This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.env.example
.gitignore
jest.config.js
package.json
README.md
src/app.js
src/config/cloudinary.js
src/config/db.js
src/config/swagger.js
src/controllers/address.controller.js
src/controllers/aggregate.controller.js
src/controllers/auth.controller.js
src/controllers/chat.controller.js
src/controllers/item.controller.js
src/controllers/notification.controller.js
src/controllers/order.controller.js
src/controllers/restaurant.controller.js
src/controllers/restaurantAddress.controller.js
src/controllers/restaurantComplete.controller.js
src/controllers/review.controller.js
src/controllers/user.controller.js
src/controllers/userComplete.controller.js
src/jobs/notificationCleanup.job.js
src/middlewares/auth.middleware.js
src/middlewares/cache.middleware.js
src/middlewares/disableCache.middleware.js
src/middlewares/errorHandler.middleware.js
src/middlewares/rateLimit.middleware.js
src/middlewares/role.middleware.js
src/middlewares/security.middleware.js
src/middlewares/upload.js
src/middlewares/validation.middleware.js
src/models/address.model.js
src/models/conversation.model.js
src/models/device.model.js
src/models/driverLocation.model.js
src/models/item.model.js
src/models/message.model.js
src/models/notification.model.js
src/models/order.model.js
src/models/restaurant.model.js
src/models/restaurantAddress.model.js
src/models/review.model.js
src/models/user.model.js
src/routes/address.routes.js
src/routes/aggregate.routes.js
src/routes/auth.routes.js
src/routes/chat.routes.js
src/routes/driver.routes.js
src/routes/health.routes.js
src/routes/item.routes.js
src/routes/notification.routes.js
src/routes/order.routes.js
src/routes/restaurant.routes.js
src/routes/restaurantAddress.routes.js
src/routes/restaurantComplete.routes.js
src/routes/review.routes.js
src/routes/user.routes.js
src/routes/userComplete.routes.js
src/server.js
src/services/chat.socket.service.js
src/services/email.service.js
src/services/healthCheck.service.js
src/services/notification.service.js
src/services/sms.service.js
src/services/socket.service.js
src/socket.js
src/utils/cache.util.js
src/utils/logger.util.js
src/utils/pagination.util.js
tests/auth.test.js
tests/cache.test.js
tests/setup.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".env.example">
# # ============================================
# # FOOD DELIVERY BACKEND - ENVIRONMENT VARIABLES
# # ============================================

# # üöÄ SERVER CONFIGURATION
# NODE_ENV=development
# PORT=3000
# API_URL=http://localhost:3000
# CLIENT_URL=http://localhost:3001
# APP_NAME="Food Delivery"

# # üì¶ DATABASE CONFIGURATION
# MONGO_URI=mongodb://localhost:27017/food_delivery
# MONGO_URI_TEST=mongodb://localhost:27017/food_delivery_test

# # üîê JWT AUTHENTICATION
# JWT_SECRET=your-super-secret-jwt-key-change-this-in-production
# JWT_EXPIRES_IN=7d
# REQUIRE_VERIFICATION=true

# # ‚òÅÔ∏è CLOUDINARY FILE UPLOAD
# CLOUDINARY_CLOUD_NAME=your-cloud-name
# CLOUDINARY_API_KEY=your-api-key
# CLOUDINARY_API_SECRET=your-api-secret

# # ‚ö° CACHE CONFIGURATION
# CACHE_TTL=300
# REDIS_URL=redis://localhost:6379

# # üìù LOGGING
# LOG_LEVEL=info
# LOG_TO_FILE=true

# # üõ°Ô∏è RATE LIMITING
# RATE_LIMIT_WINDOW_MS=900000
# RATE_LIMIT_MAX_REQUESTS=100

# # üõ°Ô∏è SECURITY
# CORS_ORIGIN=http://localhost:3001
# HELMET_ENABLED=true
# XSS_PROTECTION=true
# NOSQL_INJECTION_PROTECTION=true

# # üìß EMAIL SERVICE (Optional)
# EMAIL_ENABLED=false
# EMAIL_SERVICE=gmail
# EMAIL_USER=your-email@gmail.com
# EMAIL_PASS=your-app-password
# EMAIL_FROM=noreply@fooddelivery.com

# # üì± SMS SERVICE (Optional)
# SMS_ENABLED=false
# SMS_PROVIDER=twilio
# TWILIO_ACCOUNT_SID=your-account-sid
# TWILIO_AUTH_TOKEN=your-auth-token
# TWILIO_PHONE_NUMBER=+1234567890

# # üîî PUSH NOTIFICATIONS (Optional)
# FCM_SERVER_KEY=your-fcm-server-key
# APN_KEY_ID=your-apn-key-id
# APN_TEAM_ID=your-apn-team-id
# APN_KEY_PATH=path/to/apn/key.p8

# # üí∞ PAYMENT GATEWAY (Optional)
# STRIPE_SECRET_KEY=your-stripe-secret-key
# STRIPE_PUBLISHABLE_KEY=your-stripe-publishable-key

# # üìä ANALYTICS (Optional)
# GOOGLE_ANALYTICS_ID=your-ga-id
# MIXPANEL_TOKEN=your-mixpanel-token

# # ‚öôÔ∏è PERFORMANCE
# REQUEST_SIZE_LIMIT=10mb
# COMPRESSION_ENABLED=true
# CACHE_ENABLED=true

# # üß™ TESTING
# TEST_TIMEOUT=30000

# # ============================================
# # DEVELOPMENT SPECIFIC
# # ============================================
# # NODE_ENV=development
# DEBUG=true
# LOG_LEVEL=debug

# # ============================================
# # PRODUCTION SPECIFIC
# # ============================================
# # NODE_ENV=production
# # DEBUG=false
# # LOG_LEVEL=warn
# # CACHE_TTL=600
</file>

<file path=".gitignore">
.env 

node_modules
</file>

<file path="jest.config.js">
module.exports = {
  testEnvironment: 'node',
  setupFilesAfterEnv: ['./tests/setup.js'],
  testMatch: ['**/tests/**/*.test.js'],
  collectCoverageFrom: [
    'src/**/*.js',
    '!src/server.js',
    '!src/app.js'
  ],
  coverageThreshold: {
    global: {
      branches: 70,
      functions: 70,
      lines: 70,
      statements: 70
    }
  },
  verbose: true
};
</file>

<file path="README.md">
# üöÄ Food Delivery Backend API

A complete backend solution for food delivery applications with real-time features.

## Features

- ‚úÖ User authentication & authorization
- ‚úÖ Restaurant management
- ‚úÖ Order processing & tracking
- ‚úÖ Real-time chat
- ‚úÖ Notification system
- ‚úÖ File upload (Cloudinary)
- ‚úÖ Caching system
- ‚úÖ Rate limiting
- ‚úÖ Health checks
- ‚úÖ API documentation
- ‚úÖ Error handling
- ‚úÖ Logging

## Tech Stack

- **Runtime**: Node.js
- **Framework**: Express.js
- **Database**: MongoDB with Mongoose
- **Real-time**: Socket.io
- **File Upload**: Cloudinary + Multer
- **Authentication**: JWT
- **Caching**: Node-cache
- **Logging**: Winston
- **Testing**: Jest + Supertest
- **Documentation**: Swagger/OpenAPI

## Getting Started

### Prerequisites
- Node.js >= 14
- MongoDB
- Cloudinary account
- npm or yarn

### Installation

1. Clone the repository
```bash
git clone https://github.com/yourusername/food-delivery-backend.git
cd food-delivery-backend
</file>

<file path="src/config/cloudinary.js">
const cloudinary = require("cloudinary").v2;
require("dotenv").config();

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

module.exports = cloudinary;
</file>

<file path="src/config/db.js">
const mongoose = require("mongoose");

const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGO_URI);
    console.log("MongoDB Connected ‚úÖ");
  } catch (error) {
    console.error("MongoDB Error ‚ùå", error.message);
    process.exit(1);
  }
};

module.exports = connectDB;
</file>

<file path="src/config/swagger.js">
const swaggerJsdoc = require('swagger-jsdoc');

const options = {
  definition: {
    openapi: '3.0.0',
    info: {
      title: 'Food Delivery API',
      version: '1.0.0',
      description: 'API documentation for Food Delivery Application',
      contact: {
        name: 'API Support',
        email: 'support@fooddelivery.com'
      },
      license: {
        name: 'MIT',
        url: 'https://opensource.org/licenses/MIT'
      }
    },
    servers: [
      {
        url: process.env.API_URL || 'http://localhost:3000/api',
        description: process.env.NODE_ENV === 'production' ? 'Production server' : 'Development server'
      }
    ],
    components: {
      securitySchemes: {
        bearerAuth: {
          type: 'http',
          scheme: 'bearer',
          bearerFormat: 'JWT'
        }
      },
      schemas: {
        User: {
          type: 'object',
          required: ['name', 'phone', 'password'],
          properties: {
            name: {
              type: 'string',
              example: 'John Doe'
            },
            phone: {
              type: 'string',
              example: '+1234567890'
            },
            email: {
              type: 'string',
              example: 'john@example.com'
            },
            password: {
              type: 'string',
              format: 'password',
              example: 'password123'
            }
          }
        },
        Error: {
          type: 'object',
          properties: {
            success: {
              type: 'boolean',
              example: false
            },
            message: {
              type: 'string',
              example: 'Error message'
            }
          }
        }
      },
      responses: {
        UnauthorizedError: {
          description: 'Access token is missing or invalid'
        },
        NotFoundError: {
          description: 'The requested resource was not found'
        },
        ValidationError: {
          description: 'Validation failed'
        }
      }
    },
    tags: [
      {
        name: 'Auth',
        description: 'Authentication endpoints'
      },
      {
        name: 'Users',
        description: 'User management endpoints'
      },
      {
        name: 'Restaurants',
        description: 'Restaurant management endpoints'
      },
      {
        name: 'Orders',
        description: 'Order management endpoints'
      },
      {
        name: 'Chat',
        description: 'Chat and messaging endpoints'
      },
      {
        name: 'Notifications',
        description: 'Notification management endpoints'
      }
    ]
  },
  apis: [
    './src/routes/*.js', 
    './src/controllers/*.js',
    './src/middlewares/*.js' // ÿ•ÿ∂ÿßŸÅÿ©
  ]
};

const specs = swaggerJsdoc(options);

module.exports = specs;
</file>

<file path="src/controllers/address.controller.js">
const Address = require("../models/address.model");

// ‚ûï ÿ•ÿ∂ÿßŸÅÿ© ÿπŸÜŸàÿßŸÜ
exports.createAddress = async (req, res) => {
  try {
    const address = await Address.create({
      ...req.body,
      user: req.user.id,
    });

    // ŸÑŸà ÿßŸÑÿπŸÜŸàÿßŸÜ ÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä ‚Üí ŸÜŸÑÿ∫Ÿä ÿßŸÑÿ®ŸÇŸäÿ©
    if (address.isDefault) {
      await Address.updateMany(
        { user: req.user.id, _id: { $ne: address._id } },
        { isDefault: false }
      );
    }

    res.status(201).json(address);
  } catch (error) {
    res.status(500).json({ message: "Failed to create address" });
  }
};

// üìç ÿ¨ŸÑÿ® ÿπŸÜÿßŸàŸäŸÜ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
exports.getMyAddresses = async (req, res) => {
  const addresses = await Address.find({ user: req.user.id });
  res.json(addresses);
};

// üóë ÿ≠ÿ∞ŸÅ ÿπŸÜŸàÿßŸÜ
exports.deleteAddress = async (req, res) => {
  await Address.findOneAndDelete({
    _id: req.params.id,
    user: req.user.id,
  });

  res.json({ message: "Address deleted" });
};
</file>

<file path="src/controllers/chat.controller.js">
const Conversation = require("../models/conversation.model");
const Message = require("../models/message.model");
const User = require("../models/user.model");
const Order = require("../models/order.model");
const chatSocketService = require("../services/chat.socket.service");
const cache = require("../utils/cache.util");
const PaginationUtils = require("../utils/pagination.util");

/**
 * üí¨ ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ŸÖÿ≠ÿßÿØÿ´ÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
 * GET /api/chat/conversations
 */
exports.getUserConversations = async (req, res) => {
  try {
    const userId = req.user.id;
    const options = {
      page: parseInt(req.query.page) || 1,
      limit: Math.min(parseInt(req.query.limit) || 20, 50),
      type: req.query.type,
      archived: req.query.archived === "true",
      includeExpired: req.query.includeExpired === "true",
    };

    const cacheKey = `chat:conversations:${userId}:${JSON.stringify(options)}`;
    const cachedData = cache.get(cacheKey);
    
    if (cachedData) {
      console.log("üì¶ Serving conversations from cache");
      return res.json({
        ...cachedData,
        cached: true,
      });
    }

    const result = await Conversation.getUserConversations(userId, options);
    
    // ÿ™ÿ≠ÿØŸäÿ´ ÿπÿØÿØ ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿ∫Ÿäÿ± ÿßŸÑŸÖŸÇÿ±Ÿàÿ°ÿ©
    for (const conversation of result.conversations) {
      conversation.unreadCount = await Message.getUnreadCount(
        conversation._id,
        userId
      );
      
      // ÿ•ÿ∂ÿßŸÅÿ© ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿ•ÿ∂ÿßŸÅŸäÿ©
      conversation.isActive = conversation.expiresAt 
        ? conversation.expiresAt > new Date() 
        : true;
        
      conversation.isMuted = conversation.notificationSettings?.mute || false;
    }

    const responseData = {
      success: true,
      data: {
        conversations: result.conversations,
        pagination: result.pagination,
        summary: {
          total: result.pagination.total,
          unreadCount: result.conversations.reduce(
            (sum, conv) => sum + (conv.unreadCount || 0), 0
          ),
          activeCount: result.conversations.filter(
            conv => conv.isActive
          ).length,
        },
      },
      cached: false,
    };

    // ÿ≠ŸÅÿ∏ ŸÅŸä ÿßŸÑŸÉÿßÿ¥ ŸÑŸÖÿØÿ© ÿØŸÇŸäŸÇÿ™ŸäŸÜ
    cache.set(cacheKey, responseData, 120);
    
    res.json(responseData);
  } catch (error) {
    console.error("‚ùå Get conversations error:", error.message);
    res.status(500).json({
      success: false,
      message: "Failed to get conversations",
    });
  }
};

/**
 * üí¨ ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ŸÖÿ≠ÿßÿØÿ´ÿ© ŸÖÿπŸäŸÜÿ©
 * GET /api/chat/conversations/:id
 */
exports.getConversation = async (req, res) => {
  try {
    const userId = req.user.id;
    const conversationId = req.params.id;

    const conversation = await Conversation.findOne({
      _id: conversationId,
      participants: userId,
      deletedAt: null,
    })
      .populate("participants", "name image role isOnline")
      .populate("lastMessage")
      .populate("metadata.order.orderId", "status totalPrice")
      .populate("metadata.support.assignedTo", "name image")
      .lean();

    if (!conversation) {
      return res.status(404).json({
        success: false,
        message: "Conversation not found",
      });
    }

    // ÿ≠ÿ≥ÿßÿ® ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿ∫Ÿäÿ± ÿßŸÑŸÖŸÇÿ±Ÿàÿ°ÿ©
    conversation.unreadCount = await Message.getUnreadCount(conversationId, userId);
    
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ŸÜÿ¥ÿßÿ∑ ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
    conversation.isActive = conversation.expiresAt 
      ? conversation.expiresAt > new Date() 
      : true;
      
    conversation.isMuted = conversation.notificationSettings?.mute || false;
    
    // ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
    const stats = await Message.aggregate([
      { $match: { conversation: conversation._id } },
      {
        $facet: {
          totalMessages: [{ $count: "count" }],
          byType: [
            {
              $group: {
                _id: "$type",
                count: { $sum: 1 },
              },
            },
          ],
          bySender: [
            {
              $group: {
                _id: "$sender",
                count: { $sum: 1 },
              },
            },
            { $sort: { count: -1 } },
            { $limit: 5 },
          ],
          recentActivity: [
            {
              $group: {
                _id: {
                  $dateToString: { format: "%Y-%m-%d", date: "$delivery.sentAt" },
                },
                count: { $sum: 1 },
              },
            },
            { $sort: { _id: -1 } },
            { $limit: 7 },
          ],
        },
      },
    ]);

    res.json({
      success: true,
      data: {
        conversation,
        stats: {
          total: stats[0]?.totalMessages[0]?.count || 0,
          byType: stats[0]?.byType || [],
          bySender: stats[0]?.bySender || [],
          recentActivity: stats[0]?.recentActivity || [],
        },
      },
    });
  } catch (error) {
    console.error("‚ùå Get conversation error:", error.message);
    res.status(500).json({
      success: false,
      message: "Failed to get conversation",
    });
  }
};

/**
 * üí¨ ÿ•ŸÜÿ¥ÿßÿ° ŸÖÿ≠ÿßÿØÿ´ÿ© ÿ¨ÿØŸäÿØÿ©
 * POST /api/chat/conversations
 */
exports.createConversation = async (req, res) => {
  try {
    const userId = req.user.id;
    const { type, participantIds, title, description, metadata } = req.body;

    if (!type || !participantIds || !Array.isArray(participantIds)) {
      return res.status(400).json({
        success: false,
        message: "Type and participantIds are required",
      });
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ Ÿàÿ¨ŸàÿØ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ
    const users = await User.find({ _id: { $in: participantIds } });
    
    if (users.length !== participantIds.length) {
      return res.status(400).json({
        success: false,
        message: "Some users not found",
      });
    }

    let conversation;

    switch (type) {
      case "direct":
        if (participantIds.length !== 1) {
          return res.status(400).json({
            success: false,
            message: "Direct chat requires exactly one other participant",
          });
        }
        
        conversation = await Conversation.createDirectChat(userId, participantIds[0]);
        break;

      case "support":
        conversation = await Conversation.createSupportChat(
          userId,
          metadata?.department || "general"
        );
        break;

      case "order":
        if (!metadata?.orderId) {
          return res.status(400).json({
            success: false,
            message: "Order ID is required for order chat",
          });
        }
        
        const order = await Order.findById(metadata.orderId);
        if (!order) {
          return res.status(404).json({
            success: false,
            message: "Order not found",
          });
        }

        conversation = await Conversation.createOrderChat(
          metadata.orderId,
          userId,
          order.driver,
          order.restaurant
        );
        break;

      case "group":
        if (!title) {
          return res.status(400).json({
            success: false,
            message: "Title is required for group chat",
          });
        }
        
        conversation = await Conversation.createGroupChat(
          userId,
          title,
          description,
          participantIds,
          metadata?.isPublic || false
        );
        break;

      default:
        return res.status(400).json({
          success: false,
          message: "Invalid conversation type",
        });
    }

    // ÿ•ÿ®ÿ∑ÿßŸÑ ÿßŸÑŸÉÿßÿ¥
    cache.invalidatePattern(`chat:conversations:${userId}:*`);
    participantIds.forEach(participantId => {
      cache.invalidatePattern(`chat:conversations:${participantId}:*`);
    });

    // ÿ•ÿ±ÿ≥ÿßŸÑ ÿ•ÿ¥ÿπÿßÿ± ŸÑŸÑŸÖÿ¥ÿßÿ±ŸÉŸäŸÜ
    const notificationService = require("../services/notification.service");
    
    for (const participantId of participantIds) {
      if (participantId !== userId) {
        await notificationService.sendNotification({
          user: participantId,
          type: "new_message",
          title: "ŸÖÿ≠ÿßÿØÿ´ÿ© ÿ¨ÿØŸäÿØÿ©",
          content: type === "direct" 
            ? `${req.user.name} ÿ®ÿØÿ£ ŸÖÿ≠ÿßÿØÿ´ÿ© ŸÖÿπŸÉ`
            : `ÿ™ŸÖÿ™ ÿ•ÿ∂ÿßŸÅÿ™ŸÉ ÿ•ŸÑŸâ ŸÖÿ≠ÿßÿØÿ´ÿ© ${conversation.title || "ÿ¨ÿØŸäÿØÿ©"}`,
          data: {
            conversationId: conversation._id,
            type: conversation.type,
            createdBy: userId,
          },
          priority: "medium",
          link: `/chat/${conversation._id}`,
          icon: "üí¨",
          tags: ["chat", "conversation", `conversation_${conversation._id}`],
        });
      }
    }

    res.status(201).json({
      success: true,
      message: "Conversation created successfully",
      data: {
        conversation,
      },
    });
  } catch (error) {
    console.error("‚ùå Create conversation error:", error.message);
    res.status(500).json({
      success: false,
      message: "Failed to create conversation",
    });
  }
};

/**
 * üí¨ ÿ™ÿ≠ÿØŸäÿ´ ŸÖÿ≠ÿßÿØÿ´ÿ©
 * PUT /api/chat/conversations/:id
 */
exports.updateConversation = async (req, res) => {
  try {
    const userId = req.user.id;
    const conversationId = req.params.id;
    const updateData = req.body;

    const conversation = await Conversation.findOne({
      _id: conversationId,
      participants: userId,
      deletedAt: null,
    });

    if (!conversation) {
      return res.status(404).json({
        success: false,
        message: "Conversation not found",
      });
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿµŸÑÿßÿ≠Ÿäÿßÿ™ ŸÑŸÑÿ™ÿ≠ÿØŸäÿ´
    if (conversation.type === "group") {
      const isAdmin = conversation.metadata.group.admins.includes(userId);
      if (!isAdmin && (updateData.title || updateData.description || updateData.image)) {
        return res.status(403).json({
          success: false,
          message: "Only admins can update group details",
        });
      }
    }

    // ÿßŸÑÿ≠ŸÇŸàŸÑ ÿßŸÑŸÖÿ≥ŸÖŸàÿ≠ ÿ®ÿ™ÿ≠ÿØŸäÿ´Ÿáÿß
    const allowedUpdates = [
      "title",
      "description",
      "image",
      "notificationSettings",
      "privacySettings",
      "tags",
    ];

    const filteredUpdates = {};
    Object.keys(updateData).forEach(key => {
      if (allowedUpdates.includes(key)) {
        filteredUpdates[key] = updateData[key];
      }
    });

    // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
    Object.assign(conversation, filteredUpdates);
    await conversation.save();

    // ÿ•ÿ®ÿ∑ÿßŸÑ ÿßŸÑŸÉÿßÿ¥
    conversation.participants.forEach(participantId => {
      cache.invalidatePattern(`chat:conversations:${participantId}:*`);
    });

    // ÿ•ÿ±ÿ≥ÿßŸÑ ÿ™ÿ≠ÿØŸäÿ´ ÿπÿ®ÿ± Socket
    chatSocketService.updateConversationStatus(conversationId, {
      type: "updated",
      updatedBy: userId,
      updates: Object.keys(filteredUpdates),
    });

    res.json({
      success: true,
      message: "Conversation updated successfully",
      data: {
        conversation,
      },
    });
  } catch (error) {
    console.error("‚ùå Update conversation error:", error.message);
    res.status(500).json({
      success: false,
      message: "Failed to update conversation",
    });
  }
};

/**
 * üí¨ ÿ•ÿ∂ÿßŸÅÿ© ŸÖÿ¥ÿßÿ±ŸÉ ŸÑŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
 * POST /api/chat/conversations/:id/participants
 */
exports.addParticipant = async (req, res) => {
  try {
    const userId = req.user.id;
    const conversationId = req.params.id;
    const { participantId } = req.body;

    const conversation = await Conversation.findOne({
      _id: conversationId,
      participants: userId,
      deletedAt: null,
    });

    if (!conversation) {
      return res.status(404).json({
        success: false,
        message: "Conversation not found",
      });
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿµŸÑÿßÿ≠Ÿäÿßÿ™
    if (conversation.type === "group") {
      const isAdmin = conversation.metadata.group.admins.includes(userId);
      if (!isAdmin) {
        return res.status(403).json({
          success: false,
          message: "Only admins can add participants",
        });
      }
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ ŸÑŸÑŸÖÿ¥ÿßÿ±ŸÉŸäŸÜ
    if (conversation.type === "group" && 
        conversation.participants.length >= conversation.metadata.group.maxParticipants) {
      return res.status(400).json({
        success: false,
        message: "Maximum participants reached",
      });
    }

    // ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑŸÖÿ¥ÿßÿ±ŸÉ
    await conversation.addParticipant(participantId);

    // ÿ•ÿ®ÿ∑ÿßŸÑ ÿßŸÑŸÉÿßÿ¥
    cache.invalidatePattern(`chat:conversations:${participantId}:*`);

    // ÿ•ÿ±ÿ≥ÿßŸÑ ÿ•ÿ¥ÿπÿßÿ± ŸÑŸÑŸÖÿ¥ÿßÿ±ŸÉ ÿßŸÑÿ¨ÿØŸäÿØ
    const notificationService = require("../services/notification.service");
    await notificationService.sendNotification({
      user: participantId,
      type: "new_message",
      title: "ÿ™ŸÖÿ™ ÿ•ÿ∂ÿßŸÅÿ™ŸÉ ÿ•ŸÑŸâ ŸÖÿ≠ÿßÿØÿ´ÿ©",
      content: conversation.title 
        ? `ÿ™ŸÖÿ™ ÿ•ÿ∂ÿßŸÅÿ™ŸÉ ÿ•ŸÑŸâ ŸÖÿ≠ÿßÿØÿ´ÿ© ${conversation.title}`
        : "ÿ™ŸÖÿ™ ÿ•ÿ∂ÿßŸÅÿ™ŸÉ ÿ•ŸÑŸâ ŸÖÿ≠ÿßÿØÿ´ÿ© ÿ¨ÿØŸäÿØÿ©",
      data: {
        conversationId: conversation._id,
        addedBy: userId,
      },
      priority: "medium",
      link: `/chat/${conversation._id}`,
      icon: "üë•",
      tags: ["chat", "group", `conversation_${conversation._id}`],
    });

    // ÿ•ÿ±ÿ≥ÿßŸÑ ÿ™ÿ≠ÿØŸäÿ´ ÿπÿ®ÿ± Socket
    chatSocketService.addParticipantToChat(conversationId, participantId);

    res.json({
      success: true,
      message: "Participant added successfully",
      data: {
        conversationId,
        participantId,
      },
    });
  } catch (error) {
    console.error("‚ùå Add participant error:", error.message);
    res.status(500).json({
      success: false,
      message: "Failed to add participant",
    });
  }
};

/**
 * üí¨ ÿ•ÿ≤ÿßŸÑÿ© ŸÖÿ¥ÿßÿ±ŸÉ ŸÖŸÜ ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
 * DELETE /api/chat/conversations/:id/participants/:participantId
 */
exports.removeParticipant = async (req, res) => {
  try {
    const userId = req.user.id;
    const { id: conversationId, participantId } = req.params;

    const conversation = await Conversation.findOne({
      _id: conversationId,
      participants: userId,
      deletedAt: null,
    });

    if (!conversation) {
      return res.status(404).json({
        success: false,
        message: "Conversation not found",
      });
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿµŸÑÿßÿ≠Ÿäÿßÿ™
    if (conversation.type === "group") {
      const isAdmin = conversation.metadata.group.admins.includes(userId);
      const isSelf = participantId === userId;
      
      if (!isAdmin && !isSelf) {
        return res.status(403).json({
          success: false,
          message: "Only admins can remove other participants",
        });
      }
    }

    // ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑŸÖÿ¥ÿßÿ±ŸÉ
    await conversation.removeParticipant(participantId);

    // ÿ•ÿ®ÿ∑ÿßŸÑ ÿßŸÑŸÉÿßÿ¥
    cache.invalidatePattern(`chat:conversations:${participantId}:*`);

    // ÿ•ÿ±ÿ≥ÿßŸÑ ÿ™ÿ≠ÿØŸäÿ´ ÿπÿ®ÿ± Socket
    chatSocketService.removeParticipantFromChat(conversationId, participantId);

    res.json({
      success: true,
      message: "Participant removed successfully",
      data: {
        conversationId,
        participantId,
        removedBy: userId,
      },
    });
  } catch (error) {
    console.error("‚ùå Remove participant error:", error.message);
    res.status(500).json({
      success: false,
      message: "Failed to remove participant",
    });
  }
};

/**
 * üí¨ ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
 * GET /api/chat/conversations/:id/messages
 */
exports.getConversationMessages = async (req, res) => {
  try {
    const userId = req.user.id;
    const conversationId = req.params.id;
    
    const options = {
      page: parseInt(req.query.page) || 1,
      limit: Math.min(parseInt(req.query.limit) || 50, 100),
      before: req.query.before,
      after: req.query.after,
      types: req.query.types ? req.query.types.split(",") : [],
      includeDeleted: req.query.includeDeleted === "true",
      includeSystem: req.query.includeSystem !== "false",
    };

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ŸÖÿ¥ÿßÿ±ŸÉÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÅŸä ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
    const conversation = await Conversation.findOne({
      _id: conversationId,
      participants: userId,
      deletedAt: null,
    });

    if (!conversation) {
      return res.status(404).json({
        success: false,
        message: "Conversation not found",
      });
    }

    const cacheKey = `chat:messages:${conversationId}:${JSON.stringify(options)}`;
    const cachedData = cache.get(cacheKey);
    
    if (cachedData) {
      console.log("üì¶ Serving messages from cache");
      return res.json({
        ...cachedData,
        cached: true,
      });
    }

    const result = await Message.getConversationMessages(conversationId, options);

    // ÿ™ÿ≠ÿØŸäÿ´ ÿ≠ÿßŸÑÿ© ÿßŸÑŸÇÿ±ÿßÿ°ÿ© ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ≠ÿßŸÑŸä
    if (options.page === 1) {
      await Message.markAllAsRead(conversationId, userId);
      
      // ÿ•ÿ®ÿ∑ÿßŸÑ ÿßŸÑŸÉÿßÿ¥
      cache.invalidatePattern(`chat:conversations:${userId}:*`);
    }

    const responseData = {
      success: true,
      data: {
        messages: result.messages,
        pagination: result.pagination,
        conversation: {
          id: conversation._id,
          type: conversation.type,
          title: conversation.title,
          participants: conversation.participants.length,
        },
      },
      cached: false,
    };

    // ÿ≠ŸÅÿ∏ ŸÅŸä ÿßŸÑŸÉÿßÿ¥ ŸÑŸÖÿØÿ© ÿØŸÇŸäŸÇÿ©
    cache.set(cacheKey, responseData, 60);
    
    res.json(responseData);
  } catch (error) {
    console.error("‚ùå Get messages error:", error.message);
    res.status(500).json({
      success: false,
      message: "Failed to get messages",
    });
  }
};

/**
 * üí¨ ÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ÿ≥ÿßŸÑÿ©
 * POST /api/chat/conversations/:id/messages
 */
exports.sendMessage = async (req, res) => {
  try {
    const userId = req.user.id;
    const conversationId = req.params.id;
    const { content, type = "text", replyTo = null } = req.body;

    if (!content || content.trim().length === 0) {
      return res.status(400).json({
        success: false,
        message: "Message content is required",
      });
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ŸÖÿ¥ÿßÿ±ŸÉÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÅŸä ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
    const conversation = await Conversation.findOne({
      _id: conversationId,
      participants: userId,
      deletedAt: null,
    });

    if (!conversation) {
      return res.status(404).json({
        success: false,
        message: "Conversation not found",
      });
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ≠ÿßŸÑÿ© ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
    if (!conversation.isActive) {
      return res.status(400).json({
        success: false,
        message: "Conversation is not active",
      });
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸÖÿ±ÿØ ÿπŸÑŸäŸáÿß
    if (replyTo) {
      const repliedMessage = await Message.findOne({
        _id: replyTo,
        conversation: conversationId,
      });
      
      if (!repliedMessage) {
        return res.status(404).json({
          success: false,
          message: "Replied message not found",
        });
      }
    }

    // ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©
    const message = await Message.createTextMessage(
      conversationId,
      userId,
      content,
      replyTo
    );

    // ÿ¨ŸÑÿ® ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ŸÖÿπ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÉÿßŸÖŸÑÿ©
    const populatedMessage = await Message.findById(message._id)
      .populate("sender", "name image role")
      .populate("replyTo", "content.text sender type delivery.sentAt")
      .lean();

    // ÿ•ÿ®ÿ∑ÿßŸÑ ÿßŸÑŸÉÿßÿ¥
    conversation.participants.forEach(participantId => {
      cache.invalidatePattern(`chat:conversations:${participantId}:*`);
      cache.invalidatePattern(`chat:messages:${conversationId}:*`);
    });

    // ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿπÿ®ÿ± Socket
    chatSocketService.sendMessage(conversationId, populatedMessage);

    res.status(201).json({
      success: true,
      message: "Message sent successfully",
      data: {
        message: populatedMessage,
      },
    });
  } catch (error) {
    console.error("‚ùå Send message error:", error.message);
    res.status(500).json({
      success: false,
      message: "Failed to send message",
    });
  }
};

/**
 * üí¨ ÿ™ÿ≠ÿØŸäÿ´ ÿ±ÿ≥ÿßŸÑÿ©
 * PUT /api/chat/conversations/:conversationId/messages/:messageId
 */
exports.updateMessage = async (req, res) => {
  try {
    const userId = req.user.id;
    const { conversationId, messageId } = req.params;
    const { content } = req.body;

    if (!content || content.trim().length === 0) {
      return res.status(400).json({
        success: false,
        message: "Message content is required",
      });
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ŸÖÿ¥ÿßÿ±ŸÉÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÅŸä ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
    const conversation = await Conversation.findOne({
      _id: conversationId,
      participants: userId,
      deletedAt: null,
    });

    if (!conversation) {
      return res.status(404).json({
        success: false,
        message: "Conversation not found",
      });
    }

    // ÿ¨ŸÑÿ® ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©
    const message = await Message.findOne({
      _id: messageId,
      conversation: conversationId,
      sender: userId,
    });

    if (!message) {
      return res.status(404).json({
        success: false,
        message: "Message not found or you don't have permission to edit it",
      });
    }

    // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©
    await message.edit({ text: content });

    // ÿ•ÿ®ÿ∑ÿßŸÑ ÿßŸÑŸÉÿßÿ¥
    cache.invalidatePattern(`chat:messages:${conversationId}:*`);

    // ÿ•ÿ±ÿ≥ÿßŸÑ ÿ™ÿ≠ÿØŸäÿ´ ÿπÿ®ÿ± Socket
    const io = require("../socket").io;
    io.to(`chat:${conversationId}`).emit("chat:message:edited", {
      conversationId,
      messageId,
      newContent: content,
      editedBy: userId,
      timestamp: new Date(),
    });

    res.json({
      success: true,
      message: "Message updated successfully",
      data: {
        messageId,
        newContent: content,
      },
    });
  } catch (error) {
    console.error("‚ùå Update message error:", error.message);
    res.status(500).json({
      success: false,
      message: "Failed to update message",
    });
  }
};

/**
 * üí¨ ÿ≠ÿ∞ŸÅ ÿ±ÿ≥ÿßŸÑÿ©
 * DELETE /api/chat/conversations/:conversationId/messages/:messageId
 */
exports.deleteMessage = async (req, res) => {
  try {
    const userId = req.user.id;
    const { conversationId, messageId } = req.params;

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ŸÖÿ¥ÿßÿ±ŸÉÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÅŸä ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
    const conversation = await Conversation.findOne({
      _id: conversationId,
      participants: userId,
      deletedAt: null,
    });

    if (!conversation) {
      return res.status(404).json({
        success: false,
        message: "Conversation not found",
      });
    }

    // ÿ¨ŸÑÿ® ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©
    const message = await Message.findOne({
      _id: messageId,
      conversation: conversationId,
    });

    if (!message) {
      return res.status(404).json({
        success: false,
        message: "Message not found",
      });
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿµŸÑÿßÿ≠Ÿäÿßÿ™
    const isSender = message.sender.toString() === userId.toString();
    const isAdmin = req.user.role === "admin";
    
    if (!isSender && !isAdmin) {
      return res.status(403).json({
        success: false,
        message: "You don't have permission to delete this message",
      });
    }

    // ÿ≠ÿ∞ŸÅ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©
    await message.softDelete(userId, isSender ? "sender" : "admin");

    // ÿ•ÿ®ÿ∑ÿßŸÑ ÿßŸÑŸÉÿßÿ¥
    cache.invalidatePattern(`chat:messages:${conversationId}:*`);

    // ÿ•ÿ±ÿ≥ÿßŸÑ ÿ™ÿ≠ÿØŸäÿ´ ÿπÿ®ÿ± Socket
    const io = require("../socket").io;
    io.to(`chat:${conversationId}`).emit("chat:message:deleted", {
      conversationId,
      messageId,
      deletedBy: userId,
      timestamp: new Date(),
    });

    res.json({
      success: true,
      message: "Message deleted successfully",
      data: {
        messageId,
        deletedBy: userId,
      },
    });
  } catch (error) {
    console.error("‚ùå Delete message error:", error.message);
    res.status(500).json({
      success: false,
      message: "Failed to delete message",
    });
  }
};

/**
 * üí¨ ÿ•ÿ∂ÿßŸÅÿ© ÿ±ÿØ ŸÅÿπŸÑ ÿπŸÑŸâ ÿ±ÿ≥ÿßŸÑÿ©
 * POST /api/chat/conversations/:conversationId/messages/:messageId/reactions
 */
exports.addReaction = async (req, res) => {
  try {
    const userId = req.user.id;
    const { conversationId, messageId } = req.params;
    const { emoji } = req.body;

    if (!emoji) {
      return res.status(400).json({
        success: false,
        message: "Emoji is required",
      });
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ŸÖÿ¥ÿßÿ±ŸÉÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÅŸä ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
    const conversation = await Conversation.findOne({
      _id: conversationId,
      participants: userId,
      deletedAt: null,
    });

    if (!conversation) {
      return res.status(404).json({
        success: false,
        message: "Conversation not found",
      });
    }

    // ÿ¨ŸÑÿ® ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©
    const message = await Message.findOne({
      _id: messageId,
      conversation: conversationId,
    });

    if (!message) {
      return res.status(404).json({
        success: false,
        message: "Message not found",
      });
    }

    // ÿ•ÿ∂ÿßŸÅÿ© ÿ±ÿØ ÿßŸÑŸÅÿπŸÑ
    await message.addReaction(userId, emoji);

    // ÿ•ÿ®ÿ∑ÿßŸÑ ÿßŸÑŸÉÿßÿ¥
    cache.invalidatePattern(`chat:messages:${conversationId}:*`);

    // ÿ•ÿ±ÿ≥ÿßŸÑ ÿ™ÿ≠ÿØŸäÿ´ ÿπÿ®ÿ± Socket
    const io = require("../socket").io;
    io.to(`chat:${conversationId}`).emit("chat:message:reaction", {
      conversationId,
      messageId,
      userId,
      emoji,
      timestamp: new Date(),
    });

    res.json({
      success: true,
      message: "Reaction added successfully",
      data: {
        messageId,
        emoji,
        userId,
      },
    });
  } catch (error) {
    console.error("‚ùå Add reaction error:", error.message);
    res.status(500).json({
      success: false,
      message: "Failed to add reaction",
    });
  }
};

/**
 * üí¨ ÿ•ÿ≤ÿßŸÑÿ© ÿ±ÿØ ŸÅÿπŸÑ ŸÖŸÜ ÿ±ÿ≥ÿßŸÑÿ©
 * DELETE /api/chat/conversations/:conversationId/messages/:messageId/reactions
 */
exports.removeReaction = async (req, res) => {
  try {
    const userId = req.user.id;
    const { conversationId, messageId } = req.params;

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ŸÖÿ¥ÿßÿ±ŸÉÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÅŸä ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
    const conversation = await Conversation.findOne({
      _id: conversationId,
      participants: userId,
      deletedAt: null,
    });

    if (!conversation) {
      return res.status(404).json({
        success: false,
        message: "Conversation not found",
      });
    }

    // ÿ¨ŸÑÿ® ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©
    const message = await Message.findOne({
      _id: messageId,
      conversation: conversationId,
    });

    if (!message) {
      return res.status(404).json({
        success: false,
        message: "Message not found",
      });
    }

    // ÿ•ÿ≤ÿßŸÑÿ© ÿ±ÿØ ÿßŸÑŸÅÿπŸÑ
    await message.removeReaction(userId);

    // ÿ•ÿ®ÿ∑ÿßŸÑ ÿßŸÑŸÉÿßÿ¥
    cache.invalidatePattern(`chat:messages:${conversationId}:*`);

    // ÿ•ÿ±ÿ≥ÿßŸÑ ÿ™ÿ≠ÿØŸäÿ´ ÿπÿ®ÿ± Socket
    const io = require("../socket").io;
    io.to(`chat:${conversationId}`).emit("chat:message:reaction:removed", {
      conversationId,
      messageId,
      userId,
      timestamp: new Date(),
    });

    res.json({
      success: true,
      message: "Reaction removed successfully",
      data: {
        messageId,
        userId,
      },
    });
  } catch (error) {
    console.error("‚ùå Remove reaction error:", error.message);
    res.status(500).json({
      success: false,
      message: "Failed to remove reaction",
    });
  }
};

/**
 * üí¨ ÿ™ÿ´ÿ®Ÿäÿ™ ÿ±ÿ≥ÿßŸÑÿ©
 * POST /api/chat/conversations/:conversationId/messages/:messageId/pin
 */
exports.pinMessage = async (req, res) => {
  try {
    const userId = req.user.id;
    const { conversationId, messageId } = req.params;

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ŸÖÿ¥ÿßÿ±ŸÉÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÅŸä ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
    const conversation = await Conversation.findOne({
      _id: conversationId,
      participants: userId,
      deletedAt: null,
    });

    if (!conversation) {
      return res.status(404).json({
        success: false,
        message: "Conversation not found",
      });
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿµŸÑÿßÿ≠Ÿäÿßÿ™ (ŸÅŸÇÿ∑ ÿßŸÑÿ£ÿØŸÖŸÜ ÿ£Ÿà ŸÖŸÜÿ¥ÿ¶ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ©)
    if (conversation.type === "group") {
      const isAdmin = conversation.metadata.group.admins.includes(userId);
      if (!isAdmin) {
        return res.status(403).json({
          success: false,
          message: "Only admins can pin messages",
        });
      }
    }

    // ÿ¨ŸÑÿ® ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©
    const message = await Message.findOne({
      _id: messageId,
      conversation: conversationId,
    });

    if (!message) {
      return res.status(404).json({
        success: false,
        message: "Message not found",
      });
    }

    // ÿ™ÿ´ÿ®Ÿäÿ™ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©
    await message.pin(userId);

    // ÿ•ÿ®ÿ∑ÿßŸÑ ÿßŸÑŸÉÿßÿ¥
    cache.invalidatePattern(`chat:messages:${conversationId}:*`);

    // ÿ•ÿ±ÿ≥ÿßŸÑ ÿ™ÿ≠ÿØŸäÿ´ ÿπÿ®ÿ± Socket
    const io = require("../socket").io;
    io.to(`chat:${conversationId}`).emit("chat:message:pinned", {
      conversationId,
      messageId,
      pinnedBy: userId,
      timestamp: new Date(),
    });

    res.json({
      success: true,
      message: "Message pinned successfully",
      data: {
        messageId,
        pinnedBy: userId,
      },
    });
  } catch (error) {
    console.error("‚ùå Pin message error:", error.message);
    res.status(500).json({
      success: false,
      message: "Failed to pin message",
    });
  }
};

/**
 * üí¨ ÿßŸÑÿ®ÿ≠ÿ´ ŸÅŸä ÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
 * GET /api/chat/conversations/:id/search
 */
exports.searchMessages = async (req, res) => {
  try {
    const userId = req.user.id;
    const conversationId = req.params.id;
    const { q: searchTerm, sender, type, dateFrom, dateTo } = req.query;

    if (!searchTerm && !sender && !type && !dateFrom && !dateTo) {
      return res.status(400).json({
        success: false,
        message: "At least one search parameter is required",
      });
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ŸÖÿ¥ÿßÿ±ŸÉÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÅŸä ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
    const conversation = await Conversation.findOne({
      _id: conversationId,
      participants: userId,
      deletedAt: null,
    });

    if (!conversation) {
      return res.status(404).json({
        success: false,
        message: "Conversation not found",
      });
    }

    const options = {
      page: parseInt(req.query.page) || 1,
      limit: Math.min(parseInt(req.query.limit) || 20, 50),
      sender: sender || null,
      types: type ? type.split(",") : ["text"],
      dateFrom: dateFrom || null,
      dateTo: dateTo || null,
    };

    const result = await Message.searchMessages(
      conversationId,
      searchTerm,
      options
    );

    res.json({
      success: true,
      data: {
        messages: result.messages,
        pagination: result.pagination,
        searchParams: {
          term: searchTerm,
          sender,
          type,
          dateFrom,
          dateTo,
        },
      },
    });
  } catch (error) {
    console.error("‚ùå Search messages error:", error.message);
    res.status(500).json({
      success: false,
      message: "Failed to search messages",
    });
  }
};

/**
 * üí¨ ÿ±ŸÅÿπ ŸÖŸÑŸÅ ŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
 * POST /api/chat/conversations/:id/upload
 */
exports.uploadFile = async (req, res) => {
  try {
    const userId = req.user.id;
    const conversationId = req.params.id;

    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: "No file uploaded",
      });
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ŸÖÿ¥ÿßÿ±ŸÉÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÅŸä ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
    const conversation = await Conversation.findOne({
      _id: conversationId,
      participants: userId,
      deletedAt: null,
    });

    if (!conversation) {
      return res.status(404).json({
        success: false,
        message: "Conversation not found",
      });
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ•ÿ∞ŸÜ ŸÑÿ±ŸÅÿπ ÿßŸÑŸÖŸÑŸÅÿßÿ™
    if (!conversation.privacySettings?.allowMedia) {
      return res.status(403).json({
        success: false,
        message: "Media upload is not allowed in this conversation",
      });
    }

    // ÿ™ÿ≠ÿØŸäÿØ ŸÜŸàÿπ ÿßŸÑŸÖŸÑŸÅ
    const mimeType = req.file.mimetype;
    let type = "file";
    
    if (mimeType.startsWith("image/")) {
      type = "image";
    } else if (mimeType.startsWith("video/")) {
      type = "video";
    } else if (mimeType.startsWith("audio/")) {
      type = "audio";
    }

    // ÿ•ŸÜÿ¥ÿßÿ° ÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸÖŸÑŸÅ
    const message = await Message.createMediaMessage(
      conversationId,
      userId,
      {
        url: req.file.path,
        filename: req.file.originalname,
        size: req.file.size,
        mimeType: req.file.mimetype,
      },
      type
    );

    // ÿ¨ŸÑÿ® ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ŸÖÿπ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÉÿßŸÖŸÑÿ©
    const populatedMessage = await Message.findById(message._id)
      .populate("sender", "name image role")
      .lean();

    // ÿ•ÿ®ÿ∑ÿßŸÑ ÿßŸÑŸÉÿßÿ¥
    conversation.participants.forEach(participantId => {
      cache.invalidatePattern(`chat:conversations:${participantId}:*`);
      cache.invalidatePattern(`chat:messages:${conversationId}:*`);
    });

    // ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿπÿ®ÿ± Socket
    chatSocketService.sendMessage(conversationId, populatedMessage);

    res.status(201).json({
      success: true,
      message: "File uploaded successfully",
      data: {
        message: populatedMessage,
      },
    });
  } catch (error) {
    console.error("‚ùå Upload file error:", error.message);
    res.status(500).json({
      success: false,
      message: "Failed to upload file",
    });
  }
};

/**
 * üí¨ ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿØÿ±ÿØÿ¥ÿ©
 * GET /api/chat/stats
 */
exports.getChatStats = async (req, res) => {
  try {
    const userId = req.user.id;

    const cacheKey = `chat:stats:${userId}`;
    const cachedData = cache.get(cacheKey);
    
    if (cachedData) {
      return res.json({
        ...cachedData,
        cached: true,
      });
    }

    const [
      totalConversations,
      unreadMessages,
      recentConversations,
      messagesByType,
      activeChats,
    ] = await Promise.all([
      // ÿßŸÑÿπÿØÿØ ÿßŸÑŸÉŸÑŸä ŸÑŸÑŸÖÿ≠ÿßÿØÿ´ÿßÿ™
      Conversation.countDocuments({
        participants: userId,
        deletedAt: null,
        archivedAt: null,
      }),

      // ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿ∫Ÿäÿ± ÿßŸÑŸÖŸÇÿ±Ÿàÿ°ÿ©
      Conversation.aggregate([
        {
          $match: {
            participants: userId,
            deletedAt: null,
          },
        },
        {
          $lookup: {
            from: "messages",
            let: { conversationId: "$_id" },
            pipeline: [
              {
                $match: {
                  $expr: {
                    $and: [
                      { $eq: ["$conversation", "$$conversationId"] },
                      { $ne: ["$sender", userId] },
                      { $not: { $in: [userId, "$delivery.readBy.user"] } },
                      { $eq: ["$deleted.isDeleted", false] },
                    ],
                  },
                },
              },
              { $count: "count" },
            ],
            as: "unreadMessages",
          },
        },
        {
          $group: {
            _id: null,
            totalUnread: { $sum: { $arrayElemAt: ["$unreadMessages.count", 0] } },
          },
        },
      ]),

      // ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿßÿ™ ÿßŸÑÿ≠ÿØŸäÿ´ÿ©
      Conversation.find({
        participants: userId,
        deletedAt: null,
        archivedAt: null,
      })
        .sort({ lastActivity: -1 })
        .limit(5)
        .populate("participants", "name image")
        .populate("lastMessage")
        .lean(),

      // ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿ≠ÿ≥ÿ® ÿßŸÑŸÜŸàÿπ
      Message.aggregate([
        {
          $lookup: {
            from: "conversations",
            localField: "conversation",
            foreignField: "_id",
            as: "conversationData",
          },
        },
        { $unwind: "$conversationData" },
        {
          $match: {
            "conversationData.participants": userId,
            "deleted.isDeleted": false,
          },
        },
        {
          $group: {
            _id: "$type",
            count: { $sum: 1 },
            totalSize: { $sum: "$content.media.size" },
          },
        },
      ]),

      // ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿßÿ™ ÿßŸÑŸÜÿ¥ÿ∑ÿ©
      Conversation.countDocuments({
        participants: userId,
        deletedAt: null,
        archivedAt: null,
        lastActivity: { $gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) },
      }),
    ]);

    const stats = {
      success: true,
      data: {
        overview: {
          totalConversations,
          unreadMessages: unreadMessages[0]?.totalUnread || 0,
          activeChats,
          totalMessages: messagesByType.reduce((sum, item) => sum + item.count, 0),
        },
        byType: messagesByType.reduce((acc, item) => {
          acc[item._id] = item.count;
          return acc;
        }, {}),
        recentConversations: recentConversations.map(conv => ({
          id: conv._id,
          title: conv.title,
          type: conv.type,
          lastActivity: conv.lastActivity,
          unreadCount: conv.unreadCount || 0,
          participants: conv.participants.slice(0, 3),
        })),
        usage: {
          storageUsed: messagesByType.reduce((sum, item) => sum + (item.totalSize || 0), 0),
          averageMessagesPerDay: await calculateAverageMessages(userId),
          busiestDay: await getBusiestChatDay(userId),
        },
      },
      cached: false,
    };

    // ÿ≠ŸÅÿ∏ ŸÅŸä ÿßŸÑŸÉÿßÿ¥ ŸÑŸÖÿØÿ© 5 ÿØŸÇÿßÿ¶ŸÇ
    cache.set(cacheKey, stats, 300);
    
    res.json(stats);
  } catch (error) {
    console.error("‚ùå Get chat stats error:", error.message);
    res.status(500).json({
      success: false,
      message: "Failed to get chat statistics",
    });
  }
};

// ÿØŸàÿßŸÑ ŸÖÿ≥ÿßÿπÿØÿ©
async function calculateAverageMessages(userId) {
  const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
  
  const result = await Message.aggregate([
    {
      $lookup: {
        from: "conversations",
        localField: "conversation",
        foreignField: "_id",
        as: "conversationData",
      },
    },
    { $unwind: "$conversationData" },
    {
      $match: {
        "conversationData.participants": userId,
        "delivery.sentAt": { $gte: thirtyDaysAgo },
      },
    },
    {
      $group: {
        _id: {
          $dateToString: { format: "%Y-%m-%d", date: "$delivery.sentAt" },
        },
        messageCount: { $sum: 1 },
      },
    },
    {
      $group: {
        _id: null,
        average: { $avg: "$messageCount" },
        totalDays: { $sum: 1 },
      },
    },
  ]);

  return result[0]?.average || 0;
}

async function getBusiestChatDay(userId) {
  const result = await Message.aggregate([
    {
      $lookup: {
        from: "conversations",
        localField: "conversation",
        foreignField: "_id",
        as: "conversationData",
      },
    },
    { $unwind: "$conversationData" },
    {
      $match: {
        "conversationData.participants": userId,
      },
    },
    {
      $group: {
        _id: {
          $dayOfWeek: "$delivery.sentAt",
        },
        messageCount: { $sum: 1 },
        dayName: { $first: { $dayOfWeek: "$delivery.sentAt" } },
      },
    },
    { $sort: { messageCount: -1 } },
    { $limit: 1 },
  ]);

  if (result.length === 0) return null;

  const days = ["ÿßŸÑÿ£ÿ≠ÿØ", "ÿßŸÑÿ•ÿ´ŸÜŸäŸÜ", "ÿßŸÑÿ´ŸÑÿßÿ´ÿßÿ°", "ÿßŸÑÿ£ÿ±ÿ®ÿπÿßÿ°", "ÿßŸÑÿÆŸÖŸäÿ≥", "ÿßŸÑÿ¨ŸÖÿπÿ©", "ÿßŸÑÿ≥ÿ®ÿ™"];
  const dayIndex = result[0].dayName - 1; // MongoDB returns 1-7
  
  return {
    day: days[dayIndex],
    count: result[0].messageCount,
  };
}
</file>

<file path="src/controllers/notification.controller.js">
const notificationService = require("../services/notification.service");
const PaginationUtils = require("../utils/pagination.util");

/**
 * üìã ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
 * GET /api/notifications
 */
exports.getUserNotifications = async (req, res) => {
  try {
    const userId = req.user.id;
    const options = {
      page: parseInt(req.query.page) || 1,
      limit: Math.min(parseInt(req.query.limit) || 20, 50),
      status: req.query.status,
      type: req.query.type,
      priority: req.query.priority,
      unreadOnly: req.query.unreadOnly === "true",
      includeExpired: req.query.includeExpired === "true",
    };

    const result = await notificationService.getUserNotifications(userId, options);
    
    if (result.success) {
      res.json({
        success: true,
        ...result.data,
      });
    } else {
      res.status(400).json({
        success: false,
        message: result.error,
      });
    }
  } catch (error) {
    console.error("‚ùå Get notifications error:", error.message);
    res.status(500).json({
      success: false,
      message: "Failed to get notifications",
    });
  }
};

/**
 * üìä ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™
 * GET /api/notifications/stats
 */
exports.getNotificationStats = async (req, res) => {
  try {
    const userId = req.user.id;
    
    const result = await notificationService.getNotificationStats(userId);
    
    if (result.success) {
      res.json(result);
    } else {
      res.status(400).json({
        success: false,
        message: result.error,
      });
    }
  } catch (error) {
    console.error("‚ùå Get notification stats error:", error.message);
    res.status(500).json({
      success: false,
      message: "Failed to get notification statistics",
    });
  }
};

/**
 * üëÅÔ∏è ÿ™ÿ≠ÿØŸäÿ´ ÿ≠ÿßŸÑÿ© ÿßŸÑÿ•ÿ¥ÿπÿßÿ±
 * PUT /api/notifications/:id/status
 */
exports.updateNotificationStatus = async (req, res) => {
  try {
    const userId = req.user.id;
    const notificationId = req.params.id;
    const { status } = req.body;

    if (!["read", "unread", "archived"].includes(status)) {
      return res.status(400).json({
        success: false,
        message: "Invalid status. Allowed: read, unread, archived",
      });
    }

    const result = await notificationService.updateNotificationStatus(
      userId,
      notificationId,
      status
    );

    if (result.success) {
      res.json({
        success: true,
        message: `Notification marked as ${status}`,
        data: result.data,
      });
    } else {
      res.status(404).json({
        success: false,
        message: result.error,
      });
    }
  } catch (error) {
    console.error("‚ùå Update notification status error:", error.message);
    res.status(500).json({
      success: false,
      message: "Failed to update notification status",
    });
  }
};

/**
 * ‚úÖ ÿ™ÿ≠ÿØŸäÿØ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ŸÉŸÖŸÇÿ±Ÿàÿ°ÿ©
 * PUT /api/notifications/mark-all-read
 */
exports.markAllAsRead = async (req, res) => {
  try {
    const userId = req.user.id;
    
    const result = await notificationService.markAllAsRead(userId);
    
    if (result.success) {
      res.json({
        success: true,
        message: "All notifications marked as read",
        data: result.data,
      });
    } else {
      res.status(400).json({
        success: false,
        message: result.error,
      });
    }
  } catch (error) {
    console.error("‚ùå Mark all as read error:", error.message);
    res.status(500).json({
      success: false,
      message: "Failed to mark notifications as read",
    });
  }
};

/**
 * üóëÔ∏è ÿ≠ÿ∞ŸÅ ÿ•ÿ¥ÿπÿßÿ±
 * DELETE /api/notifications/:id
 */
exports.deleteNotification = async (req, res) => {
  try {
    const userId = req.user.id;
    const notificationId = req.params.id;

    const result = await notificationService.deleteNotification(userId, notificationId);

    if (result.success) {
      res.json({
        success: true,
        message: "Notification deleted successfully",
        data: result.data,
      });
    } else {
      res.status(404).json({
        success: false,
        message: result.error,
      });
    }
  } catch (error) {
    console.error("‚ùå Delete notification error:", error.message);
    res.status(500).json({
      success: false,
      message: "Failed to delete notification",
    });
  }
};

/**
 * üßπ ÿ≠ÿ∞ŸÅ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿßŸÑŸÖŸÇÿ±Ÿàÿ°ÿ©
 * DELETE /api/notifications/read
 */
exports.deleteReadNotifications = async (req, res) => {
  try {
    const userId = req.user.id;
    const { olderThan } = req.query;
    
    const query = {
      user: userId,
      status: "read",
    };
    
    if (olderThan) {
      const date = new Date();
      date.setDate(date.getDate() - parseInt(olderThan));
      query.readAt = { $lt: date };
    }

    const Notification = require("../models/notification.model");
    const result = await Notification.deleteMany(query);

    // ÿ•ÿ®ÿ∑ÿßŸÑ ÿßŸÑŸÉÿßÿ¥
    const cache = require("../utils/cache.util");
    cache.invalidatePattern(`notifications:*:${userId}`);

    res.json({
      success: true,
      message: "Read notifications deleted successfully",
      data: {
        deletedCount: result.deletedCount,
      },
    });
  } catch (error) {
    console.error("‚ùå Delete read notifications error:", error.message);
    res.status(500).json({
      success: false,
      message: "Failed to delete read notifications",
    });
  }
};

/**
 * üéØ ÿ•ÿ±ÿ≥ÿßŸÑ ÿ•ÿ¥ÿπÿßÿ± ŸÖÿÆÿµÿµ (ŸÑŸÑÿ£ÿØŸÖŸÜ ŸÅŸÇÿ∑)
 * POST /api/notifications/send
 */
exports.sendCustomNotification = async (req, res) => {
  try {
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿµŸÑÿßÿ≠Ÿäÿ© ÿßŸÑÿ£ÿØŸÖŸÜ
    if (req.user.role !== "admin") {
      return res.status(403).json({
        success: false,
        message: "Only admins can send custom notifications",
      });
    }

    const {
      userIds,
      title,
      content,
      type = "system",
      priority = "medium",
      data = {},
      link,
      icon,
      campaignId,
      group,
      tags = [],
      settings = {},
    } = req.body;

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
    if (!userIds || !Array.isArray(userIds) || userIds.length === 0) {
      return res.status(400).json({
        success: false,
        message: "User IDs are required",
      });
    }

    if (!title || !content) {
      return res.status(400).json({
        success: false,
        message: "Title and content are required",
      });
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿπÿØÿØ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ
    const maxUsers = 1000; // ÿ≠ÿØ ÿ£ŸÇÿµŸâ ŸÑÿ•ÿ±ÿ≥ÿßŸÑ ÿØŸÅÿπÿ© Ÿàÿßÿ≠ÿØÿ©
    if (userIds.length > maxUsers) {
      return res.status(400).json({
        success: false,
        message: `Cannot send to more than ${maxUsers} users at once`,
      });
    }

    // ÿ•ŸÜÿ¥ÿßÿ° ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ŸÑŸÉŸÑ ŸÖÿ≥ÿ™ÿÆÿØŸÖ
    const notificationsData = userIds.map(userId => ({
      user: userId,
      type,
      title,
      content,
      priority,
      data,
      link,
      icon: icon || Notification.getIconByType(type),
      campaignId,
      group,
      tags: [...tags, "custom", "admin_sent"],
      settings: {
        push: settings.push !== undefined ? settings.push : true,
        email: settings.email || false,
        sms: settings.sms || false,
        inApp: settings.inApp !== undefined ? settings.inApp : true,
      },
    }));

    // ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™
    const result = await notificationService.sendBulkNotifications(notificationsData);

    res.json({
      success: true,
      message: "Notifications sent successfully",
      data: result,
    });
  } catch (error) {
    console.error("‚ùå Send custom notification error:", error.message);
    res.status(500).json({
      success: false,
      message: "Failed to send notifications",
    });
  }
};

/**
 * üìà ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿ≠ŸÖŸÑÿ© (ŸÑŸÑÿ£ÿØŸÖŸÜ)
 * GET /api/notifications/campaign/:campaignId/stats
 */
exports.getCampaignStats = async (req, res) => {
  try {
    if (req.user.role !== "admin") {
      return res.status(403).json({
        success: false,
        message: "Only admins can view campaign stats",
      });
    }

    const { campaignId } = req.params;
    const Notification = require("../models/notification.model");

    const [
      totalCount,
      readCount,
      byType,
      byPriority,
      byDay,
      deliveryStats,
    ] = await Promise.all([
      Notification.countDocuments({ campaignId }),
      Notification.countDocuments({ campaignId, status: "read" }),
      Notification.aggregate([
        { $match: { campaignId } },
        {
          $group: {
            _id: "$type",
            count: { $sum: 1 },
          },
        },
      ]),
      Notification.aggregate([
        { $match: { campaignId } },
        {
          $group: {
            _id: "$priority",
            count: { $sum: 1 },
          },
        },
      ]),
      Notification.aggregate([
        { $match: { campaignId } },
        {
          $group: {
            _id: {
              $dateToString: { format: "%Y-%m-%d", date: "$sentAt" },
            },
            count: { $sum: 1 },
            readCount: {
              $sum: { $cond: [{ $eq: ["$status", "read"] }, 1, 0] },
            },
          },
        },
        { $sort: { _id: -1 } },
      ]),
      Notification.aggregate([
        { $match: { campaignId } },
        {
          $group: {
            _id: null,
            pushSent: { $sum: { $cond: [{ $eq: ["$delivery.pushSent", true] }, 1, 0] } },
            emailSent: { $sum: { $cond: [{ $eq: ["$delivery.emailSent", true] }, 1, 0] } },
            smsSent: { $sum: { $cond: [{ $eq: ["$delivery.smsSent", true] }, 1, 0] } },
          },
        },
      ]),
    ]);

    const uniqueUsers = await Notification.distinct("user", { campaignId });
    
    res.json({
      success: true,
      data: {
        campaignId,
        total: totalCount,
        read: readCount,
        unread: totalCount - readCount,
        uniqueUsers: uniqueUsers.length,
        engagementRate: totalCount > 0 ? (readCount / totalCount) * 100 : 0,
        byType: byType.reduce((acc, item) => {
          acc[item._id] = item.count;
          return acc;
        }, {}),
        byPriority: byPriority.reduce((acc, item) => {
          acc[item._id] = item.count;
          return acc;
        }, {}),
        byDay,
        delivery: deliveryStats[0] || {},
      },
    });
  } catch (error) {
    console.error("‚ùå Get campaign stats error:", error.message);
    res.status(500).json({
      success: false,
      message: "Failed to get campaign statistics",
    });
  }
};

/**
 * üîî ÿ™ÿ≠ÿØŸäÿ´ ÿ™ŸÅÿ∂ŸäŸÑÿßÿ™ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™
 * PUT /api/notifications/preferences
 */
exports.updateNotificationPreferences = async (req, res) => {
  try {
    const userId = req.user.id;
    const { preferences } = req.body;

    const User = require("../models/user.model");
    const user = await User.findById(userId);
    
    if (!user) {
      return res.status(404).json({
        success: false,
        message: "User not found",
      });
    }

    // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ™ŸÅÿ∂ŸäŸÑÿßÿ™
    user.preferences = {
      ...user.preferences,
      notifications: {
        ...user.preferences?.notifications,
        ...preferences,
      },
    };

    await user.save();

    // ÿ•ÿ®ÿ∑ÿßŸÑ ÿßŸÑŸÉÿßÿ¥
    const cache = require("../utils/cache.util");
    cache.del(`user:${userId}`);
    cache.del(`user:complete:${userId}`);

    res.json({
      success: true,
      message: "Notification preferences updated",
      data: {
        preferences: user.preferences.notifications,
      },
    });
  } catch (error) {
    console.error("‚ùå Update preferences error:", error.message);
    res.status(500).json({
      success: false,
      message: "Failed to update notification preferences",
    });
  }
};

/**
 * üì± ÿ™ÿ≥ÿ¨ŸäŸÑ ÿ¨Ÿáÿßÿ≤ ŸÑŸÄ Push Notifications
 * POST /api/notifications/devices
 */
exports.registerDevice = async (req, res) => {
  try {
    const userId = req.user.id;
    const { deviceToken, platform, deviceId, appVersion } = req.body;

    if (!deviceToken || !platform) {
      return res.status(400).json({
        success: false,
        message: "Device token and platform are required",
      });
    }

    const Device = require("../models/device.model");
    
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑÿ¨Ÿáÿßÿ≤ ŸÖÿ≥ÿ¨ŸÑÿßŸã ÿ®ÿßŸÑŸÅÿπŸÑ
    let device = await Device.findOne({ deviceId, user: userId });
    
    if (device) {
      // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ¨Ÿáÿßÿ≤ ÿßŸÑÿ≠ÿßŸÑŸä
      device.deviceToken = deviceToken;
      device.platform = platform;
      device.appVersion = appVersion;
      device.lastActive = new Date();
      device.isActive = true;
    } else {
      // ÿ™ÿ≥ÿ¨ŸäŸÑ ÿ¨Ÿáÿßÿ≤ ÿ¨ÿØŸäÿØ
      device = await Device.create({
        user: userId,
        deviceToken,
        platform,
        deviceId,
        appVersion,
        lastActive: new Date(),
        isActive: true,
      });
    }

    await device.save();

    res.json({
      success: true,
      message: "Device registered successfully",
      data: {
        deviceId: device._id,
        platform: device.platform,
        registeredAt: device.createdAt,
      },
    });
  } catch (error) {
    console.error("‚ùå Register device error:", error.message);
    res.status(500).json({
      success: false,
      message: "Failed to register device",
    });
  }
};
</file>

<file path="src/controllers/restaurantAddress.controller.js">
const RestaurantAddress = require("../models/restaurantAddress.model");
const Restaurant = require("../models/restaurant.model");

// ‚ûï ÿ•ŸÜÿ¥ÿßÿ° ÿπŸÜŸàÿßŸÜ ŸÖÿ∑ÿπŸÖ
exports.createAddress = async (req, res) => {
  try {
    const { restaurantId, addressLine, city, latitude, longitude } = req.body;

    // ÿ™ÿ≠ŸÇŸÇ ÿ£ŸÜ ÿßŸÑŸÖÿ∑ÿπŸÖ ŸÖŸàÿ¨ŸàÿØ
    const restaurant = await Restaurant.findById(restaurantId);
    if (!restaurant) {
      return res.status(404).json({ message: "Restaurant not found" });
    }

    const address = await RestaurantAddress.create({
      restaurant: restaurantId,
      addressLine,
      city,
      latitude,
      longitude,
    });

    res.status(201).json(address);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: "Failed to create restaurant address" });
  }
};

// üìç ÿ¨ŸÑÿ® ÿπŸÜŸàÿßŸÜ ÿßŸÑŸÖÿ∑ÿπŸÖ
exports.getAddresses = async (req, res) => {
  try {
    const { restaurantId } = req.params;

    const addresses = await RestaurantAddress.find({
      restaurant: restaurantId,
    });

    res.json(addresses);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: "Failed to fetch restaurant addresses" });
  }
};
</file>

<file path="src/controllers/restaurantComplete.controller.js">
const Restaurant = require("../models/restaurant.model");
const RestaurantAddress = require("../models/restaurantAddress.model");
const Item = require("../models/item.model");
const upload = require("../middlewares/upload");
const cloudinary = require("../config/cloudinary");
const cache = require("../utils/cache.util");

/**
 * üìù ÿ•ŸÜÿ¥ÿßÿ° ŸÖÿ∑ÿπŸÖ ŸÉÿßŸÖŸÑ ŸÖÿπ ÿπŸÜÿßŸàŸäŸÜ ŸàÿπŸÜÿßÿµÿ± ŸàÿµŸàÿ±
 * POST /api/restaurants/complete
 * 
 * Body (multipart/form-data):
 * - name: String (required)
 * - description: String
 * - type: String
 * - phone: String
 * - email: String
 * - deliveryFee: Number
 * - minOrderAmount: Number
 * - estimatedDeliveryTime: Number
 * - tags: String (comma separated)
 * 
 * - image: File (ÿµŸàÿ±ÿ© ÿßŸÑŸÖÿ∑ÿπŸÖ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©)
 * - coverImage: File (ÿµŸàÿ±ÿ© ÿßŸÑÿ∫ŸÑÿßŸÅ)
 * 
 * - addresses: JSON Array (ÿπŸÜÿßŸàŸäŸÜ ÿßŸÑŸÖÿ∑ÿπŸÖ)
 *   [{
 *     addressLine: String,
 *     city: String,
 *     latitude: Number,
 *     longitude: Number
 *   }]
 * 
 * - items: JSON Array (ÿπŸÜÿßÿµÿ± ÿßŸÑŸÇÿßÿ¶ŸÖÿ©)
 *   [{
 *     name: String,
 *     price: Number,
 *     description: String,
 *     category: String,
 *     image: File
 *   }]
 * 
 * - openingHours: JSON Object
 *   {"monday": "09:00-22:00", "tuesday": "09:00-22:00", ...}
 */
exports.createCompleteRestaurant = async (req, res) => {
  try {
    // üîê ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿµŸÑÿßÿ≠Ÿäÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ (ÿ£ÿØŸÖŸÜ ŸÅŸÇÿ∑)
    if (req.user.role !== "admin") {
      return res.status(403).json({
        success: false,
        message: "Only admins can create restaurants",
      });
    }

    console.log("üöÄ Starting complete restaurant creation...");

    // üìÑ ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÜÿµŸäÿ©
    const {
      name,
      description,
      type = "restaurant",
      phone,
      email,
      deliveryFee = 0,
      minOrderAmount = 0,
      estimatedDeliveryTime = 30,
      tags = "",
      addresses = "[]",
      items = "[]",
      openingHours = "{}",
    } = req.body;

    // üîç ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿäÿ©
    if (!name || !name.trim()) {
      return res.status(400).json({
        success: false,
        message: "Restaurant name is required",
      });
    }

    // üîÑ ÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ŸÖŸÜ JSON strings ÿ•ŸÑŸâ objects
    let addressesArray = [];
    let itemsArray = [];
    let openingHoursObj = {};

    try {
      addressesArray = JSON.parse(addresses);
      itemsArray = JSON.parse(items);
      openingHoursObj = JSON.parse(openingHours);
    } catch (parseError) {
      console.error("‚ùå JSON parsing error:", parseError);
      return res.status(400).json({
        success: false,
        message: "Invalid JSON format in addresses, items, or openingHours",
      });
    }

    // üîÑ ÿ™ÿ≠ŸàŸäŸÑ tags ŸÖŸÜ string ÿ•ŸÑŸâ array
    const tagsArray = tags
      ? tags.split(",").map((tag) => tag.trim()).filter((tag) => tag)
      : [];

    console.log(`üìä Processing: ${name}`);
    console.log(`üìå Addresses: ${addressesArray.length}`);
    console.log(`üìå Items: ${itemsArray.length}`);
    console.log(`üìå Tags: ${tagsArray.length}`);

    // ============ 1Ô∏è‚É£ ÿ±ŸÅÿπ ÿßŸÑÿµŸàÿ± ÿ•ŸÑŸâ Cloudinary ============
    console.log("üì§ Uploading images to Cloudinary...");

    let imageUrl = null;
    let coverImageUrl = null;

    try {
      // ÿ±ŸÅÿπ ÿµŸàÿ±ÿ© ÿßŸÑŸÖÿ∑ÿπŸÖ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©
      if (req.files?.image) {
        const imageResult = await cloudinary.uploader.upload(
          req.files.image[0].path,
          {
            folder: "restaurants/main",
            transformation: [
              { width: 800, height: 600, crop: "fill" },
              { quality: "auto:good" },
            ],
          }
        );
        imageUrl = imageResult.secure_url;
        console.log("‚úÖ Main image uploaded:", imageUrl);
      }

      // ÿ±ŸÅÿπ ÿµŸàÿ±ÿ© ÿßŸÑÿ∫ŸÑÿßŸÅ
      if (req.files?.coverImage) {
        const coverResult = await cloudinary.uploader.upload(
          req.files.coverImage[0].path,
          {
            folder: "restaurants/covers",
            transformation: [
              { width: 1200, height: 400, crop: "fill" },
              { quality: "auto:good" },
            ],
          }
        );
        coverImageUrl = coverResult.secure_url;
        console.log("‚úÖ Cover image uploaded:", coverImageUrl);
      }
    } catch (uploadError) {
      console.error("‚ùå Image upload error:", uploadError);
      return res.status(500).json({
        success: false,
        message: "Failed to upload images",
      });
    }

    // ============ 2Ô∏è‚É£ ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑŸÖÿ∑ÿπŸÖ ŸÅŸä ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ============
    console.log("üíæ Creating restaurant in database...");

    let restaurant;
    try {
      restaurant = await Restaurant.create({
        name: name.trim(),
        description: description?.trim(),
        type,
        phone: phone?.trim(),
        email: email?.trim(),
        image: imageUrl,
        coverImage: coverImageUrl,
        deliveryFee: Number(deliveryFee),
        minOrderAmount: Number(minOrderAmount),
        estimatedDeliveryTime: Number(estimatedDeliveryTime),
        tags: tagsArray,
        openingHours: openingHoursObj,
        createdBy: req.user.id,
        isOpen: true,
      });

      console.log("‚úÖ Restaurant created with ID:", restaurant._id);
    } catch (dbError) {
      console.error("‚ùå Database error creating restaurant:", dbError);
      return res.status(500).json({
        success: false,
        message: "Failed to create restaurant in database",
      });
    }

    // ============ 3Ô∏è‚É£ ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿπŸÜÿßŸàŸäŸÜ (ÿ•ÿ∞ÿß Ÿàÿ¨ÿØÿ™) ============
    let createdAddresses = [];
    if (addressesArray.length > 0) {
      console.log("üìç Creating restaurant addresses...");

      const addressPromises = addressesArray.map(async (addressData, index) => {
        try {
          const address = await RestaurantAddress.create({
            restaurant: restaurant._id,
            addressLine: addressData.addressLine?.trim(),
            city: addressData.city?.trim() || "Niamey",
            latitude: addressData.latitude ? Number(addressData.latitude) : null,
            longitude: addressData.longitude ? Number(addressData.longitude) : null,
          });
          return address;
        } catch (addrError) {
          console.error(`‚ùå Error creating address ${index + 1}:`, addrError);
          return null;
        }
      });

      const addressesResults = await Promise.allSettled(addressPromises);
      createdAddresses = addressesResults
        .filter((result) => result.status === "fulfilled" && result.value)
        .map((result) => result.value);

      console.log(`‚úÖ Created ${createdAddresses.length} addresses`);
    }

    // ============ 4Ô∏è‚É£ ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿπŸÜÿßÿµÿ± (ÿ•ÿ∞ÿß Ÿàÿ¨ÿØÿ™) ============
    let createdItems = [];
    if (itemsArray.length > 0) {
      console.log("üçΩÔ∏è Creating menu items...");

      // ÿ¨ŸÖÿπ ŸÖŸÑŸÅÿßÿ™ ÿßŸÑÿµŸàÿ± ŸÑŸÑÿπŸÜÿßÿµÿ±
      const itemImages = req.files?.itemImages || [];

      const itemPromises = itemsArray.map(async (itemData, index) => {
        try {
          let itemImageUrl = null;

          // ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ÿµŸàÿ±ÿ© ÿßŸÑÿπŸÜÿµÿ± ÿßŸÑŸÖŸÇÿßÿ®ŸÑÿ©
          const matchingImage = itemImages.find(
            (img) => img.fieldname === `items[${index}][image]`
          );

          // ÿ±ŸÅÿπ ÿµŸàÿ±ÿ© ÿßŸÑÿπŸÜÿµÿ± ÿ•ÿ∞ÿß Ÿàÿ¨ÿØÿ™
          if (matchingImage) {
            try {
              const imageResult = await cloudinary.uploader.upload(
                matchingImage.path,
                {
                  folder: `restaurants/${restaurant._id}/items`,
                  transformation: [
                    { width: 500, height: 500, crop: "fill" },
                    { quality: "auto:good" },
                  ],
                }
              );
              itemImageUrl = imageResult.secure_url;
            } catch (imgError) {
              console.error(`‚ùå Error uploading item image ${index + 1}:`, imgError);
            }
          }

          // ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿπŸÜÿµÿ±
          const item = await Item.create({
            name: itemData.name?.trim(),
            price: Number(itemData.price) || 0,
            description: itemData.description?.trim(),
            category: itemData.category?.trim() || "main",
            image: itemImageUrl,
            restaurant: restaurant._id,
            isAvailable: true,
          });

          return item;
        } catch (itemError) {
          console.error(`‚ùå Error creating item ${index + 1}:`, itemError);
          return null;
        }
      });

      const itemsResults = await Promise.allSettled(itemPromises);
      createdItems = itemsResults
        .filter((result) => result.status === "fulfilled" && result.value)
        .map((result) => result.value);

      console.log(`‚úÖ Created ${createdItems.length} menu items`);
    }

    // ============ 5Ô∏è‚É£ ÿ•ÿ®ÿ∑ÿßŸÑ ÿßŸÑŸÉÿßÿ¥ ============
    cache.invalidatePattern("restaurant:*");
    cache.invalidatePattern("home:*");
    console.log("üóëÔ∏è Invalidated related cache");

    // ============ 6Ô∏è‚É£ ÿ•ÿπÿØÿßÿØ ÿßŸÑÿßÿ≥ÿ™ÿ¨ÿßÿ®ÿ© ÿßŸÑŸÜŸáÿßÿ¶Ÿäÿ© ============
    console.log("üéâ Restaurant creation completed successfully!");

    // ÿ¨ŸÑÿ® ÿßŸÑŸÖÿ∑ÿπŸÖ ŸÖÿπ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ±ÿ™ÿ®ÿ∑ÿ©
    const populatedRestaurant = await Restaurant.findById(restaurant._id)
      .populate("createdBy", "name email phone")
      .lean();

    const responseData = {
      success: true,
      message: "Restaurant created successfully",
      data: {
        restaurant: {
          ...populatedRestaurant,
          addresses: createdAddresses,
          items: createdItems,
        },
        summary: {
          addressesCount: createdAddresses.length,
          itemsCount: createdItems.length,
          imagesCount: (imageUrl ? 1 : 0) + (coverImageUrl ? 1 : 0),
        },
      },
      timestamp: new Date(),
    };

    res.status(201).json(responseData);
  } catch (error) {
    console.error("‚ùå Unexpected error in createCompleteRestaurant:", error);
    res.status(500).json({
      success: false,
      message: "An unexpected error occurred",
      error: process.env.NODE_ENV === "development" ? error.message : undefined,
    });
  }
};

/**
 * üì§ ÿØÿßŸÑÿ© ŸÖÿ≥ÿßÿπÿØÿ© ŸÑÿ±ŸÅÿπ ŸÖŸÑŸÅÿßÿ™ ŸÖÿ™ÿπÿØÿØÿ©
 */
const uploadMultiple = upload("restaurants").fields([
  { name: "image", maxCount: 1 },
  { name: "coverImage", maxCount: 1 },
  { name: "itemImages", maxCount: 20 }, // ŸäŸÖŸÉŸÜ ÿ±ŸÅÿπ ÿ≠ÿ™Ÿâ 20 ÿµŸàÿ±ÿ© ŸÑŸÑÿπŸÜÿßÿµÿ±
]);

/**
 * üõ†Ô∏è Middleware ŸÑŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿ±ŸÅÿπ
 */
exports.uploadRestaurantFiles = (req, res, next) => {
  uploadMultiple(req, res, function (err) {
    if (err) {
      console.error("‚ùå File upload error:", err);
      return res.status(400).json({
        success: false,
        message: "File upload failed",
        error: err.message,
      });
    }
    next();
  });
};

/**
 * üéØ ÿ™ÿ≠ÿØŸäÿ´ ŸÖÿ∑ÿπŸÖ ŸÉÿßŸÖŸÑ
 * PUT /api/restaurants/:id/complete
 */
exports.updateCompleteRestaurant = async (req, res) => {
  try {
    // Ÿáÿ∞ÿß ÿ≥ŸäŸÉŸàŸÜ ŸÖÿ¥ÿßÿ®ŸáŸãÿß ŸÑŸÑÿ•ŸÜÿ¥ÿßÿ° ŸÑŸÉŸÜ ŸÑŸÑÿ™ÿ≠ÿØŸäÿ´
    // ŸäŸÖŸÉŸÜŸÜÿß ÿ™ÿ∑ŸàŸäÿ±Ÿá ŸÑÿßÿ≠ŸÇŸãÿß
    res.json({
      success: true,
      message: "Update endpoint will be implemented soon",
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: "Update failed",
    });
  }
};
</file>

<file path="src/controllers/review.controller.js">
const Review = require("../models/review.model");
const Restaurant = require("../models/restaurant.model");


// POST /api/restaurants/:id/reviews

exports.addReview = async (req, res) => {
  try {
    const { rating, comment } = req.body;
    const restaurantId = req.params.id;

    const review = await Review.create({
      user: req.user.id,
      restaurant: restaurantId,
      rating,
      comment,
    });

    // üîÑ ÿ≠ÿ≥ÿßÿ® ÿßŸÑŸÖÿ™Ÿàÿ≥ÿ∑ ŸàÿπÿØÿØ ÿßŸÑÿ™ŸÇŸäŸäŸÖÿßÿ™
    const stats = await Review.aggregate([
      { $match: { restaurant: review.restaurant } },
      {
        $group: {
          _id: "$restaurant",
          avgRating: { $avg: "$rating" },
          count: { $sum: 1 },
        },
      },
    ]);

    await Restaurant.findByIdAndUpdate(restaurantId, {
      averageRating: stats[0].avgRating,
      ratingsCount: stats[0].count,
    });

    res.status(201).json(review);
  } catch (error) {
    if (error.code === 11000) {
      return res
        .status(400)
        .json({ message: "You already rated this restaurant" });
    }

    console.error(error);
    res.status(500).json({ message: "Failed to add review" });
  }
};

// GET  /api/restaurants/:id/reviews

exports.getRestaurantReviews = async (req, res) => {
  try {
    const restaurantId = req.params.id;

    const reviews = await Review.find({ restaurant: restaurantId })
      .populate("user", "name")
      .sort({ createdAt: -1 });

    res.json(reviews);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: "Failed to fetch reviews" });
  }
};
</file>

<file path="src/controllers/user.controller.js">
const User = require("../models/user.model");

exports.getUsers = async (req, res) => {
  const users = await User.find();
  res.json(users);
};

// ÿØÿßŸÑÿ© ŸÑÿ¨ŸÑÿ® ŸÖÿ≥ÿ™ÿÆÿØŸÖ Ÿàÿßÿ≠ÿØ
exports.getUser = async (req, res) => {
  try {
    const userId = req.params.id; // ŸÜŸÅÿ™ÿ±ÿ∂ ÿ£ŸÜ ÿßŸÑŸÖÿπÿ±ŸÅ Ÿäÿ¨Ÿä ŸÖŸÜ ÿßŸÑÿ±ÿßÿ®ÿ∑ /api/users/:id
    const user = await User.findById(userId).select("name email phone role"); // ÿ¨ŸÑÿ® ÿßŸÑÿ≠ŸÇŸàŸÑ ŸÅŸÇÿ∑
    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }
    res.json(user);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: "Server error" });
  }
};

exports.getMyProfile = async (req, res) => {
  try {
    // req.user.id ŸÖŸàÿ¨ŸàÿØ ÿ®ÿπÿØ middleware auth
    const user = await User.findById(req.user.id).select("name email phone role image");
    if (!user) return res.status(404).json({ message: "User not found" });

    res.json(user); 
  } catch (err) {
    console.error(err);
    res.status(500).json({ message: "Server error" });
  }
};

exports.uploadAvatar = async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ message: "No file uploaded" });
    }

    const user = await User.findByIdAndUpdate(
      req.user.id,
      { image: req.file.path }, // ‚úÖ Cloudinary URL
      { new: true }
    ).select("name email phone role image");

    res.json(user);
  } catch (err) {
    console.error(err);
    res.status(500).json({ message: "Server error" });
  }
};


exports.createUser = async (req, res) => {
  const { name, phone, role } = req.body;

  const user = await User.create({
    name,
    phone,
    role,
  });

  res.status(201).json(user);
};
</file>

<file path="src/controllers/userComplete.controller.js">
const User = require("../models/user.model");
const Order = require("../models/order.model");
const Address = require("../models/address.model");
const Review = require("../models/review.model");
const Restaurant = require("../models/restaurant.model");
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");
const crypto = require("crypto");
const cache = require("../utils/cache.util");
const PaginationUtils = require("../utils/pagination.util");

/**
 * üìã ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑŸÉÿßŸÖŸÑÿ©
 * GET /api/users/me/complete
 */
exports.getMyCompleteProfile = async (req, res) => {
  try {
    const userId = req.user.id;
    const cacheKey = `user:complete:${userId}`;
    
    // ŸÖÿ≠ÿßŸàŸÑÿ© ÿ¨ŸÑÿ® ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ŸÖŸÜ ÿßŸÑŸÉÿßÿ¥
    const cachedData = cache.get(cacheKey);
    if (cachedData) {
      console.log("üì¶ Serving complete profile from cache");
      return res.json({
        ...cachedData,
        cached: true,
      });
    }

    console.log(`üîÑ Fetching complete profile for user ${userId}`);
    
    // ÿ¨ŸÑÿ® ÿ¨ŸÖŸäÿπ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿ®ÿßŸÑÿ™Ÿàÿßÿ≤Ÿä
    const [
      user,
      addresses,
      recentOrders,
      favoriteRestaurants,
      recentReviews,
      stats,
    ] = await Promise.all([
      // ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿäÿ©
      User.findById(userId)
        .select("-password -verificationCode -resetPasswordToken -activityLog")
        .lean(),
      
      // ÿπŸÜÿßŸàŸäŸÜ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
      Address.find({ user: userId })
        .sort({ isDefault: -1, createdAt: -1 })
        .lean(),
      
      // ÿ¢ÿÆÿ± 5 ÿ∑ŸÑÿ®ÿßÿ™
      Order.find({ user: userId })
        .populate("restaurant", "name image")
        .populate("driver", "name phone image")
        .sort({ createdAt: -1 })
        .limit(5)
        .lean(),
      
      // ÿßŸÑŸÖÿ∑ÿßÿπŸÖ ÿßŸÑŸÖŸÅÿ∂ŸÑÿ©
      Restaurant.find({ _id: { $in: user?.favorites || [] } })
        .select("name image type averageRating")
        .limit(10)
        .lean(),
      
      // ÿ¢ÿÆÿ± ÿßŸÑÿ™ŸÇŸäŸäŸÖÿßÿ™
      Review.find({ user: userId })
        .populate("restaurant", "name image")
        .sort({ createdAt: -1 })
        .limit(5)
        .lean(),
      
      // ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ŸÖÿ™ŸÇÿØŸÖÿ©
      this.getUserAdvancedStats(userId),
    ]);

    if (!user) {
      return res.status(404).json({
        success: false,
        message: "User not found",
      });
    }

    // ÿ≠ÿ≥ÿßÿ® ÿßŸÑÿπŸÖÿ±
    if (user.dateOfBirth) {
      const today = new Date();
      const birthDate = new Date(user.dateOfBirth);
      let age = today.getFullYear() - birthDate.getFullYear();
      const monthDiff = today.getMonth() - birthDate.getMonth();
      if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birthDate.getDate())) {
        age--;
      }
      user.age = age;
    }

    // ÿ•ÿπÿØÿßÿØ ÿßŸÑÿßÿ≥ÿ™ÿ¨ÿßÿ®ÿ©
    const responseData = {
      success: true,
      data: {
        user,
        addresses,
        recentOrders,
        favoriteRestaurants,
        recentReviews,
        stats,
        summary: {
          addressesCount: addresses.length,
          totalOrders: user.stats?.totalOrders || 0,
          favoriteRestaurantsCount: favoriteRestaurants.length,
          reviewsCount: recentReviews.length,
        },
      },
      cached: false,
      timestamp: new Date(),
    };

    // ÿ≠ŸÅÿ∏ ŸÅŸä ÿßŸÑŸÉÿßÿ¥ ŸÑŸÖÿØÿ© 5 ÿØŸÇÿßÿ¶ŸÇ
    cache.set(cacheKey, responseData, 300);
    
    res.json(responseData);
  } catch (error) {
    console.error("‚ùå Complete profile error:", error.message);
    res.status(500).json({
      success: false,
      message: "Failed to load profile data",
    });
  }
};

/**
 * üìä ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑŸÖÿ™ŸÇÿØŸÖÿ©
 */
exports.getUserAdvancedStats = async (userId) => {
  try {
    const [orderStats, reviewStats, spendingStats] = await Promise.all([
      // ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿ∑ŸÑÿ®ÿßÿ™
      Order.aggregate([
        { $match: { user: userId } },
        {
          $group: {
            _id: "$status",
            count: { $sum: 1 },
            totalAmount: { $sum: "$totalPrice" },
          },
        },
      ]),
      
      // ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿ™ŸÇŸäŸäŸÖÿßÿ™
      Review.aggregate([
        { $match: { user: userId } },
        {
          $group: {
            _id: null,
            averageRating: { $avg: "$rating" },
            totalReviews: { $sum: 1 },
          },
        },
      ]),
      
      // ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿ•ŸÜŸÅÿßŸÇ
      Order.aggregate([
        { $match: { user: userId, status: "delivered" } },
        {
          $group: {
            _id: {
              $dateToString: { format: "%Y-%m", date: "$createdAt" },
            },
            totalSpent: { $sum: "$totalPrice" },
            orderCount: { $sum: 1 },
          },
        },
        { $sort: { _id: -1 } },
        { $limit: 6 },
      ]),
    ]);

    // ŸÖÿπÿßŸÑÿ¨ÿ© ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿ∑ŸÑÿ®ÿßÿ™
    const orderStatusStats = {};
    let totalOrders = 0;
    let totalSpent = 0;

    orderStats.forEach(stat => {
      orderStatusStats[stat._id] = {
        count: stat.count,
        amount: stat.totalAmount,
      };
      totalOrders += stat.count;
      totalSpent += stat.totalAmount;
    });

    // ŸÖÿπÿßŸÑÿ¨ÿ© ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿ™ŸÇŸäŸäŸÖÿßÿ™
    const reviewData = reviewStats[0] || {
      averageRating: 0,
      totalReviews: 0,
    };

    // ŸÖÿπÿßŸÑÿ¨ÿ© ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿ•ŸÜŸÅÿßŸÇ ÿßŸÑÿ¥Ÿáÿ±Ÿäÿ©
    const monthlySpending = spendingStats.reduce((acc, curr) => {
      acc[curr._id] = {
        spent: curr.totalSpent,
        orders: curr.orderCount,
      };
      return acc;
    }, {});

    return {
      orderStatusStats,
      totalOrders,
      totalSpent,
      averageOrderValue: totalOrders > 0 ? totalSpent / totalOrders : 0,
      reviewStats: {
        averageRating: reviewData.averageRating || 0,
        totalReviews: reviewData.totalReviews || 0,
      },
      monthlySpending,
      favoriteCategories: await this.getFavoriteCategories(userId),
      lastActive: await this.getLastActivity(userId),
    };
  } catch (error) {
    console.error("Stats calculation error:", error);
    return {};
  }
};

/**
 * üìà ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿßŸÑŸÅÿ¶ÿßÿ™ ÿßŸÑŸÖŸÅÿ∂ŸÑÿ© ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
 */
exports.getFavoriteCategories = async (userId) => {
  try {
    const favoriteCategories = await Order.aggregate([
      { $match: { user: userId, status: "delivered" } },
      { $unwind: "$items" },
      {
        $lookup: {
          from: "items",
          localField: "items.item",
          foreignField: "_id",
          as: "itemDetails",
        },
      },
      { $unwind: "$itemDetails" },
      {
        $group: {
          _id: "$itemDetails.category",
          count: { $sum: 1 },
          totalSpent: { $sum: "$items.price" },
        },
      },
      { $sort: { count: -1 } },
      { $limit: 5 },
    ]);

    return favoriteCategories.map(cat => ({
      category: cat._id || "unknown",
      orderCount: cat.count,
      totalSpent: cat.totalSpent,
    }));
  } catch (error) {
    console.error("Favorite categories error:", error);
    return [];
  }
};

/**
 * üìç ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ¢ÿÆÿ± ŸÜÿ¥ÿßÿ∑ ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
 */
exports.getLastActivity = async (userId) => {
  try {
    const user = await User.findById(userId).select("lastActivity lastLogin");
    
    const activities = [
      { type: "lastLogin", date: user?.lastLogin },
      { type: "lastActivity", date: user?.lastActivity },
    ].filter(activity => activity.date);

    if (activities.length === 0) return null;

    const latestActivity = activities.reduce((latest, current) => {
      return new Date(current.date) > new Date(latest.date) ? current : latest;
    });

    return {
      type: latestActivity.type,
      date: latestActivity.date,
      relativeTime: this.getRelativeTime(latestActivity.date),
    };
  } catch (error) {
    console.error("Last activity error:", error);
    return null;
  }
};

/**
 * ‚è∞ ÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑÿ™ÿßÿ±ŸäÿÆ ÿ•ŸÑŸâ ŸàŸÇÿ™ ŸÜÿ≥ÿ®Ÿä
 */
exports.getRelativeTime = (date) => {
  const now = new Date();
  const past = new Date(date);
  const diffMs = now - past;
  const diffMins = Math.round(diffMs / 60000);
  const diffHours = Math.round(diffMs / 3600000);
  const diffDays = Math.round(diffMs / 86400000);

  if (diffMins < 1) return "ÿßŸÑÿ¢ŸÜ";
  if (diffMins < 60) return `ŸÖŸÜÿ∞ ${diffMins} ÿØŸÇŸäŸÇÿ©`;
  if (diffHours < 24) return `ŸÖŸÜÿ∞ ${diffHours} ÿ≥ÿßÿπÿ©`;
  if (diffDays < 7) return `ŸÖŸÜÿ∞ ${diffDays} ŸäŸàŸÖ`;
  
  return past.toLocaleDateString("ar-EG");
};

/**
 * üîÑ ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÖŸÑŸÅ ÿßŸÑÿ¥ÿÆÿµŸä
 * PUT /api/users/me/complete
 */
exports.updateCompleteProfile = async (req, res) => {
  try {
    const userId = req.user.id;
    const updateData = req.body;
    
    console.log(`üîÑ Updating profile for user ${userId}`);

    // ÿßŸÑÿ≠ŸÇŸàŸÑ ÿßŸÑŸÖÿ≥ŸÖŸàÿ≠ ÿ®ÿ™ÿ≠ÿØŸäÿ´Ÿáÿß
    const allowedFields = [
      "name", "email", "bio", "address", "city", 
      "dateOfBirth", "gender", "preferences"
    ];
    
    // ŸÅŸÑÿ™ÿ±ÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
    const filteredData = {};
    Object.keys(updateData).forEach(key => {
      if (allowedFields.includes(key)) {
        filteredData[key] = updateData[key];
      }
    });

    // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÖŸàŸÇÿπ ÿ•ÿ∞ÿß ŸÉÿßŸÜ ŸÖŸàÿ¨ŸàÿØÿßŸã
    if (updateData.latitude && updateData.longitude) {
      filteredData.location = {
        type: "Point",
        coordinates: [
          parseFloat(updateData.longitude),
          parseFloat(updateData.latitude),
        ],
      };
    }

    // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
    const updatedUser = await User.findByIdAndUpdate(
      userId,
      { $set: filteredData },
      { 
        new: true,
        runValidators: true,
        select: "-password -verificationCode -resetPasswordToken -activityLog"
      }
    );

    if (!updatedUser) {
      return res.status(404).json({
        success: false,
        message: "User not found",
      });
    }

    // ÿ•ÿ®ÿ∑ÿßŸÑ ÿßŸÑŸÉÿßÿ¥
    cache.del(`user:complete:${userId}`);
    cache.invalidatePattern(`user:*:${userId}`);

    // ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑŸÜÿ¥ÿßÿ∑
    await updatedUser.logActivity("profile_updated", {
      fields: Object.keys(filteredData),
      ip: req.ip,
    }, req);

    res.json({
      success: true,
      message: "Profile updated successfully",
      data: updatedUser,
      updatedFields: Object.keys(filteredData),
      timestamp: new Date(),
    });
  } catch (error) {
    console.error("‚ùå Profile update error:", error.message);
    
    if (error.name === "ValidationError") {
      return res.status(400).json({
        success: false,
        message: "Validation error",
        errors: Object.values(error.errors).map(err => err.message),
      });
    }
    
    if (error.code === 11000) {
      return res.status(400).json({
        success: false,
        message: "Email or phone already exists",
      });
    }
    
    res.status(500).json({
      success: false,
      message: "Failed to update profile",
    });
  }
};

/**
 * üì∑ ÿ™ÿ≠ÿØŸäÿ´ ÿµŸàÿ±ÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
 * PUT /api/users/me/avatar
 */
exports.updateAvatar = async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: "No image uploaded",
      });
    }

    const userId = req.user.id;
    const imageUrl = req.file.path; // Cloudinary URL

    const updatedUser = await User.findByIdAndUpdate(
      userId,
      { image: imageUrl },
      { 
        new: true,
        select: "-password -verificationCode -resetPasswordToken"
      }
    );

    // ÿ•ÿ®ÿ∑ÿßŸÑ ÿßŸÑŸÉÿßÿ¥
    cache.del(`user:complete:${userId}`);

    // ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑŸÜÿ¥ÿßÿ∑
    await updatedUser.logActivity("avatar_updated", {
      imageUrl,
      ip: req.ip,
    }, req);

    res.json({
      success: true,
      message: "Avatar updated successfully",
      data: {
        image: updatedUser.image,
      },
      timestamp: new Date(),
    });
  } catch (error) {
    console.error("‚ùå Avatar update error:", error.message);
    res.status(500).json({
      success: false,
      message: "Failed to update avatar",
    });
  }
};

/**
 * üñºÔ∏è ÿ™ÿ≠ÿØŸäÿ´ ÿµŸàÿ±ÿ© ÿßŸÑÿ∫ŸÑÿßŸÅ
 * PUT /api/users/me/cover
 */
exports.updateCoverImage = async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: "No image uploaded",
      });
    }

    const userId = req.user.id;
    const imageUrl = req.file.path;

    const updatedUser = await User.findByIdAndUpdate(
      userId,
      { coverImage: imageUrl },
      { 
        new: true,
        select: "-password"
      }
    );

    cache.del(`user:complete:${userId}`);

    await updatedUser.logActivity("cover_updated", {
      imageUrl,
      ip: req.ip,
    }, req);

    res.json({
      success: true,
      message: "Cover image updated successfully",
      data: {
        coverImage: updatedUser.coverImage,
      },
      timestamp: new Date(),
    });
  } catch (error) {
    console.error("‚ùå Cover image error:", error.message);
    res.status(500).json({
      success: false,
      message: "Failed to update cover image",
    });
  }
};

/**
 * üîê ÿ™ÿ∫ŸäŸäÿ± ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±
 * PUT /api/users/me/password
 */
exports.changePassword = async (req, res) => {
  try {
    const { currentPassword, newPassword, confirmPassword } = req.body;
    const userId = req.user.id;

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
    if (!currentPassword || !newPassword || !confirmPassword) {
      return res.status(400).json({
        success: false,
        message: "All password fields are required",
      });
    }

    if (newPassword !== confirmPassword) {
      return res.status(400).json({
        success: false,
        message: "New passwords do not match",
      });
    }

    if (newPassword.length < 6) {
      return res.status(400).json({
        success: false,
        message: "Password must be at least 6 characters",
      });
    }

    // ÿ¨ŸÑÿ® ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÖÿπ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±
    const user = await User.findById(userId).select("+password");
    
    if (!user) {
      return res.status(404).json({
        success: false,
        message: "User not found",
      });
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ÿßŸÑÿ≠ÿßŸÑŸäÿ©
    const isMatch = await bcrypt.compare(currentPassword, user.password);
    
    if (!isMatch) {
      return res.status(400).json({
        success: false,
        message: "Current password is incorrect",
      });
    }

    // ÿ™ÿ≠ÿØŸäÿ´ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±
    const hashedPassword = await bcrypt.hash(newPassword, 10);
    user.password = hashedPassword;
    await user.save();

    // ÿ•ÿ®ÿ∑ÿßŸÑ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ¨ŸÑÿ≥ÿßÿ™
    cache.invalidatePattern(`session:*:${userId}`);

    // ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑŸÜÿ¥ÿßÿ∑
    await user.logActivity("password_changed", {
      ip: req.ip,
      userAgent: req.headers["user-agent"],
    }, req);

    // ÿ•ŸÜÿ¥ÿßÿ° token ÿ¨ÿØŸäÿØ
    const token = jwt.sign(
      { id: user._id, role: user.role },
      process.env.JWT_SECRET,
      { expiresIn: "7d" }
    );

    res.json({
      success: true,
      message: "Password changed successfully",
      token, // ÿ•ÿ±ÿ¨ÿßÿπ token ÿ¨ÿØŸäÿØ
      timestamp: new Date(),
    });
  } catch (error) {
    console.error("‚ùå Password change error:", error.message);
    res.status(500).json({
      success: false,
      message: "Failed to change password",
    });
  }
};

/**
 * ‚≠ê ÿ•ÿ∂ÿßŸÅÿ©/ÿ•ÿ≤ÿßŸÑÿ© ŸÖÿ∑ÿπŸÖ ŸÖŸÜ ÿßŸÑŸÖŸÅÿ∂ŸÑÿ©
 * POST /api/users/me/favorites/:restaurantId
 */
exports.toggleFavorite = async (req, res) => {
  try {
    const userId = req.user.id;
    const { restaurantId } = req.params;

    const user = await User.findById(userId);
    const restaurant = await Restaurant.findById(restaurantId);

    if (!restaurant) {
      return res.status(404).json({
        success: false,
        message: "Restaurant not found",
      });
    }

    const isFavorite = user.favorites.includes(restaurantId);
    let message = "";
    
    if (isFavorite) {
      // ÿ•ÿ≤ÿßŸÑÿ© ŸÖŸÜ ÿßŸÑŸÖŸÅÿ∂ŸÑÿ©
      user.favorites = user.favorites.filter(
        fav => fav.toString() !== restaurantId
      );
      message = "Restaurant removed from favorites";
    } else {
      // ÿ•ÿ∂ÿßŸÅÿ© ÿ•ŸÑŸâ ÿßŸÑŸÖŸÅÿ∂ŸÑÿ©
      user.favorites.push(restaurantId);
      message = "Restaurant added to favorites";
    }

    await user.save();
    cache.del(`user:complete:${userId}`);

    // ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑŸÜÿ¥ÿßÿ∑
    await user.logActivity(
      isFavorite ? "favorite_removed" : "favorite_added",
      { restaurantId, restaurantName: restaurant.name },
      req
    );

    res.json({
      success: true,
      message,
      data: {
        isFavorite: !isFavorite,
        favoritesCount: user.favorites.length,
      },
      timestamp: new Date(),
    });
  } catch (error) {
    console.error("‚ùå Toggle favorite error:", error.message);
    res.status(500).json({
      success: false,
      message: "Failed to update favorites",
    });
  }
};

/**
 * üìú ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ≥ÿ¨ŸÑ ÿßŸÑŸÜÿ¥ÿßÿ∑ÿßÿ™
 * GET /api/users/me/activity
 */
exports.getActivityLog = async (req, res) => {
  try {
    const userId = req.user.id;
    const paginationOptions = PaginationUtils.getPaginationOptions(req);
    const { skip, limit } = paginationOptions;

    const user = await User.findById(userId).select("activityLog");
    
    if (!user) {
      return res.status(404).json({
        success: false,
        message: "User not found",
      });
    }

    // ÿ™ÿ∑ÿ®ŸäŸÇ pagination ÿπŸÑŸâ ÿ≥ÿ¨ŸÑ ÿßŸÑŸÜÿ¥ÿßÿ∑ÿßÿ™
    const total = user.activityLog.length;
    const activityLog = user.activityLog
      .slice(skip, skip + limit)
      .map(log => ({
        ...log,
        relativeTime: this.getRelativeTime(log.timestamp),
      }));

    const response = PaginationUtils.createPaginationResponse(
      activityLog,
      total,
      paginationOptions,
      {
        summary: {
          totalActivities: total,
          lastActivity: user.activityLog[0]?.timestamp || null,
        },
      }
    );

    res.json(response);
  } catch (error) {
    console.error("‚ùå Activity log error:", error.message);
    res.status(500).json({
      success: false,
      message: "Failed to get activity log",
    });
  }
};

/**
 * üìä ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
 * GET /api/users/me/stats
 */
exports.getUserStats = async (req, res) => {
  try {
    const userId = req.user.id;
    const cacheKey = `user:stats:${userId}`;
    
    const cachedData = cache.get(cacheKey);
    if (cachedData) {
      return res.json({
        ...cachedData,
        cached: true,
      });
    }

    const [basicStats, orderStats, spendingTrends] = await Promise.all([
      // ÿßŸÑÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿäÿ©
      User.findById(userId)
        .select("stats role createdAt lastLogin lastActivity")
        .lean(),
      
      // ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿ∑ŸÑÿ®ÿßÿ™ ÿßŸÑŸÖÿ™ŸÇÿØŸÖÿ©
      Order.aggregate([
        { $match: { user: userId } },
        {
          $facet: {
            byStatus: [
              {
                $group: {
                  _id: "$status",
                  count: { $sum: 1 },
                  totalAmount: { $sum: "$totalPrice" },
                },
              },
            ],
            byMonth: [
              {
                $group: {
                  _id: {
                    $dateToString: { format: "%Y-%m", date: "$createdAt" },
                  },
                  count: { $sum: 1 },
                  amount: { $sum: "$totalPrice" },
                },
              },
              { $sort: { _id: -1 } },
              { $limit: 6 },
            ],
            byRestaurant: [
              {
                $group: {
                  _id: "$restaurant",
                  count: { $sum: 1 },
                  amount: { $sum: "$totalPrice" },
                },
              },
              { $sort: { count: -1 } },
              { $limit: 5 },
            ],
            favoriteItems: [
              { $unwind: "$items" },
              {
                $group: {
                  _id: "$items.name",
                  count: { $sum: "$items.qty" },
                  totalAmount: { $sum: { $multiply: ["$items.price", "$items.qty"] } },
                },
              },
              { $sort: { count: -1 } },
              { $limit: 10 },
            ],
          },
        },
      ]),
      
      // ÿßÿ™ÿ¨ÿßŸáÿßÿ™ ÿßŸÑÿ•ŸÜŸÅÿßŸÇ
      Order.aggregate([
        { $match: { user: userId, status: "delivered" } },
        {
          $group: {
            _id: {
              $dateToString: { format: "%Y-%m-%d", date: "$createdAt" },
            },
            totalSpent: { $sum: "$totalPrice" },
          },
        },
        { $sort: { _id: -1 } },
        { $limit: 30 },
      ]),
    ]);

    // ÿ¨ŸÑÿ® ÿ£ÿ≥ŸÖÿßÿ° ÿßŸÑŸÖÿ∑ÿßÿπŸÖ
    const restaurantIds = orderStats[0]?.byRestaurant?.map(r => r._id) || [];
    const restaurants = await Restaurant.find({ _id: { $in: restaurantIds } })
      .select("name image")
      .lean();

    const restaurantMap = restaurants.reduce((map, rest) => {
      map[rest._id] = rest;
      return map;
    }, {});

    // ÿ®ŸÜÿßÿ° ÿßÿ≥ÿ™ÿ¨ÿßÿ®ÿ© ÿßŸÑÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™
    const responseData = {
      success: true,
      data: {
        basic: {
          memberSince: basicStats.createdAt,
          lastLogin: basicStats.lastLogin,
          lastActivity: basicStats.lastActivity,
          role: basicStats.role,
          ...basicStats.stats,
        },
        orders: {
          byStatus: orderStats[0]?.byStatus?.reduce((acc, stat) => {
            acc[stat._id] = {
              count: stat.count,
              amount: stat.totalAmount,
            };
            return acc;
          }, {}) || {},
          byMonth: orderStats[0]?.byMonth?.map(month => ({
            month: month._id,
            count: month.count,
            amount: month.amount,
          })) || [],
          byRestaurant: orderStats[0]?.byRestaurant?.map(rest => ({
            restaurant: restaurantMap[rest._id] || { _id: rest._id },
            count: rest.count,
            amount: rest.amount,
          })) || [],
          favoriteItems: orderStats[0]?.favoriteItems || [],
        },
        spending: {
          trends: spendingTrends,
          averageOrderValue: basicStats.stats?.totalOrders > 0 
            ? basicStats.stats.totalSpent / basicStats.stats.totalOrders 
            : 0,
          monthlyAverage: await this.calculateMonthlyAverage(userId),
        },
        insights: {
          favoriteTimeOfDay: await this.getFavoriteTimeOfDay(userId),
          favoriteDayOfWeek: await this.getFavoriteDayOfWeek(userId),
          deliverySpeed: await this.getAverageDeliverySpeed(userId),
          cancellationRate: basicStats.stats?.totalOrders > 0
            ? (basicStats.stats.cancelledOrders / basicStats.stats.totalOrders) * 100
            : 0,
        },
      },
      cached: false,
      timestamp: new Date(),
    };

    // ÿ≠ŸÅÿ∏ ŸÅŸä ÿßŸÑŸÉÿßÿ¥ ŸÑŸÖÿØÿ© 10 ÿØŸÇÿßÿ¶ŸÇ
    cache.set(cacheKey, responseData, 600);
    
    res.json(responseData);
  } catch (error) {
    console.error("‚ùå User stats error:", error.message);
    res.status(500).json({
      success: false,
      message: "Failed to get user statistics",
    });
  }
};

/**
 * üìÖ ÿ≠ÿ≥ÿßÿ® ÿßŸÑŸÖÿ™Ÿàÿ≥ÿ∑ ÿßŸÑÿ¥Ÿáÿ±Ÿä ŸÑŸÑÿ•ŸÜŸÅÿßŸÇ
 */
exports.calculateMonthlyAverage = async (userId) => {
  try {
    const sixMonthsAgo = new Date();
    sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);

    const result = await Order.aggregate([
      {
        $match: {
          user: userId,
          status: "delivered",
          createdAt: { $gte: sixMonthsAgo },
        },
      },
      {
        $group: {
          _id: { $month: "$createdAt" },
          totalSpent: { $sum: "$totalPrice" },
          orderCount: { $sum: 1 },
        },
      },
      {
        $group: {
          _id: null,
          averageMonthlySpent: { $avg: "$totalSpent" },
          averageMonthlyOrders: { $avg: "$orderCount" },
        },
      },
    ]);

    return result[0] || { averageMonthlySpent: 0, averageMonthlyOrders: 0 };
  } catch (error) {
    console.error("Monthly average error:", error);
    return { averageMonthlySpent: 0, averageMonthlyOrders: 0 };
  }
};

/**
 * üïí ÿßŸÑŸàŸÇÿ™ ÿßŸÑŸÖŸÅÿ∂ŸÑ ŸÑŸÑÿ∑ŸÑÿ®
 */
exports.getFavoriteTimeOfDay = async (userId) => {
  try {
    const result = await Order.aggregate([
      { $match: { user: userId } },
      {
        $group: {
          _id: { $hour: "$createdAt" },
          count: { $sum: 1 },
        },
      },
      { $sort: { count: -1 } },
      { $limit: 1 },
    ]);

    if (result.length === 0) return null;

    const hour = result[0]._id;
    let timeOfDay = "";
    
    if (hour < 6) timeOfDay = "ŸÑŸäŸÑ";
    else if (hour < 12) timeOfDay = "ÿµÿ®ÿßÿ≠";
    else if (hour < 18) timeOfDay = "ÿ∏Ÿáÿ±";
    else timeOfDay = "ŸÖÿ≥ÿßÿ°";

    return {
      hour,
      timeOfDay,
      count: result[0].count,
    };
  } catch (error) {
    console.error("Favorite time error:", error);
    return null;
  }
};

/**
 * üìÖ ÿßŸÑŸäŸàŸÖ ÿßŸÑŸÖŸÅÿ∂ŸÑ ŸÑŸÑÿ∑ŸÑÿ®
 */
exports.getFavoriteDayOfWeek = async (userId) => {
  try {
    const days = ["ÿßŸÑÿ£ÿ≠ÿØ", "ÿßŸÑÿ•ÿ´ŸÜŸäŸÜ", "ÿßŸÑÿ´ŸÑÿßÿ´ÿßÿ°", "ÿßŸÑÿ£ÿ±ÿ®ÿπÿßÿ°", "ÿßŸÑÿÆŸÖŸäÿ≥", "ÿßŸÑÿ¨ŸÖÿπÿ©", "ÿßŸÑÿ≥ÿ®ÿ™"];
    
    const result = await Order.aggregate([
      { $match: { user: userId } },
      {
        $group: {
          _id: { $dayOfWeek: "$createdAt" },
          count: { $sum: 1 },
        },
      },
      { $sort: { count: -1 } },
      { $limit: 1 },
    ]);

    if (result.length === 0) return null;

    const dayIndex = result[0]._id - 1; // MongoDB returns 1-7
    return {
      dayIndex,
      dayName: days[dayIndex],
      count: result[0].count,
    };
  } catch (error) {
    console.error("Favorite day error:", error);
    return null;
  }
};

/**
 * ‚è±Ô∏è ŸÖÿ™Ÿàÿ≥ÿ∑ ÿ≥ÿ±ÿπÿ© ÿßŸÑÿ™ŸàÿµŸäŸÑ
 */
exports.getAverageDeliverySpeed = async (userId) => {
  try {
    const result = await Order.aggregate([
      {
        $match: {
          user: userId,
          status: "delivered",
          createdAt: { $exists: true },
          updatedAt: { $exists: true },
        },
      },
      {
        $project: {
          deliveryTime: {
            $divide: [
              { $subtract: ["$updatedAt", "$createdAt"] },
              60000, // ÿ™ÿ≠ŸàŸäŸÑ ÿ•ŸÑŸâ ÿØŸÇÿßÿ¶ŸÇ
            ],
          },
        },
      },
      {
        $group: {
          _id: null,
          averageDeliveryTime: { $avg: "$deliveryTime" },
          fastestDelivery: { $min: "$deliveryTime" },
          slowestDelivery: { $max: "$deliveryTime" },
        },
      },
    ]);

    return result[0] || {
      averageDeliveryTime: 0,
      fastestDelivery: 0,
      slowestDelivery: 0,
    };
  } catch (error) {
    console.error("Delivery speed error:", error);
    return {
      averageDeliveryTime: 0,
      fastestDelivery: 0,
      slowestDelivery: 0,
    };
  }
};

/**
 * üöÄ ÿ™ÿ≠ÿØŸäÿ´ ÿ≠ÿßŸÑÿ© ÿßŸÑÿ™Ÿàÿßÿ¨ÿØ (Online/Offline)
 * PUT /api/users/me/presence
 */
exports.updatePresence = async (req, res) => {
  try {
    const userId = req.user.id;
    const { isOnline, location } = req.body;

    const updateData = { isOnline };
    
    if (location && location.latitude && location.longitude) {
      updateData.location = {
        type: "Point",
        coordinates: [location.longitude, location.latitude],
      };
      
      // ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑŸÖŸÜÿØŸàÿ®ÿå ÿ™ÿ≠ÿØŸäÿ´ ŸÖŸàŸÇÿπŸá
      if (req.user.role === "driver") {
        updateData["driverInfo.currentLocation"] = updateData.location;
        updateData["driverInfo.isAvailable"] = isOnline;
      }
    }

    const updatedUser = await User.findByIdAndUpdate(
      userId,
      { $set: updateData },
      { new: true, select: "name role isOnline location" }
    );

    // ÿ•ÿ±ÿ≥ÿßŸÑ ÿ™ÿ≠ÿØŸäÿ´ ÿπÿ®ÿ± Socket.io
    if (req.app.get('io')) {
      req.app.get('io').emit('user:presence', {
        userId,
        isOnline: updatedUser.isOnline,
        location: updatedUser.location,
        role: updatedUser.role,
        timestamp: new Date(),
      });
    }

    res.json({
      success: true,
      message: `You are now ${isOnline ? 'online' : 'offline'}`,
      data: {
        isOnline: updatedUser.isOnline,
        location: updatedUser.location,
        updatedAt: new Date(),
      },
    });
  } catch (error) {
    console.error("‚ùå Presence update error:", error.message);
    res.status(500).json({
      success: false,
      message: "Failed to update presence",
    });
  }
};
</file>

<file path="src/jobs/notificationCleanup.job.js">
const cron = require("node-cron");
const notificationService = require("../services/notification.service");
const Notification = require("../models/notification.model");

class NotificationCleanupJob {
  constructor() {
    this.jobs = [];
  }

  /**
   * ÿ®ÿØÿ° ÿ¨ŸÖŸäÿπ ÿßŸÑŸÖŸáÿßŸÖ ÿßŸÑŸÖÿ¨ÿØŸàŸÑÿ©
   */
  start() {
    console.log("‚è∞ Starting notification cleanup jobs...");

    // ŸÖŸáŸÖÿ© ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿßŸÑŸÖŸÜÿ™ŸáŸäÿ© ŸÉŸÑ ŸäŸàŸÖ ŸÅŸä ŸÖŸÜÿ™ÿµŸÅ ÿßŸÑŸÑŸäŸÑ
    this.jobs.push(
      cron.schedule("0 0 * * *", async () => {
        console.log("üßπ Running expired notifications cleanup...");
        try {
          const result = await notificationService.cleanupExpiredNotifications();
          console.log(`‚úÖ Cleanup completed: ${result.deletedCount} notifications deleted`);
        } catch (error) {
          console.error("‚ùå Cleanup job error:", error.message);
        }
      })
    );

    // ŸÖŸáŸÖÿ© ÿ•ÿ±ÿ≥ÿßŸÑ ÿ™ÿ∞ŸÉŸäÿ± ÿßŸÑÿ™ŸÇŸäŸäŸÖ ŸÉŸÑ ŸäŸàŸÖ ŸÅŸä 6 ŸÖÿ≥ÿßÿ°Ÿã
    this.jobs.push(
      cron.schedule("0 18 * * *", async () => {
        console.log("‚≠ê Sending review reminder notifications...");
        await this.sendReviewReminders();
      })
    );

    // ŸÖŸáŸÖÿ© ÿ™ÿ≠ÿØŸäÿ´ ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ŸÉŸÑ ÿ≥ÿßÿπÿ©
    this.jobs.push(
      cron.schedule("0 * * * *", async () => {
        console.log("üìä Updating notification statistics...");
        await this.updateNotificationStats();
      })
    );

    // ŸÖŸáŸÖÿ© ÿ•ÿπÿßÿØÿ© ŸÖÿ≠ÿßŸàŸÑÿ© ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿßŸÑŸÅÿßÿ¥ŸÑÿ© ŸÉŸÑ 5 ÿØŸÇÿßÿ¶ŸÇ
    this.jobs.push(
      cron.schedule("*/5 * * * *", async () => {
        console.log("üîÑ Retrying failed notifications...");
        await this.retryFailedNotifications();
      })
    );

    console.log("‚úÖ Notification cleanup jobs started");
  }

  /**
   * ÿ•ÿ±ÿ≥ÿßŸÑ ÿ™ÿ∞ŸÉŸäÿ± ÿßŸÑÿ™ŸÇŸäŸäŸÖ ŸÑŸÑÿ∑ŸÑÿ®ÿßÿ™ ÿßŸÑŸÖŸÉÿ™ŸÖŸÑÿ©
   */
  async sendReviewReminders() {
    try {
      const Order = require("../models/order.model");
      const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
      
      // ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ÿßŸÑÿ∑ŸÑÿ®ÿßÿ™ ÿßŸÑŸÖŸÉÿ™ŸÖŸÑÿ© ŸÖŸÜÿ∞ 24 ÿ≥ÿßÿπÿ© ŸàŸÑŸÖ Ÿäÿ™ŸÖ ÿ™ŸÇŸäŸäŸÖŸáÿß
      const orders = await Order.find({
        status: "delivered",
        deliveredAt: { 
          $gte: oneDayAgo,
          $lt: new Date(Date.now() - 23 * 60 * 60 * 1000), // ÿ®ŸäŸÜ 23 Ÿà 24 ÿ≥ÿßÿπÿ©
        },
      })
      .populate("user", "name")
      .populate("restaurant", "name");

      // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ÿ•ÿ∞ÿß ŸÉÿßŸÜ ŸáŸÜÿßŸÉ ÿ™ŸÇŸäŸäŸÖ ÿ≥ÿßÿ®ŸÇ
      const Review = require("../models/review.model");
      
      for (const order of orders) {
        const existingReview = await Review.findOne({
          user: order.user._id,
          restaurant: order.restaurant._id,
          order: order._id,
        });

        if (!existingReview) {
          // ÿ•ÿ±ÿ≥ÿßŸÑ ÿ•ÿ¥ÿπÿßÿ± ÿ™ÿ∞ŸÉŸäÿ± ÿßŸÑÿ™ŸÇŸäŸäŸÖ
          await notificationService.sendNotification({
            user: order.user._id,
            type: "review_reminder",
            title: "ŸÉŸäŸÅ ŸÉÿßŸÜÿ™ ÿ™ÿ¨ÿ±ÿ®ÿ™ŸÉÿü",
            content: `ÿ¥ÿßÿ±ŸÉŸÜÿß ÿ±ÿ£ŸäŸÉ ŸÅŸä ÿ™ÿ¨ÿ±ÿ®ÿ© ÿ∑ŸÑÿ®ŸÉ ŸÖŸÜ ${order.restaurant.name}`,
            data: {
              orderId: order._id,
              restaurantId: order.restaurant._id,
              restaurantName: order.restaurant.name,
            },
            priority: "low",
            link: `/restaurants/${order.restaurant._id}/review`,
            icon: "‚≠ê",
            tags: ["review", "reminder", `order_${order._id}`],
          });
        }
      }

      console.log(`‚úÖ Sent ${orders.length} review reminders`);
    } catch (error) {
      console.error("‚ùå Review reminder job error:", error.message);
    }
  }

  /**
   * ÿ™ÿ≠ÿØŸäÿ´ ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™
   */
  async updateNotificationStats() {
    try {
      // ÿ™ÿ≠ÿØŸäÿ´ ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿ≠ŸÖŸÑÿßÿ™ ÿßŸÑŸÜÿ¥ÿ∑ÿ©
      const activeCampaigns = await Notification.distinct("campaignId", {
        campaignId: { $exists: true },
        sentAt: { $gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) },
      });

      for (const campaignId of activeCampaigns) {
        const stats = await Notification.aggregate([
          { $match: { campaignId } },
          {
            $group: {
              _id: null,
              total: { $sum: 1 },
              read: { 
                $sum: { $cond: [{ $eq: ["$status", "read"] }, 1, 0] } 
              },
              delivered: {
                $sum: { $cond: [{ $eq: ["$delivery.pushSent", true] }, 1, 0] },
              },
            },
          },
        ]);

        if (stats.length > 0) {
          console.log(`üìä Campaign ${campaignId}:`, stats[0]);
        }
      }
    } catch (error) {
      console.error("‚ùå Stats update job error:", error.message);
    }
  }

  /**
   * ÿ•ÿπÿßÿØÿ© ŸÖÿ≠ÿßŸàŸÑÿ© ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿßŸÑŸÅÿßÿ¥ŸÑÿ©
   */
  async retryFailedNotifications() {
    try {
      const notifications = await Notification.find({
        $or: [
          { "delivery.pushSent": false, "delivery.retryCount": { $lt: 3 } },
          { "delivery.emailSent": false, "delivery.retryCount": { $lt: 3 } },
          { "delivery.smsSent": false, "delivery.retryCount": { $lt: 3 } },
        ],
        sentAt: { $gte: new Date(Date.now() - 24 * 60 * 60 * 1000) },
      });

      for (const notification of notifications) {
        try {
          await notification.retryDelivery();
          console.log(`üîÑ Retrying notification ${notification._id}`);
        } catch (error) {
          console.error(`‚ùå Retry failed for ${notification._id}:`, error.message);
        }
      }
    } catch (error) {
      console.error("‚ùå Retry job error:", error.message);
    }
  }

  /**
   * ÿ•ŸäŸÇÿßŸÅ ÿ¨ŸÖŸäÿπ ÿßŸÑŸÖŸáÿßŸÖ
   */
  stop() {
    this.jobs.forEach(job => job.stop());
    console.log("üõë Notification cleanup jobs stopped");
  }
}

module.exports = new NotificationCleanupJob();
</file>

<file path="src/middlewares/cache.middleware.js">
const cache = require('../utils/cache.util');

/**
 * Middleware ŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑŸÉÿßÿ¥ ŸÅŸä ÿßŸÑÿßÿ≥ÿ™ÿ¨ÿßÿ®ÿ©
 */
const cacheMiddleware = (req, res, next) => {
  const originalJson = res.json;
  const originalSend = res.send;
  
  res.json = function(data) {
    if (data && typeof data === 'object') {
      const cacheKey = cache.generateKey(req);
      const isCached = cache.has(cacheKey);
      
      // ÿ•ÿ∂ÿßŸÅÿ© metadata ŸÅŸÇÿ∑ ÿ•ÿ∞ÿß ŸÑŸÖ ÿ™ŸÉŸÜ ŸÖŸàÿ¨ŸàÿØÿ© ÿ®ÿßŸÑŸÅÿπŸÑ
      if (!data.metadata) {
        data.metadata = {};
      }
      
      data.metadata.cacheInfo = {
        cached: isCached,
        key: cacheKey,
        timestamp: new Date().toISOString(),
        ttl: cache.cache.options.stdTTL || 300
      };
    }
    
    return originalJson.call(this, data);
  };
  
  res.send = function(data) {
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ÿ•ÿ∞ÿß ŸÉÿßŸÜ JSON
    try {
      if (typeof data === 'string') {
        const parsed = JSON.parse(data);
        const cacheKey = cache.generateKey(req);
        const isCached = cache.has(cacheKey);
        
        if (!parsed.metadata) {
          parsed.metadata = {};
        }
        
        parsed.metadata.cacheInfo = {
          cached: isCached,
          key: cacheKey,
          timestamp: new Date().toISOString(),
          ttl: cache.cache.options.stdTTL || 300
        };
        
        data = JSON.stringify(parsed);
      }
    } catch (error) {
      // ŸÑŸäÿ≥ JSONÿå ÿ™ÿ¨ÿßŸáŸÑ
    }
    
    return originalSend.call(this, data);
  };
  
  next();
};

/**
 * Middleware ŸÑŸÖŸÜÿπ ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ ŸÅŸä ÿßŸÑŸÉÿßÿ¥
 */
const noCache = (req, res, next) => {
  res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate');
  res.setHeader('Pragma', 'no-cache');
  res.setHeader('Expires', '0');
  res.setHeader('Surrogate-Control', 'no-store');
  
  res.locals.noCache = true;
  
  next();
};

/**
 * Middleware ŸÑÿ™ŸÅÿπŸäŸÑ ÿßŸÑŸÉÿßÿ¥ ŸÑŸÑŸÖÿ≥ÿßÿ±ÿßÿ™ ÿßŸÑŸÖÿ≠ÿØÿØÿ©
 */
const cacheResponse = (ttl = 300) => {
  return (req, res, next) => {
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ∑ÿ±ŸÇ HTTP ÿßŸÑÿ™Ÿä Ÿäÿ¨ÿ® ÿπÿØŸÖ ÿ™ÿÆÿ≤ŸäŸÜŸáÿß
    if (['POST', 'PUT', 'PATCH', 'DELETE'].includes(req.method.toUpperCase())) {
      return next();
    }
    
    const cacheKey = cache.generateKey(req);
    const cachedData = cache.get(cacheKey);
    
    if (cachedData !== undefined && cachedData !== null) {
      console.log(`üì¶ Serving from cache: ${cacheKey}`);
      
      // ÿ•ÿ∂ÿßŸÅÿ© metadata
      const responseData = {
        ...cachedData,
        metadata: {
          ...cachedData.metadata,
          cached: true,
          servedFromCache: true,
          timestamp: new Date().toISOString()
        }
      };
      
      return res.json(responseData);
    }
    
    const originalJson = res.json;
    res.json = function(data) {
      try {
        // ŸÅŸÇÿ∑ ÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑÿ±ÿØŸàÿØ ÿßŸÑŸÜÿßÿ¨ÿ≠ÿ©
        if (res.statusCode >= 200 && res.statusCode < 300) {
          // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿπÿØŸÖ Ÿàÿ¨ŸàÿØ noCache flag
          if (!res.locals.noCache) {
            cache.set(cacheKey, data, ttl);
          }
        }
      } catch (error) {
        console.error('‚ùå Cache set error:', error.message);
      }
      
      return originalJson.call(this, data);
    };
    
    next();
  };
};

/**
 * Middleware ŸÑŸÖÿ≥ÿ≠ ÿßŸÑŸÉÿßÿ¥ ÿπŸÜÿØ ÿßŸÑÿ∑ŸÑÿ®ÿßÿ™ ÿßŸÑÿ™Ÿä ÿ™ÿπÿØŸÑ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
 */
const invalidateCacheOnMutation = (patterns = []) => {
  return (req, res, next) => {
    const originalJson = res.json;
    
    res.json = function(data) {
      if (res.statusCode >= 200 && res.statusCode < 300) {
        const method = req.method.toUpperCase();
        
        if (['POST', 'PUT', 'PATCH', 'DELETE'].includes(method)) {
          // ÿ™ÿ£ÿÆŸäÿ± ÿ•ÿ®ÿ∑ÿßŸÑ ÿßŸÑŸÉÿßÿ¥ ŸÑÿ∂ŸÖÿßŸÜ ÿßŸÉÿ™ŸÖÿßŸÑ ÿßŸÑÿπŸÖŸÑŸäÿ©
          setTimeout(() => {
            // ŸÖÿ≥ÿ≠ ÿßŸÑÿ£ŸÜŸÖÿßÿ∑ ÿßŸÑŸÖÿ≠ÿØÿØÿ©
            patterns.forEach(pattern => {
              cache.invalidatePattern(pattern);
            });
            
            // ŸÖÿ≥ÿ≠ ÿßŸÑŸÉÿßÿ¥ ÿßŸÑÿπÿßŸÖ ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
            if (req.user && req.user.id) {
              cache.invalidatePattern(`*:${req.user.id}:*`);
              cache.invalidatePattern(`*:${req.user.id}`);
              cache.del(`user:${req.user.id}`);
              cache.del(`user:complete:${req.user.id}`);
              cache.del(`dashboard:${req.user.id}`);
            }
            
            console.log(`üóëÔ∏è Invalidated cache for ${req.method} ${req.originalUrl}`);
          }, 100);
        }
      }
      
      return originalJson.call(this, data);
    };
    
    next();
  };
};

module.exports = {
  cacheMiddleware,
  noCache,
  cacheResponse,
  invalidateCacheOnMutation,
  cacheLogger: cacheMiddleware // ŸÑŸÑÿ≠ŸÅÿßÿ∏ ÿπŸÑŸâ ÿßŸÑÿ™ŸàÿßŸÅŸÇ
};
</file>

<file path="src/middlewares/disableCache.middleware.js">
/**
 * Middleware ŸÑÿ™ÿπÿ∑ŸäŸÑ ÿßŸÑŸÉÿßÿ¥ ŸÑÿ∑ŸÑÿ®ÿßÿ™ ŸÖÿπŸäŸÜÿ©
 */
const disableCache = (req, res, next) => {
  // ÿ™ÿπÿ∑ŸäŸÑ ÿßŸÑŸÉÿßÿ¥ ŸÑŸáÿ∞ÿß ÿßŸÑÿ∑ŸÑÿ®
  res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate');
  res.setHeader('Pragma', 'no-cache');
  res.setHeader('Expires', '0');
  res.setHeader('Surrogate-Control', 'no-store');
  
  // ÿ•ÿ∂ÿßŸÅÿ© header ŸÑŸÑÿ•ÿ¥ÿßÿ±ÿ© ÿ•ŸÑŸâ ÿ™ÿπÿ∑ŸäŸÑ ÿßŸÑŸÉÿßÿ¥
  res.locals.noCache = true;
  
  next();
};

module.exports = disableCache;
</file>

<file path="src/middlewares/errorHandler.middleware.js">
class AppError extends Error {
  constructor(message, statusCode) {
    super(message);
    this.statusCode = statusCode;
    this.status = `${statusCode}`.startsWith('4') ? 'fail' : 'error';
    this.isOperational = true;

    Error.captureStackTrace(this, this.constructor);
  }
}

// Middleware ŸÑŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿ£ÿÆÿ∑ÿßÿ°
const errorHandler = (err, req, res, next) => {
  err.statusCode = err.statusCode || 500;
  err.status = err.status || 'error';

  // ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿÆÿ∑ÿ£
  console.error(`[${new Date().toISOString()}] ERROR:`, {
    message: err.message,
    stack: err.stack,
    url: req.originalUrl,
    method: req.method,
    ip: req.ip,
    user: req.user?.id || 'guest'
  });

  // ŸÅŸä ÿ®Ÿäÿ¶ÿ© ÿßŸÑÿ™ÿ∑ŸàŸäÿ±ÿå ÿπÿ±ÿ∂ ÿ™ŸÅÿßÿµŸäŸÑ ÿ£ŸÉÿ´ÿ±
  if (process.env.NODE_ENV === 'development') {
    return res.status(err.statusCode).json({
      success: false,
      status: err.status,
      error: err,
      message: err.message,
      stack: err.stack
    });
  }

  // ŸÅŸä ÿ®Ÿäÿ¶ÿ© ÿßŸÑÿ•ŸÜÿ™ÿßÿ¨ÿå ÿπÿ±ÿ∂ ÿ±ÿ≥ÿßŸÑÿ© ÿπÿßŸÖÿ©
  const message = err.isOperational ? err.message : 'Something went wrong!';
  
  res.status(err.statusCode).json({
    success: false,
    status: err.status,
    message
  });
};

// Middleware ŸÑÿßŸÑÿ™ŸÇÿßÿ∑ 404
const notFoundHandler = (req, res, next) => {
  const error = new AppError(`Can't find ${req.originalUrl} on this server!`, 404);
  next(error);
};

// Wrapper ŸÑŸÄ async functions
const catchAsync = (fn) => {
  return (req, res, next) => {
    fn(req, res, next).catch(next);
  };
};

module.exports = {
  AppError,
  errorHandler,
  notFoundHandler,
  catchAsync
};
</file>

<file path="src/middlewares/role.middleware.js">
module.exports = (...allowedRoles) => {
  return (req, res, next) => {
    if (!allowedRoles.includes(req.user.role)) {
      return res.status(403).json({
        message: "Access denied role not permitted",
      });
    }
    next();
  };
};
</file>

<file path="src/middlewares/security.middleware.js">
const { AppError } = require('./errorHandler.middleware');
const rateLimit = require('express-rate-limit');
const helmet = require('helmet');
const mongoSanitize = require('express-mongo-sanitize');
const xss = require('xss-clean');
const hpp = require('hpp');

/**
 * Middleware ŸÑÿ≠ŸÖÿßŸäÿ© ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ ŸÖŸÜ Ÿáÿ¨ŸÖÿßÿ™ XSS
 */
const xssProtection = (req, res, next) => {
  try {
    if (req.body) {
      Object.keys(req.body).forEach(key => {
        if (typeof req.body[key] === 'string') {
          req.body[key] = xss(req.body[key], {
            whiteList: {}, // ŸÑÿß ÿ™ÿ≥ŸÖÿ≠ ÿ®ÿ£Ÿä tags
            stripIgnoreTag: true, // ÿ•ÿ≤ÿßŸÑÿ© ÿ¨ŸÖŸäÿπ tags
            stripIgnoreTagBody: ['script'] // ÿ•ÿ≤ÿßŸÑÿ© ŸÖÿ≠ÿ™ŸàŸâ script tags
          });
        }
      });
    }
    
    if (req.query) {
      Object.keys(req.query).forEach(key => {
        if (typeof req.query[key] === 'string') {
          req.query[key] = xss(req.query[key]);
        }
      });
    }
    
    if (req.params) {
      Object.keys(req.params).forEach(key => {
        if (typeof req.params[key] === 'string') {
          req.params[key] = xss(req.params[key]);
        }
      });
    }
    
    next();
  } catch (error) {
    next(new AppError('XSS protection failed', 400));
  }
};

/**
 * Middleware ŸÑŸÖŸÜÿπ Ÿáÿ¨ŸÖÿßÿ™ NoSQL injection
 */
const nosqlInjectionProtection = (req, res, next) => {
  try {
    mongoSanitize.sanitize(req.body);
    mongoSanitize.sanitize(req.query);
    mongoSanitize.sanitize(req.params);
    
    next();
  } catch (error) {
    next(new AppError('NoSQL injection protection failed', 400));
  }
};

/**
 * Middleware ŸÑŸÖŸÜÿπ parameter pollution
 */
const parameterPollutionProtection = hpp({
  whitelist: [
    'page',
    'limit',
    'sort',
    'fields',
    'search',
    'type',
    'category',
    'minPrice',
    'maxPrice',
    'minRating',
    'status'
  ]
});

/**
 * Rate limiting ŸÖÿÆÿµÿµ ŸÑŸÑÿ™ÿ∑ÿ®ŸäŸÇ
 */
const createRateLimiter = (options = {}) => {
  const defaultOptions = {
    windowMs: 15 * 60 * 1000, // 15 ÿØŸÇŸäŸÇÿ©
    max: 100, // 100 ÿ∑ŸÑÿ® ŸÑŸÉŸÑ IP
    message: {
      success: false,
      message: "Too many requests from this IP, please try again later"
    },
    standardHeaders: true,
    legacyHeaders: false,
    skipSuccessfulRequests: false,
    keyGenerator: (req) => {
      return req.ip + ':' + (req.user?.id || 'anonymous');
    }
  };
  
  return rateLimit({ ...defaultOptions, ...options });
};

/**
 * Rate limiters ŸÖÿÆÿ™ŸÑŸÅÿ© ŸÑÿ£ŸÜŸàÿßÿπ ŸÖÿÆÿ™ŸÑŸÅÿ© ŸÖŸÜ ÿßŸÑÿ∑ŸÑÿ®ÿßÿ™
 */
const rateLimiters = {
  // ŸÑŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ŸàÿßŸÑÿØÿÆŸàŸÑ
  auth: createRateLimiter({
    windowMs: 60 * 60 * 1000, // ÿ≥ÿßÿπÿ© Ÿàÿßÿ≠ÿØÿ©
    max: 5, // 5 ŸÖÿ≠ÿßŸàŸÑÿßÿ™ ŸÅŸÇÿ∑
    message: {
      success: false,
      message: "Too many login attempts, please try again after an hour"
    },
    skipSuccessfulRequests: true
  }),
  
  // ŸÑÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ∑ŸÑÿ®ÿßÿ™
  orders: createRateLimiter({
    windowMs: 15 * 60 * 1000, // 15 ÿØŸÇŸäŸÇÿ©
    max: 20, // 20 ÿ∑ŸÑÿ® ŸÉŸÑ 15 ÿØŸÇŸäŸÇÿ©
    message: {
      success: false,
      message: "Too many orders, please wait before creating more"
    }
  }),
  
  // ŸÑŸÑÿ±ŸÅÿπ
  upload: createRateLimiter({
    windowMs: 10 * 60 * 1000, // 10 ÿØŸÇÿßÿ¶ŸÇ
    max: 20, // 20 ŸÖŸÑŸÅ ŸÅŸä 10 ÿØŸÇÿßÿ¶ŸÇ
    message: {
      success: false,
      message: "Too many file uploads, please try again later"
    }
  }),
  
  // ŸÑŸÑŸÄ API ÿßŸÑÿπÿßŸÖÿ©
  api: createRateLimiter({
    windowMs: 15 * 60 * 1000, // 15 ÿØŸÇŸäŸÇÿ©
    max: 100, // 100 ÿ∑ŸÑÿ® ŸÑŸÉŸÑ IP
    message: {
      success: false,
      message: "Too many API requests, please try again later"
    }
  }),
  
  // ŸÑŸÑÿ®ÿ≠ÿ´
  search: createRateLimiter({
    windowMs: 60 * 1000, // ÿØŸÇŸäŸÇÿ© Ÿàÿßÿ≠ÿØÿ©
    max: 30, // 30 ÿ∑ŸÑÿ® ÿ®ÿ≠ÿ´ ŸÅŸä ÿßŸÑÿØŸÇŸäŸÇÿ©
    message: {
      success: false,
      message: "Too many search requests, please slow down"
    }
  })
};

/**
 * Middleware ŸÑŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ£ÿµŸÑ ÿßŸÑÿ∑ŸÑÿ® (CORS)
 */
const corsProtection = (req, res, next) => {
  const allowedOrigins = [
    'http://localhost:3000',
    'http://localhost:3001',
    'https://fooddelivery.com',
    'https://www.fooddelivery.com',
    process.env.CLIENT_URL
  ].filter(Boolean);
  
  const origin = req.headers.origin;
  
  if (allowedOrigins.includes(origin)) {
    res.setHeader('Access-Control-Allow-Origin', origin);
  }
  
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, PATCH, DELETE, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Requested-With');
  res.setHeader('Access-Control-Allow-Credentials', 'true');
  res.setHeader('Access-Control-Max-Age', '86400'); // 24 ÿ≥ÿßÿπÿ©
  
  if (req.method === 'OPTIONS') {
    return res.status(200).end();
  }
  
  next();
};

/**
 * Middleware ŸÑŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ŸÜŸàÿπ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ
 */
const contentTypeValidation = (req, res, next) => {
  if (req.method === 'POST' || req.method === 'PUT' || req.method === 'PATCH') {
    const contentType = req.headers['content-type'];
    
    if (!contentType || !contentType.includes('application/json')) {
      if (contentType && contentType.includes('multipart/form-data')) {
        // ŸÖÿ≥ŸÖŸàÿ≠ ŸÑÿ±ŸÅÿπ ÿßŸÑŸÖŸÑŸÅÿßÿ™
        return next();
      }
      return next(new AppError('Content-Type must be application/json', 415));
    }
  }
  
  next();
};

/**
 * Middleware ŸÑŸÖŸÜÿπ MIME type sniffing
 */
const noSniff = (req, res, next) => {
  res.setHeader('X-Content-Type-Options', 'nosniff');
  next();
};

/**
 * Middleware ŸÑŸÖŸÜÿπ clickjacking
 */
const antiClickjacking = (req, res, next) => {
  res.setHeader('X-Frame-Options', 'DENY');
  next();
};

/**
 * Middleware ŸÑŸÖŸÜÿπ XSS ÿπÿ®ÿ± ÿßŸÑŸÖÿ™ÿµŸÅÿ≠
 */
const xssBrowserProtection = (req, res, next) => {
  res.setHeader('X-XSS-Protection', '1; mode=block');
  next();
};

/**
 * Middleware ŸÑŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ≠ÿ¨ŸÖ ÿßŸÑÿ∑ŸÑÿ®
 */
const requestSizeLimit = (maxSize = '10mb') => {
  return (req, res, next) => {
    const contentLength = req.headers['content-length'];
    
    if (contentLength) {
      const sizeInMB = parseInt(contentLength) / (1024 * 1024);
      const maxSizeInMB = parseInt(maxSize);
      
      if (sizeInMB > maxSizeInMB) {
        return next(new AppError(`Request size exceeds ${maxSize} limit`, 413));
      }
    }
    
    next();
  };
};

/**
 * Middleware ŸÑŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ user agent
 */
const userAgentValidation = (req, res, next) => {
  const userAgent = req.headers['user-agent'];
  
  if (!userAgent) {
    return next(new AppError('User-Agent header is required', 400));
  }
  
  // ŸäŸÖŸÉŸÜ ÿ•ÿ∂ÿßŸÅÿ© ŸÖÿ≤ŸäÿØ ŸÖŸÜ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸáŸÜÿß
  const blockedAgents = [
    'curl',
    'wget',
    'python-requests',
    'go-http-client',
    'java'
  ];
  
  const isBlocked = blockedAgents.some(agent => 
    userAgent.toLowerCase().includes(agent)
  );
  
  if (isBlocked && process.env.NODE_ENV === 'production') {
    return next(new AppError('Access denied for this user agent', 403));
  }
  
  next();
};

/**
 * Middleware ŸÑŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ referrer
 */
const referrerValidation = (req, res, next) => {
  const referrer = req.headers.referer || req.headers.referrer;
  
  if (referrer && process.env.NODE_ENV === 'production') {
    const allowedDomains = [
      'fooddelivery.com',
      'www.fooddelivery.com',
      'localhost:3000',
      'localhost:3001'
    ];
    
    const isAllowed = allowedDomains.some(domain => 
      referrer.includes(domain)
    );
    
    if (!isAllowed) {
      console.warn(`Blocked request from unauthorized referrer: ${referrer}`);
      return next(new AppError('Access denied', 403));
    }
  }
  
  next();
};

/**
 * Middleware ÿ¥ÿßŸÖŸÑ ŸÑŸÑÿ£ŸÖÿßŸÜ
 */
const securityMiddleware = (app) => {
  // Helmet ŸÑŸÑÿ≠ŸÖÿßŸäÿ© ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿäÿ©
  app.use(helmet({
    contentSecurityPolicy: {
      directives: {
        defaultSrc: ["'self'"],
        styleSrc: ["'self'", "'unsafe-inline'"],
        scriptSrc: ["'self'"],
        imgSrc: ["'self'", "data:", "https://res.cloudinary.com"],
        connectSrc: ["'self'", "ws://localhost:3000"],
        fontSrc: ["'self'"],
        objectSrc: ["'none'"],
        mediaSrc: ["'self'"],
        frameSrc: ["'none'"],
      },
    },
    crossOriginEmbedderPolicy: false,
    crossOriginResourcePolicy: { policy: "same-site" }
  }));
  
  // CORS protection
  app.use(corsProtection);
  
  // NoSQL injection protection
  app.use(nosqlInjectionProtection);
  
  // XSS protection
  app.use(xssProtection);
  
  // Parameter pollution protection
  app.use(parameterPollutionProtection);
  
  // Request size limit
  app.use(requestSizeLimit('10mb'));
  
  // Content type validation
  app.use(contentTypeValidation);
  
  // Additional security headers
  app.use(noSniff);
  app.use(antiClickjacking);
  app.use(xssBrowserProtection);
  
  // User agent validation (ŸÅŸä ÿßŸÑÿ•ŸÜÿ™ÿßÿ¨ ŸÅŸÇÿ∑)
  if (process.env.NODE_ENV === 'production') {
    app.use(userAgentValidation);
    app.use(referrerValidation);
  }
  
  console.log('‚úÖ Security middleware initialized');
};

module.exports = {
  securityMiddleware,
  rateLimiters,
  xssProtection,
  nosqlInjectionProtection,
  corsProtection,
  contentTypeValidation,
  requestSizeLimit,
  userAgentValidation,
  referrerValidation
};
</file>

<file path="src/middlewares/validation.middleware.js">
const { AppError } = require('./errorHandler.middleware');
const mongoose = require('mongoose');

class ValidationMiddleware {
  validateRegister(req, res, next) {
    const { name, phone, password, email, role } = req.body;
    
    const errors = [];
    
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿßÿ≥ŸÖ
    if (!name || name.trim().length < 2) {
      errors.push('ÿßŸÑÿßÿ≥ŸÖ Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ ÿ≠ÿ±ŸÅŸäŸÜ');
    }
    
    if (name && name.trim().length > 100) {
      errors.push('ÿßŸÑÿßÿ≥ŸÖ Ÿäÿ¨ÿ® ÿ£ŸÑÿß Ÿäÿ™ÿ¨ÿßŸàÿ≤ 100 ÿ≠ÿ±ŸÅ');
    }
    
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑŸáÿßÿ™ŸÅ
    if (!phone) {
      errors.push('ÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ ŸÖÿ∑ŸÑŸàÿ®');
    } else {
      const phoneRegex = /^\+?[1-9]\d{1,14}$/;
      if (!phoneRegex.test(phone.replace(/\s/g, ''))) {
        errors.push('ÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠');
      }
    }
    
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±
    if (!password) {
      errors.push('ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ŸÖÿ∑ŸÑŸàÿ®ÿ©');
    } else if (password.length < 6) {
      errors.push('ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± Ÿäÿ¨ÿ® ÿ£ŸÜ ÿ™ŸÉŸàŸÜ ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ 6 ÿ£ÿ≠ÿ±ŸÅ');
    } else if (password.length > 100) {
      errors.push('ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± Ÿäÿ¨ÿ® ÿ£ŸÑÿß ÿ™ÿ™ÿ¨ÿßŸàÿ≤ 100 ÿ≠ÿ±ŸÅ');
    }
    
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ®ÿ±ŸäÿØ ÿßŸÑÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜŸä
    if (email) {
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(email)) {
        errors.push('ÿßŸÑÿ®ÿ±ŸäÿØ ÿßŸÑÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜŸä ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠');
      }
    }
    
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿØŸàÿ±
    if (role && !['client', 'driver', 'admin'].includes(role)) {
      errors.push('ÿßŸÑÿØŸàÿ± ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠');
    }
    
    if (errors.length > 0) {
      return next(new AppError(errors.join(' | '), 400));
    }
    
    next();
  }

  validateLogin(req, res, next) {
    const { phone, password } = req.body;
    
    const errors = [];
    
    if (!phone) {
      errors.push('ÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ ŸÖÿ∑ŸÑŸàÿ®');
    }
    
    if (!password) {
      errors.push('ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ŸÖÿ∑ŸÑŸàÿ®ÿ©');
    }
    
    if (errors.length > 0) {
      return next(new AppError(errors.join(' | '), 400));
    }
    
    next();
  }

  validateOrder(req, res, next) {
    const { items, totalPrice, pickupAddress, deliveryAddress, restaurant } = req.body;
    
    const errors = [];
    
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿπŸÜÿßÿµÿ±
    if (!items || !Array.isArray(items) || items.length === 0) {
      errors.push('Ÿäÿ¨ÿ® ÿ•ÿ∂ÿßŸÅÿ© ÿπŸÜÿßÿµÿ± ŸÑŸÑÿ∑ŸÑÿ®');
    } else {
      items.forEach((item, index) => {
        if (!item.name || !item.qty || !item.price) {
          errors.push(`ÿßŸÑÿπŸÜÿµÿ± ${index + 1} ŸÜÿßŸÇÿµ ÿßŸÑŸÖÿπŸÑŸàŸÖÿßÿ™`);
        }
        
        if (item.qty <= 0) {
          errors.push(`ÿßŸÑŸÉŸÖŸäÿ© ŸÑŸÑÿπŸÜÿµÿ± ${index + 1} Ÿäÿ¨ÿ® ÿ£ŸÜ ÿ™ŸÉŸàŸÜ ÿ£ŸÉÿ®ÿ± ŸÖŸÜ ÿßŸÑÿµŸÅÿ±`);
        }
        
        if (item.price < 0) {
          errors.push(`ÿ≥ÿπÿ± ÿßŸÑÿπŸÜÿµÿ± ${index + 1} ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠`);
        }
      });
    }
    
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ≥ÿπÿ± ÿßŸÑÿ•ÿ¨ŸÖÿßŸÑŸä
    if (!totalPrice || totalPrice <= 0) {
      errors.push('ÿßŸÑÿ≥ÿπÿ± ÿßŸÑÿ•ÿ¨ŸÖÿßŸÑŸä ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠');
    }
    
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿπŸÜÿßŸàŸäŸÜ
    if (!pickupAddress || !mongoose.Types.ObjectId.isValid(pickupAddress)) {
      errors.push('ÿπŸÜŸàÿßŸÜ ÿßŸÑÿßÿ≥ÿ™ŸÑÿßŸÖ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠');
    }
    
    if (!deliveryAddress || !mongoose.Types.ObjectId.isValid(deliveryAddress)) {
      errors.push('ÿπŸÜŸàÿßŸÜ ÿßŸÑÿ™ŸàÿµŸäŸÑ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠');
    }
    
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑŸÖÿ∑ÿπŸÖ
    if (!restaurant || !mongoose.Types.ObjectId.isValid(restaurant)) {
      errors.push('ÿßŸÑŸÖÿ∑ÿπŸÖ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠');
    }
    
    if (errors.length > 0) {
      return next(new AppError(errors.join(' | '), 400));
    }
    
    next();
  }

  validateRestaurant(req, res, next) {
    const { name, type, phone, email } = req.body;
    
    const errors = [];
    
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿßÿ≥ŸÖ
    if (!name || name.trim().length < 2) {
      errors.push('ÿßÿ≥ŸÖ ÿßŸÑŸÖÿ∑ÿπŸÖ Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ ÿ≠ÿ±ŸÅŸäŸÜ');
    }
    
    if (name && name.trim().length > 100) {
      errors.push('ÿßÿ≥ŸÖ ÿßŸÑŸÖÿ∑ÿπŸÖ Ÿäÿ¨ÿ® ÿ£ŸÑÿß Ÿäÿ™ÿ¨ÿßŸàÿ≤ 100 ÿ≠ÿ±ŸÅ');
    }
    
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑŸÜŸàÿπ
    if (type && !['restaurant', 'cafe', 'bakery', 'fast-food', 'grocery', 'pharmacy', 'other'].includes(type)) {
      errors.push('ŸÜŸàÿπ ÿßŸÑŸÖÿ∑ÿπŸÖ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠');
    }
    
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑŸáÿßÿ™ŸÅ
    if (phone) {
      const phoneRegex = /^\+?[1-9]\d{1,14}$/;
      if (!phoneRegex.test(phone.replace(/\s/g, ''))) {
        errors.push('ÿ±ŸÇŸÖ Ÿáÿßÿ™ŸÅ ÿßŸÑŸÖÿ∑ÿπŸÖ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠');
      }
    }
    
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ®ÿ±ŸäÿØ ÿßŸÑÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜŸä
    if (email) {
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(email)) {
        errors.push('ÿ®ÿ±ŸäÿØ ÿßŸÑŸÖÿ∑ÿπŸÖ ÿßŸÑÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜŸä ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠');
      }
    }
    
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ±ÿ≥ŸàŸÖ ÿßŸÑÿ™ŸàÿµŸäŸÑ
    if (req.body.deliveryFee && req.body.deliveryFee < 0) {
      errors.push('ÿ±ÿ≥ŸàŸÖ ÿßŸÑÿ™ŸàÿµŸäŸÑ Ÿäÿ¨ÿ® ÿ£ŸÜ ÿ™ŸÉŸàŸÜ ÿ£ŸÉÿ®ÿ± ŸÖŸÜ ÿ£Ÿà ÿ™ÿ≥ÿßŸàŸä ÿßŸÑÿµŸÅÿ±');
    }
    
    if (errors.length > 0) {
      return next(new AppError(errors.join(' | '), 400));
    }
    
    next();
  }

  validateItem(req, res, next) {
    const { name, price, restaurant, category } = req.body;
    
    const errors = [];
    
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿßÿ≥ŸÖ
    if (!name || name.trim().length < 2) {
      errors.push('ÿßÿ≥ŸÖ ÿßŸÑÿπŸÜÿµÿ± Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ ÿ≠ÿ±ŸÅŸäŸÜ');
    }
    
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ≥ÿπÿ±
    if (!price || price <= 0) {
      errors.push('ÿ≥ÿπÿ± ÿßŸÑÿπŸÜÿµÿ± ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠');
    }
    
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑŸÖÿ∑ÿπŸÖ
    if (!restaurant || !mongoose.Types.ObjectId.isValid(restaurant)) {
      errors.push('ÿßŸÑŸÖÿ∑ÿπŸÖ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠');
    }
    
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑŸÅÿ¶ÿ©
    if (category && !['appetizer', 'main', 'dessert', 'drink', 'side', 'special'].includes(category)) {
      errors.push('ŸÅÿ¶ÿ© ÿßŸÑÿπŸÜÿµÿ± ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠ÿ©');
    }
    
    if (errors.length > 0) {
      return next(new AppError(errors.join(' | '), 400));
    }
    
    next();
  }

  validateAddress(req, res, next) {
    const { addressLine, label, latitude, longitude } = req.body;
    
    const errors = [];
    
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿπŸÜŸàÿßŸÜ
    if (!addressLine || addressLine.trim().length < 5) {
      errors.push('ÿßŸÑÿπŸÜŸàÿßŸÜ Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ 5 ÿ£ÿ≠ÿ±ŸÅ');
    }
    
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ™ÿ≥ŸÖŸäÿ©
    if (!label || !['Home', 'Work', 'Office', 'Other'].includes(label)) {
      errors.push('ÿ™ÿ≥ŸÖŸäÿ© ÿßŸÑÿπŸÜŸàÿßŸÜ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠ÿ©');
    }
    
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ•ÿ≠ÿØÿßÿ´Ÿäÿßÿ™ (ÿßÿÆÿ™Ÿäÿßÿ±Ÿä)
    if (latitude && (latitude < -90 || latitude > 90)) {
      errors.push('ÿÆÿ∑ ÿßŸÑÿπÿ±ÿ∂ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠');
    }
    
    if (longitude && (longitude < -180 || longitude > 180)) {
      errors.push('ÿÆÿ∑ ÿßŸÑÿ∑ŸàŸÑ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠');
    }
    
    if (errors.length > 0) {
      return next(new AppError(errors.join(' | '), 400));
    }
    
    next();
  }

  validateReview(req, res, next) {
    const { rating, comment, restaurant } = req.body;
    
    const errors = [];
    
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ™ŸÇŸäŸäŸÖ
    if (!rating || rating < 1 || rating > 5) {
      errors.push('ÿßŸÑÿ™ŸÇŸäŸäŸÖ Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ÿ®ŸäŸÜ 1 Ÿà 5');
    }
    
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ™ÿπŸÑŸäŸÇ
    if (comment && comment.length > 1000) {
      errors.push('ÿßŸÑÿ™ÿπŸÑŸäŸÇ Ÿäÿ¨ÿ® ÿ£ŸÑÿß Ÿäÿ™ÿ¨ÿßŸàÿ≤ 1000 ÿ≠ÿ±ŸÅ');
    }
    
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑŸÖÿ∑ÿπŸÖ
    if (!restaurant || !mongoose.Types.ObjectId.isValid(restaurant)) {
      errors.push('ÿßŸÑŸÖÿ∑ÿπŸÖ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠');
    }
    
    if (errors.length > 0) {
      return next(new AppError(errors.join(' | '), 400));
    }
    
    next();
  }

  validateNotification(req, res, next) {
    const { title, content, type, priority } = req.body;
    
    const errors = [];
    
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿπŸÜŸàÿßŸÜ
    if (!title || title.trim().length < 2) {
      errors.push('ÿπŸÜŸàÿßŸÜ ÿßŸÑÿ•ÿ¥ÿπÿßÿ± Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ ÿ≠ÿ±ŸÅŸäŸÜ');
    }
    
    if (title && title.length > 200) {
      errors.push('ÿπŸÜŸàÿßŸÜ ÿßŸÑÿ•ÿ¥ÿπÿßÿ± Ÿäÿ¨ÿ® ÿ£ŸÑÿß Ÿäÿ™ÿ¨ÿßŸàÿ≤ 200 ÿ≠ÿ±ŸÅ');
    }
    
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ
    if (!content || content.trim().length < 2) {
      errors.push('ŸÖÿ≠ÿ™ŸàŸâ ÿßŸÑÿ•ÿ¥ÿπÿßÿ± Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ ÿ≠ÿ±ŸÅŸäŸÜ');
    }
    
    if (content && content.length > 1000) {
      errors.push('ŸÖÿ≠ÿ™ŸàŸâ ÿßŸÑÿ•ÿ¥ÿπÿßÿ± Ÿäÿ¨ÿ® ÿ£ŸÑÿß Ÿäÿ™ÿ¨ÿßŸàÿ≤ 1000 ÿ≠ÿ±ŸÅ');
    }
    
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑŸÜŸàÿπ
    const validTypes = [
      'system', 'order_created', 'order_accepted', 'order_picked',
      'order_delivered', 'order_cancelled', 'driver_assigned',
      'driver_arrived', 'payment_success', 'payment_failed',
      'review_reminder', 'promotion', 'announcement', 'security', 'support'
    ];
    
    if (type && !validTypes.includes(type)) {
      errors.push('ŸÜŸàÿπ ÿßŸÑÿ•ÿ¥ÿπÿßÿ± ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠');
    }
    
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ£ŸàŸÑŸàŸäÿ©
    if (priority && !['low', 'medium', 'high', 'urgent'].includes(priority)) {
      errors.push('ÿ£ŸàŸÑŸàŸäÿ© ÿßŸÑÿ•ÿ¥ÿπÿßÿ± ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠ÿ©');
    }
    
    if (errors.length > 0) {
      return next(new AppError(errors.join(' | '), 400));
    }
    
    next();
  }

  validateChatMessage(req, res, next) {
    const { content, type, conversationId } = req.body;
    
    const errors = [];
    
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ
    if (!content || content.trim().length === 0) {
      errors.push('ŸÖÿ≠ÿ™ŸàŸâ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ŸÖÿ∑ŸÑŸàÿ®');
    }
    
    if (content && content.length > 5000) {
      errors.push('ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿ∑ŸàŸäŸÑÿ© ÿ¨ÿØÿßŸã (ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ 5000 ÿ≠ÿ±ŸÅ)');
    }
    
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑŸÜŸàÿπ
    const validTypes = [
      'text', 'image', 'video', 'audio', 'file',
      'location', 'contact', 'sticker', 'system',
      'order_update', 'delivery'
    ];
    
    if (type && !validTypes.includes(type)) {
      errors.push('ŸÜŸàÿπ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠');
    }
    
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
    if (!conversationId || !mongoose.Types.ObjectId.isValid(conversationId)) {
      errors.push('ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ© ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠ÿ©');
    }
    
    if (errors.length > 0) {
      return next(new AppError(errors.join(' | '), 400));
    }
    
    next();
  }

  validatePagination(req, res, next) {
    const { page, limit, sortBy, sortOrder } = req.query;
    
    const errors = [];
    
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿµŸÅÿ≠ÿ©
    if (page && (isNaN(page) || parseInt(page) < 1)) {
      errors.push('ÿ±ŸÇŸÖ ÿßŸÑÿµŸÅÿ≠ÿ© Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ÿ±ŸÇŸÖ ŸÖŸàÿ¨ÿ®');
    }
    
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ≠ÿØ
    if (limit && (isNaN(limit) || parseInt(limit) < 1 || parseInt(limit) > 100)) {
      errors.push('ÿßŸÑÿ≠ÿØ Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ÿ®ŸäŸÜ 1 Ÿà 100');
    }
    
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ™ÿ±ÿ™Ÿäÿ®
    if (sortOrder && !['asc', 'desc', 'ASC', 'DESC', '-1', '1'].includes(sortOrder)) {
      errors.push('ÿßÿ™ÿ¨ÿßŸá ÿßŸÑÿ™ÿ±ÿ™Ÿäÿ® ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠');
    }
    
    if (errors.length > 0) {
      return next(new AppError(errors.join(' | '), 400));
    }
    
    next();
  }

  validateFileUpload(req, res, next) {
    if (!req.file && !req.files) {
      return next(new AppError('ŸÑŸÖ Ÿäÿ™ŸÖ ÿ±ŸÅÿπ ÿ£Ÿä ŸÖŸÑŸÅ', 400));
    }
    
    next();
  }

  sanitizeInput(req, res, next) {
    // ÿ™ÿ∑ŸáŸäÿ± body
    if (req.body) {
      Object.keys(req.body).forEach(key => {
        if (typeof req.body[key] === 'string') {
          // ÿ•ÿ≤ÿßŸÑÿ© tags HTML ŸÑŸÑŸàŸÇÿßŸäÿ© ŸÖŸÜ XSS
          req.body[key] = req.body[key]
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .trim();
        }
      });
    }
    
    // ÿ™ÿ∑ŸáŸäÿ± query parameters
    if (req.query) {
      Object.keys(req.query).forEach(key => {
        if (typeof req.query[key] === 'string') {
          req.query[key] = req.query[key]
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .trim();
        }
      });
    }
    
    next();
  }

  validateObjectId(paramName) {
    return (req, res, next) => {
      const id = req.params[paramName];
      
      if (!id || !mongoose.Types.ObjectId.isValid(id)) {
        return next(new AppError(`ŸÖÿπÿ±ŸêŸëŸÅ ${paramName} ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠`, 400));
      }
      
      next();
    };
  }
}

module.exports = new ValidationMiddleware();
</file>

<file path="src/models/address.model.js">
const mongoose = require("mongoose");

const addressSchema = new mongoose.Schema(
  {
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },

    label: {
      type: String, // Home, Work, Office
      required: true,
    },

    addressLine: {
      type: String,
      required: true,
    },

    city: {
      type: String,
      default: "Niamey",
    },

    latitude: Number,
    longitude: Number,

    isDefault: {
      type: Boolean,
      default: false,
    },
  },
  { timestamps: true }
);

module.exports = mongoose.model("Address", addressSchema);
</file>

<file path="src/models/device.model.js">
const mongoose = require("mongoose");

const deviceSchema = new mongoose.Schema(
  {
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
      index: true,
    },
    
    deviceToken: {
      type: String,
      required: true,
      index: true,
    },
    
    platform: {
      type: String,
      required: true,
      enum: ["ios", "android", "web"],
    },
    
    deviceId: {
      type: String,
      required: true,
      index: true,
    },
    
    deviceModel: String,
    deviceBrand: String,
    osVersion: String,
    
    appVersion: {
      type: String,
    },
    
    lastActive: {
      type: Date,
      default: Date.now,
    },
    
    isActive: {
      type: Boolean,
      default: true,
    },
    
    preferences: {
      notifications: {
        enabled: { type: Boolean, default: true },
        sound: { type: Boolean, default: true },
        vibration: { type: Boolean, default: true },
        badge: { type: Boolean, default: true },
      },
    },
    
    metadata: {
      type: mongoose.Schema.Types.Mixed,
      default: {},
    },
  },
  {
    timestamps: true,
  }
);

// ŸÖŸÜÿπ ÿ™ÿ≥ÿ¨ŸäŸÑ ŸÜŸÅÿ≥ ÿßŸÑÿ¨Ÿáÿßÿ≤ ŸÑŸÜŸÅÿ≥ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ£ŸÉÿ´ÿ± ŸÖŸÜ ŸÖÿ±ÿ©
deviceSchema.index({ user: 1, deviceId: 1 }, { unique: true });

// Middleware
deviceSchema.pre("save", function(next) {
  if (this.isModified("deviceToken")) {
    this.lastActive = new Date();
  }
  next();
});

// Static Methods
deviceSchema.statics.findActiveDevices = function(userId) {
  return this.find({
    user: userId,
    isActive: true,
    lastActive: { $gt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) }, // ÿ¢ÿÆÿ± 30 ŸäŸàŸÖ
  });
};

deviceSchema.statics.deactivateDevice = async function(deviceId, userId) {
  return await this.findOneAndUpdate(
    { _id: deviceId, user: userId },
    { isActive: false },
    { new: true }
  );
};

deviceSchema.statics.deactivateAllDevices = async function(userId) {
  return await this.updateMany(
    { user: userId },
    { isActive: false }
  );
};

module.exports = mongoose.model("Device", deviceSchema);
</file>

<file path="src/models/driverLocation.model.js">
const mongoose = require("mongoose");

const driverLocationSchema = new mongoose.Schema(
  {
    driver: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
      index: true,
    },
    order: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Order",
      default: null,
      index: true,
    },
    location: {
      type: {
        type: String,
        enum: ["Point"],
        default: "Point",
      },
      coordinates: {
        type: [Number], // [lng, lat]
        required: true,
      },
    },
    createdAt: {
      type: Date,
      default: Date.now,
      expires: 60 * 10, // üßπ Ÿäÿ≠ÿ∞ŸÅ ÿ®ÿπÿØ 10 ÿØŸÇÿßÿ¶ŸÇ
    },
  }
);

// Geo index
driverLocationSchema.index({ location: "2dsphere" });

module.exports = mongoose.model("DriverLocation", driverLocationSchema);
</file>

<file path="src/models/message.model.js">
const mongoose = require("mongoose");

const messageSchema = new mongoose.Schema(
  {
    // ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ© ÿßŸÑÿ™Ÿä ÿ™ŸÜÿ™ŸÖŸä ÿ•ŸÑŸäŸáÿß ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©
    conversation: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Conversation",
      required: true,
      index: true,
    },
    
    // ÿßŸÑŸÖÿ±ÿ≥ŸÑ
    sender: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
      index: true,
    },
    
    // ŸÜŸàÿπ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©
    type: {
      type: String,
      required: true,
      enum: [
        "text",         // ŸÜÿµ
        "image",        // ÿµŸàÿ±ÿ©
        "video",        // ŸÅŸäÿØŸäŸà
        "audio",        // ÿµŸàÿ™
        "file",         // ŸÖŸÑŸÅ
        "location",     // ŸÖŸàŸÇÿπ
        "contact",      // ÿ¨Ÿáÿ© ÿßÿ™ÿµÿßŸÑ
        "sticker",      // ŸÖŸÑÿµŸÇ
        "system",       // ÿ±ÿ≥ÿßŸÑÿ© ŸÜÿ∏ÿßŸÖ
        "order_update", // ÿ™ÿ≠ÿØŸäÿ´ ÿ∑ŸÑÿ®
        "delivery",     // ÿ™ÿ≠ÿØŸäÿ´ ÿ™ŸàÿµŸäŸÑ
      ],
      default: "text",
    },
    
    // ŸÖÿ≠ÿ™ŸàŸâ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©
    content: {
      text: {
        type: String,
        trim: true,
        maxlength: 5000,
      },
      media: {
        url: String,
        thumbnail: String,
        filename: String,
        size: Number,
        mimeType: String,
        duration: Number, // ŸÑŸÑŸÖŸÑŸÅÿßÿ™ ÿßŸÑÿµŸàÿ™Ÿäÿ©/ÿßŸÑŸÖÿ±ÿ¶Ÿäÿ©
        dimensions: {
          width: Number,
          height: Number,
        },
      },
      location: {
        latitude: Number,
        longitude: Number,
        address: String,
      },
      contact: {
        name: String,
        phone: String,
        email: String,
      },
      system: {
        action: String,
        data: mongoose.Schema.Types.Mixed,
      },
    },
    
    // ÿ±ÿØ ÿπŸÑŸâ ÿ±ÿ≥ÿßŸÑÿ© ÿ≥ÿßÿ®ŸÇÿ©
    replyTo: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Message",
    },
    
    // ÿ•ÿ¥ÿßÿ±ÿßÿ™ ŸÑŸÑÿ£ÿπÿ∂ÿßÿ° (Mentions)
    mentions: [{
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
    }],
    
    // ÿßŸÑŸàÿ≥ŸàŸÖ (ŸÑŸÑÿ™ŸÜÿ∏ŸäŸÖ)
    tags: [{
      type: String,
      trim: true,
    }],
    
    // ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿ™ÿ≥ŸÑŸäŸÖ ŸàÿßŸÑŸÇÿ±ÿßÿ°ÿ©
    delivery: {
      sentAt: {
        type: Date,
        default: Date.now,
        index: true,
      },
      deliveredAt: Date,
      readBy: [{
        user: {
          type: mongoose.Schema.Types.ObjectId,
          ref: "User",
        },
        readAt: {
          type: Date,
          default: Date.now,
        },
      }],
      deliveredTo: [{
        user: {
          type: mongoose.Schema.Types.ObjectId,
          ref: "User",
        },
        deliveredAt: Date,
      }],
    },
    
    // ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿ™ÿ≠ÿ±Ÿäÿ±
    edited: {
      isEdited: {
        type: Boolean,
        default: false,
      },
      editCount: {
        type: Number,
        default: 0,
      },
      lastEditedAt: Date,
      history: [{
        content: mongoose.Schema.Types.Mixed,
        editedAt: Date,
      }],
    },
    
    // ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿ≠ÿ∞ŸÅ
    deleted: {
      isDeleted: {
        type: Boolean,
        default: false,
      },
      deletedAt: Date,
      deletedBy: {
        type: mongoose.Schema.Types.ObjectId,
        ref: "User",
      },
      deleteType: {
        type: String,
        enum: ["sender", "admin", "system"],
      },
    },
    
    // ÿ±ÿØŸàÿØ ÿßŸÑŸÅÿπŸÑ (Reactions)
    reactions: [{
      user: {
        type: mongoose.Schema.Types.ObjectId,
        ref: "User",
      },
      emoji: {
        type: String,
        required: true,
      },
      reactedAt: {
        type: Date,
        default: Date.now,
      },
    }],
    
    // ŸÑŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑŸÖŸáŸÖÿ© (Starred)
    starredBy: [{
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
    }],
    
    // ŸÑŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑŸÖÿ´ÿ®ÿ™ÿ©
    pinned: {
      isPinned: {
        type: Boolean,
        default: false,
      },
      pinnedAt: Date,
      pinnedBy: {
        type: mongoose.Schema.Types.ObjectId,
        ref: "User",
      },
    },
    
    // ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑŸÖÿ≠ŸàŸÑÿ© (Forwarded)
    forwarded: {
      isForwarded: {
        type: Boolean,
        default: false,
      },
      originalMessage: {
        type: mongoose.Schema.Types.ObjectId,
        ref: "Message",
      },
      forwardCount: {
        type: Number,
        default: 0,
      },
    },
    
    // ŸÖŸäÿ™ÿßÿØÿßÿ™ÿß ÿ•ÿ∂ÿßŸÅŸäÿ©
    metadata: {
      type: mongoose.Schema.Types.Mixed,
      default: {},
    },
    
    // ÿßŸÑŸÜÿ≥ÿÆ ÿßŸÑÿ•ÿ∂ÿßŸÅŸäÿ© (ŸÑŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑŸÖŸÜŸÇŸàŸÑÿ©)
    copies: [{
      conversation: {
        type: mongoose.Schema.Types.ObjectId,
        ref: "Conversation",
      },
      messageId: {
        type: mongoose.Schema.Types.ObjectId,
      },
    }],
  },
  {
    timestamps: true,
    toJSON: { virtuals: true },
    toObject: { virtuals: true },
  }
);

// Indexes
messageSchema.index({ conversation: 1, "delivery.sentAt": -1 });
messageSchema.index({ sender: 1, "delivery.sentAt": -1 });
messageSchema.index({ "delivery.readBy.user": 1 });
messageSchema.index({ type: 1, "delivery.sentAt": -1 });

// Middleware
messageSchema.pre("save", function(next) {
  // ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿ±ÿ≥ÿßŸÑÿ© ŸÜÿµŸäÿ© Ÿàÿ™ÿ≠ÿ™ŸàŸä ÿπŸÑŸâ mentions
  if (this.type === "text" && this.content.text) {
    // ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ÿßŸÑŸÄ mentions ŸÖŸÜ ÿßŸÑŸÜÿµ (@username)
    const mentionRegex = /@([\w\u0600-\u06FF]+)/g;
    const mentions = [...this.content.text.matchAll(mentionRegex)].map(m => m[1]);
    
    if (mentions.length > 0) {
      // TODO: ÿ™ÿ≠ŸàŸäŸÑ usernames ÿ•ŸÑŸâ user IDs
    }
  }
  
  // ÿ•ÿ∞ÿß ÿ™ŸÖ ÿßŸÑÿ™ÿπÿØŸäŸÑ
  if (this.isModified("content") && !this.isNew) {
    this.edited.isEdited = true;
    this.edited.editCount += 1;
    this.edited.lastEditedAt = new Date();
    
    // ÿ≠ŸÅÿ∏ ÿßŸÑÿ™ÿßÿ±ŸäÿÆ
    this.edited.history.push({
      content: this._previousContent || this.content,
      editedAt: new Date(),
    });
    
    // ÿßŸÑÿ≠ŸÅÿßÿ∏ ÿπŸÑŸâ ÿ¢ÿÆÿ± 10 ÿ™ÿπÿØŸäŸÑÿßÿ™ ŸÅŸÇÿ∑
    if (this.edited.history.length > 10) {
      this.edited.history = this.edited.history.slice(-10);
    }
  }
  
  next();
});

messageSchema.pre("save", async function(next) {
  if (this.isNew) {
    // ÿ™ÿ≠ÿØŸäÿ´ ÿ¢ÿÆÿ± ÿ±ÿ≥ÿßŸÑÿ© ŸÅŸä ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
    const Conversation = require("./conversation.model");
    await Conversation.findByIdAndUpdate(
      this.conversation,
      {
        lastMessage: this._id,
        lastActivity: new Date(),
        $inc: { "stats.messageCount": 1 },
      }
    );
    
    // ÿ™ÿ≠ÿØŸäÿ´ ŸàŸÇÿ™ ÿ¢ÿÆÿ± ÿ±ÿ≥ÿßŸÑÿ©
    if (!this.conversation.stats?.firstMessageAt) {
      await Conversation.findByIdAndUpdate(
        this.conversation,
        {
          "stats.firstMessageAt": new Date(),
          "stats.lastMessageAt": new Date(),
        }
      );
    }
  }
  next();
});

// Virtuals
messageSchema.virtual("isRead").get(function() {
  return this.delivery.readBy.length > 0;
});

messageSchema.virtual("isDelivered").get(function() {
  return this.delivery.deliveredTo.length > 0;
});

messageSchema.virtual("timeAgo").get(function() {
  const now = new Date();
  const sent = new Date(this.delivery.sentAt);
  const diffMs = now - sent;
  const diffMins = Math.floor(diffMs / 60000);
  const diffHours = Math.floor(diffMs / 3600000);
  const diffDays = Math.floor(diffMs / 86400000);
  
  if (diffMins < 1) return "ÿßŸÑÿ¢ŸÜ";
  if (diffMins < 60) return `ŸÖŸÜÿ∞ ${diffMins} ÿØŸÇŸäŸÇÿ©`;
  if (diffHours < 24) return `ŸÖŸÜÿ∞ ${diffHours} ÿ≥ÿßÿπÿ©`;
  if (diffDays < 7) return `ŸÖŸÜÿ∞ ${diffDays} ŸäŸàŸÖ`;
  if (diffDays < 30) return `ŸÖŸÜÿ∞ ${Math.floor(diffDays / 7)} ÿ£ÿ≥ÿ®Ÿàÿπ`;
  return `ŸÖŸÜÿ∞ ${Math.floor(diffDays / 30)} ÿ¥Ÿáÿ±`;
});

// Methods
messageSchema.methods.markAsDelivered = async function(userId) {
  if (!this.delivery.deliveredTo.some(d => d.user.toString() === userId.toString())) {
    this.delivery.deliveredTo.push({
      user: userId,
      deliveredAt: new Date(),
    });
    
    if (!this.delivery.deliveredAt) {
      this.delivery.deliveredAt = new Date();
    }
    
    await this.save();
  }
  return this;
};

messageSchema.methods.markAsRead = async function(userId) {
  if (!this.delivery.readBy.some(r => r.user.toString() === userId.toString())) {
    this.delivery.readBy.push({
      user: userId,
      readAt: new Date(),
    });
    await this.save();
  }
  return this;
};

messageSchema.methods.addReaction = async function(userId, emoji) {
  // ÿ•ÿ≤ÿßŸÑÿ© ÿ±ÿØ ÿßŸÑŸÅÿπŸÑ ÿßŸÑÿ≥ÿßÿ®ŸÇ ŸÑŸÜŸÅÿ≥ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
  this.reactions = this.reactions.filter(
    reaction => reaction.user.toString() !== userId.toString()
  );
  
  // ÿ•ÿ∂ÿßŸÅÿ© ÿ±ÿØ ÿßŸÑŸÅÿπŸÑ ÿßŸÑÿ¨ÿØŸäÿØ
  this.reactions.push({
    user: userId,
    emoji,
    reactedAt: new Date(),
  });
  
  await this.save();
  return this;
};

messageSchema.methods.removeReaction = async function(userId) {
  this.reactions = this.reactions.filter(
    reaction => reaction.user.toString() !== userId.toString()
  );
  
  await this.save();
  return this;
};

messageSchema.methods.toggleStar = async function(userId) {
  const index = this.starredBy.findIndex(
    id => id.toString() === userId.toString()
  );
  
  if (index === -1) {
    this.starredBy.push(userId);
  } else {
    this.starredBy.splice(index, 1);
  }
  
  await this.save();
  return this;
};

messageSchema.methods.pin = async function(userId) {
  this.pinned.isPinned = true;
  this.pinned.pinnedAt = new Date();
  this.pinned.pinnedBy = userId;
  
  await this.save();
  return this;
};

messageSchema.methods.unpin = async function() {
  this.pinned.isPinned = false;
  this.pinned.pinnedAt = null;
  this.pinned.pinnedBy = null;
  
  await this.save();
  return this;
};

messageSchema.methods.softDelete = async function(userId, deleteType = "sender") {
  this.deleted.isDeleted = true;
  this.deleted.deletedAt = new Date();
  this.deleted.deletedBy = userId;
  this.deleted.deleteType = deleteType;
  
  await this.save();
  return this;
};

messageSchema.methods.edit = async function(newContent) {
  const oldContent = { ...this.content };
  
  this.content = newContent;
  await this.save();
  
  return { oldContent, newContent };
};

// Static Methods
messageSchema.statics.createTextMessage = async function(conversationId, senderId, text, replyTo = null) {
  const message = await this.create({
    conversation: conversationId,
    sender: senderId,
    type: "text",
    content: {
      text: text.trim(),
    },
    replyTo,
    delivery: {
      sentAt: new Date(),
    },
  });
  
  return message;
};

messageSchema.statics.createMediaMessage = async function(conversationId, senderId, mediaData, type = "image") {
  const message = await this.create({
    conversation: conversationId,
    sender: senderId,
    type,
    content: {
      media: mediaData,
    },
    delivery: {
      sentAt: new Date(),
    },
  });
  
  return message;
};

messageSchema.statics.createSystemMessage = async function(conversationId, action, data = {}) {
  const message = await this.create({
    conversation: conversationId,
    sender: null, // ÿßŸÑŸÜÿ∏ÿßŸÖ
    type: "system",
    content: {
      system: {
        action,
        data,
      },
    },
    delivery: {
      sentAt: new Date(),
    },
  });
  
  return message;
};

messageSchema.statics.createOrderUpdateMessage = async function(conversationId, orderData) {
  const message = await this.create({
    conversation: conversationId,
    sender: null,
    type: "order_update",
    content: {
      text: `ÿ™ÿ≠ÿØŸäÿ´ ÿπŸÑŸâ ÿßŸÑÿ∑ŸÑÿ®: ${orderData.status}`,
      system: {
        action: "order_update",
        data: orderData,
      },
    },
    delivery: {
      sentAt: new Date(),
    },
  });
  
  return message;
};

messageSchema.statics.getConversationMessages = async function(conversationId, options = {}) {
  const {
    page = 1,
    limit = 50,
    before = null,
    after = null,
    types = [],
    includeDeleted = false,
    includeSystem = true,
  } = options;
  
  const skip = (page - 1) * limit;
  
  const query = {
    conversation: conversationId,
  };
  
  if (!includeDeleted) {
    query["deleted.isDeleted"] = false;
  }
  
  if (!includeSystem) {
    query.type = { $ne: "system" };
  }
  
  if (types.length > 0) {
    query.type = { $in: types };
  }
  
  if (before) {
    query["delivery.sentAt"] = { $lt: new Date(before) };
  }
  
  if (after) {
    query["delivery.sentAt"] = { $gt: new Date(after) };
  }
  
  const [messages, total] = await Promise.all([
    this.find(query)
      .populate("sender", "name image role")
      .populate("replyTo", "content.text sender type delivery.sentAt")
      .populate("mentions", "name image")
      .sort({ "delivery.sentAt": -1 })
      .skip(skip)
      .limit(limit)
      .lean(),
    
    this.countDocuments(query),
  ]);
  
  // ÿπŸÉÿ≥ ÿßŸÑÿ™ÿ±ÿ™Ÿäÿ® ŸÑÿ£ŸÇÿØŸÖ ‚Üí ÿ£ÿ≠ÿØÿ´
  messages.reverse();
  
  return {
    messages,
    pagination: {
      page,
      limit,
      total,
      totalPages: Math.ceil(total / limit),
      hasMore: skip + limit < total,
    },
  };
};

messageSchema.statics.searchMessages = async function(conversationId, searchTerm, options = {}) {
  const {
    page = 1,
    limit = 20,
    sender = null,
    types = ["text"],
    dateFrom = null,
    dateTo = null,
  } = options;
  
  const skip = (page - 1) * limit;
  
  const query = {
    conversation: conversationId,
    "deleted.isDeleted": false,
    type: { $in: types },
  };
  
  if (searchTerm) {
    query["content.text"] = { $regex: searchTerm, $options: "i" };
  }
  
  if (sender) {
    query.sender = sender;
  }
  
  if (dateFrom) {
    query["delivery.sentAt"] = { $gte: new Date(dateFrom) };
  }
  
  if (dateTo) {
    query["delivery.sentAt"] = { $lte: new Date(dateTo) };
  }
  
  const [messages, total] = await Promise.all([
    this.find(query)
      .populate("sender", "name image")
      .sort({ "delivery.sentAt": -1 })
      .skip(skip)
      .limit(limit)
      .lean(),
    
    this.countDocuments(query),
  ]);
  
  return {
    messages,
    pagination: {
      page,
      limit,
      total,
      totalPages: Math.ceil(total / limit),
    },
  };
};

messageSchema.statics.markAllAsRead = async function(conversationId, userId) {
  const result = await this.updateMany(
    {
      conversation: conversationId,
      sender: { $ne: userId },
      "delivery.readBy.user": { $ne: userId },
    },
    {
      $push: {
        "delivery.readBy": {
          user: userId,
          readAt: new Date(),
        },
      },
    }
  );
  
  return result.modifiedCount;
};

messageSchema.statics.getUnreadCount = async function(conversationId, userId) {
  return await this.countDocuments({
    conversation: conversationId,
    sender: { $ne: userId },
    "delivery.readBy.user": { $ne: userId },
    "deleted.isDeleted": false,
  });
};

module.exports = mongoose.model("Message", messageSchema);
</file>

<file path="src/models/notification.model.js">
const mongoose = require("mongoose");

const notificationSchema = new mongoose.Schema(
  {
    // ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑŸÖÿ≥ÿ™ŸáÿØŸÅ
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
      index: true,
    },
    
    // ŸÜŸàÿπ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±
    type: {
      type: String,
      required: true,
      enum: [
        "system",           // ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿßŸÑŸÜÿ∏ÿßŸÖ
        "order_created",    // ÿ∑ŸÑÿ® ÿ¨ÿØŸäÿØ
        "order_accepted",   // ÿ™ŸÖ ŸÇÿ®ŸàŸÑ ÿßŸÑÿ∑ŸÑÿ®
        "order_picked",     // ÿ™ŸÖ ÿßÿ≥ÿ™ŸÑÿßŸÖ ÿßŸÑÿ∑ŸÑÿ®
        "order_delivered",  // ÿ™ŸÖ ÿßŸÑÿ™ŸàÿµŸäŸÑ
        "order_cancelled",  // ÿ∑ŸÑÿ® ŸÖŸÑÿ∫Ÿä
        "driver_assigned",  // ÿ™ŸÖ ÿ™ÿπŸäŸäŸÜ ŸÖŸÜÿØŸàÿ®
        "driver_arrived",   // ÿßŸÑŸÖŸÜÿØŸàÿ® ŸàÿµŸÑ
        "payment_success",  // ÿØŸÅÿπ ŸÜÿßÿ¨ÿ≠
        "payment_failed",   // ÿØŸÅÿπ ŸÅÿßÿ¥ŸÑ
        "review_reminder",  // ÿ™ÿ∞ŸÉŸäÿ± ÿ®ÿßŸÑÿ™ŸÇŸäŸäŸÖ
        "promotion",        // ÿπÿ±Ÿàÿ∂ ÿ™ÿ±ŸàŸäÿ¨Ÿäÿ©
        "announcement",     // ÿ•ÿπŸÑÿßŸÜÿßÿ™
        "security",         // ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿ£ŸÖŸÜŸäÿ©
        "support",          // ÿ±ÿØŸàÿØ ÿßŸÑÿØÿπŸÖ
      ],
      index: true,
    },
    
    // ÿßŸÑÿπŸÜŸàÿßŸÜ
    title: {
      type: String,
      required: true,
      trim: true,
      maxlength: 200,
    },
    
    // ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ
    content: {
      type: String,
      required: true,
      trim: true,
      maxlength: 1000,
    },
    
    // ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ•ÿ∂ÿßŸÅŸäÿ©
    data: {
      type: mongoose.Schema.Types.Mixed,
      default: {},
    },
    
    // ÿßŸÑÿµŸàÿ±ÿ© ÿ£Ÿà ÿßŸÑÿ£ŸäŸÇŸàŸÜÿ©
    icon: {
      type: String,
    },
    
    // ÿßŸÑÿ±ÿßÿ®ÿ∑ ÿßŸÑŸÖÿ±ÿ™ÿ®ÿ∑
    link: {
      type: String,
      trim: true,
    },
    
    // ÿ£ŸàŸÑŸàŸäÿ© ÿßŸÑÿ•ÿ¥ÿπÿßÿ±
    priority: {
      type: String,
      enum: ["low", "medium", "high", "urgent"],
      default: "medium",
    },
    
    // ÿ≠ÿßŸÑÿ© ÿßŸÑÿ•ÿ¥ÿπÿßÿ±
    status: {
      type: String,
      enum: ["unread", "read", "archived", "deleted"],
      default: "unread",
      index: true,
    },
    
    // ŸàŸÇÿ™ ÿßŸÑÿ•ÿ±ÿ≥ÿßŸÑ
    sentAt: {
      type: Date,
      default: Date.now,
      index: true,
    },
    
    // ŸàŸÇÿ™ ÿßŸÑŸÇÿ±ÿßÿ°ÿ©
    readAt: {
      type: Date,
    },
    
    // ÿ™ÿßÿ±ŸäÿÆ ÿßŸÜÿ™Ÿáÿßÿ° ÿßŸÑÿµŸÑÿßÿ≠Ÿäÿ©
    expiresAt: {
      type: Date,
      index: true,
    },
    
    // ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™
    settings: {
      push: { type: Boolean, default: true },       // ÿ•ÿ±ÿ≥ÿßŸÑ push notification
      email: { type: Boolean, default: false },     // ÿ•ÿ±ÿ≥ÿßŸÑ email
      sms: { type: Boolean, default: false },       // ÿ•ÿ±ÿ≥ÿßŸÑ SMS
      inApp: { type: Boolean, default: true },      // ÿπÿ±ÿ∂ ŸÅŸä ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ
    },
    
    // ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑÿ•ÿ±ÿ≥ÿßŸÑ
    delivery: {
      pushSent: { type: Boolean, default: false },
      emailSent: { type: Boolean, default: false },
      smsSent: { type: Boolean, default: false },
      pushError: String,
      emailError: String,
      smsError: String,
      retryCount: { type: Number, default: 0 },
    },
    
    // ÿ™ÿ™ÿ®ÿπ ÿßŸÑÿ≠ŸÖŸÑÿ©
    campaignId: {
      type: String,
      index: true,
    },
    
    // ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ©
    group: {
      type: String,
      index: true,
    },
    
    // ÿßŸÑŸàÿ≥ŸàŸÖ
    tags: [{
      type: String,
      trim: true,
      index: true,
    }],
  },
  {
    timestamps: true,
    toJSON: { virtuals: true },
    toObject: { virtuals: true },
  }
);

// Indexes
notificationSchema.index({ user: 1, status: 1, sentAt: -1 });
notificationSchema.index({ type: 1, sentAt: -1 });
notificationSchema.index({ expiresAt: 1 }, { expireAfterSeconds: 0 }); // ŸÑÿ≠ÿ∞ŸÅ ÿßŸÑŸÖŸÜÿ™ŸáŸäÿ© ÿ™ŸÑŸÇÿßÿ¶ŸäÿßŸã

// Middleware
notificationSchema.pre("save", function(next) {
  if (this.isModified("status") && this.status === "read" && !this.readAt) {
    this.readAt = new Date();
  }
  
  // ÿ™ÿπŸäŸäŸÜ ÿ™ÿßÿ±ŸäÿÆ ÿßŸÜÿ™Ÿáÿßÿ° ÿßŸÑÿµŸÑÿßÿ≠Ÿäÿ© ÿ•ÿ∞ÿß ŸÑŸÖ ŸäŸÉŸÜ ŸÖŸàÿ¨ŸàÿØÿßŸã
  if (!this.expiresAt) {
    const expiryDays = {
      urgent: 7,     // 7 ÿ£ŸäÿßŸÖ ŸÑŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿßŸÑÿπÿßÿ¨ŸÑÿ©
      high: 14,      // 14 ŸäŸàŸÖ ŸÑŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿßŸÑŸÖŸáŸÖÿ©
      medium: 30,    // 30 ŸäŸàŸÖ ŸÑŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿßŸÑÿπÿßÿØŸäÿ©
      low: 60,       // 60 ŸäŸàŸÖ ŸÑŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿßŸÑŸÖŸÜÿÆŸÅÿ∂ÿ©
    };
    
    this.expiresAt = new Date();
    this.expiresAt.setDate(this.expiresAt.getDate() + (expiryDays[this.priority] || 30));
  }
  
  next();
});

// Virtuals
notificationSchema.virtual("isExpired").get(function() {
  return this.expiresAt && this.expiresAt < new Date();
});

notificationSchema.virtual("timeAgo").get(function() {
  const now = new Date();
  const sent = new Date(this.sentAt);
  const diffMs = now - sent;
  const diffMins = Math.floor(diffMs / 60000);
  const diffHours = Math.floor(diffMs / 3600000);
  const diffDays = Math.floor(diffMs / 86400000);
  
  if (diffMins < 1) return "ÿßŸÑÿ¢ŸÜ";
  if (diffMins < 60) return `ŸÖŸÜÿ∞ ${diffMins} ÿØŸÇŸäŸÇÿ©`;
  if (diffHours < 24) return `ŸÖŸÜÿ∞ ${diffHours} ÿ≥ÿßÿπÿ©`;
  if (diffDays < 7) return `ŸÖŸÜÿ∞ ${diffDays} ŸäŸàŸÖ`;
  if (diffDays < 30) return `ŸÖŸÜÿ∞ ${Math.floor(diffDays / 7)} ÿ£ÿ≥ÿ®Ÿàÿπ`;
  if (diffDays < 365) return `ŸÖŸÜÿ∞ ${Math.floor(diffDays / 30)} ÿ¥Ÿáÿ±`;
  return `ŸÖŸÜÿ∞ ${Math.floor(diffDays / 365)} ÿ≥ŸÜÿ©`;
});

// Static Methods
notificationSchema.statics.createForOrder = async function(order, type, additionalData = {}) {
  const Notification = this;
  
  let title, content, priority = "medium";
  
  switch (type) {
    case "order_created":
      title = "ÿ™ŸÖ ÿ•ŸÜÿ¥ÿßÿ° ÿ∑ŸÑÿ® ÿ¨ÿØŸäÿØ";
      content = `ÿ™ŸÖ ÿ•ŸÜÿ¥ÿßÿ° ÿ∑ŸÑÿ®ŸÉ #${order._id.toString().slice(-6)} ÿ®ŸÜÿ¨ÿßÿ≠.`;
      priority = "high";
      break;
      
    case "order_accepted":
      title = "ÿ™ŸÖ ŸÇÿ®ŸàŸÑ ÿ∑ŸÑÿ®ŸÉ";
      content = `ÿ™ŸÖ ŸÇÿ®ŸàŸÑ ÿ∑ŸÑÿ®ŸÉ #${order._id.toString().slice(-6)} Ÿàÿ¨ÿßÿ±Ÿä ÿ™ÿ¨ŸáŸäÿ≤Ÿá.`;
      priority = "high";
      break;
      
    case "driver_assigned":
      title = "ÿ™ŸÖ ÿ™ÿπŸäŸäŸÜ ŸÖŸÜÿØŸàÿ®";
      content = `ÿ™ŸÖ ÿ™ÿπŸäŸäŸÜ ŸÖŸÜÿØŸàÿ® ŸÑÿ™ŸàÿµŸäŸÑ ÿ∑ŸÑÿ®ŸÉ #${order._id.toString().slice(-6)}.`;
      priority = "high";
      break;
      
    case "order_picked":
      title = "ÿ™ŸÖ ÿßÿ≥ÿ™ŸÑÿßŸÖ ÿßŸÑÿ∑ŸÑÿ®";
      content = `ÿ™ŸÖ ÿßÿ≥ÿ™ŸÑÿßŸÖ ÿ∑ŸÑÿ®ŸÉ #${order._id.toString().slice(-6)} ŸÖŸÜ ÿßŸÑŸÖÿ∑ÿπŸÖ.`;
      priority = "medium";
      break;
      
    case "order_delivered":
      title = "ÿ™ŸÖ ÿ™ŸàÿµŸäŸÑ ÿßŸÑÿ∑ŸÑÿ®";
      content = `ÿ™ŸÖ ÿ™ŸàÿµŸäŸÑ ÿ∑ŸÑÿ®ŸÉ #${order._id.toString().slice(-6)} ÿ®ŸÜÿ¨ÿßÿ≠.`;
      priority = "high";
      break;
      
    case "order_cancelled":
      title = "ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿßŸÑÿ∑ŸÑÿ®";
      content = `ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿ∑ŸÑÿ®ŸÉ #${order._id.toString().slice(-6)}.`;
      priority = "urgent";
      break;
      
    default:
      title = "ÿ™ÿ≠ÿØŸäÿ´ ÿπŸÑŸâ ÿ∑ŸÑÿ®ŸÉ";
      content = `ŸáŸÜÿßŸÉ ÿ™ÿ≠ÿØŸäÿ´ ÿπŸÑŸâ ÿ∑ŸÑÿ®ŸÉ #${order._id.toString().slice(-6)}.`;
  }
  
  const notification = await Notification.create({
    user: order.user,
    type,
    title,
    content,
    priority,
    data: {
      orderId: order._id,
      orderNumber: order._id.toString().slice(-6),
      status: order.status,
      totalPrice: order.totalPrice,
      restaurant: order.restaurant?._id || order.restaurant,
      driver: order.driver?._id || order.driver,
      ...additionalData,
    },
    link: `/orders/${order._id}`,
    icon: this.getIconByType(type),
    tags: ["order", type, `order_${order._id}`],
  });
  
  return notification;
};

notificationSchema.statics.createForUser = async function(userId, type, data = {}) {
  const Notification = this;
  
  const templates = {
    welcome: {
      title: "ŸÖÿ±ÿ≠ÿ®ÿßŸã ÿ®ŸÉ!",
      content: "ÿ¥ŸÉÿ±ÿßŸã ŸÑÿßŸÜÿ∂ŸÖÿßŸÖŸÉ ÿ•ŸÑŸäŸÜÿß. ŸÜÿ™ŸÖŸÜŸâ ŸÑŸÉ ÿ™ÿ¨ÿ±ÿ®ÿ© ŸÖŸÖÿ™ÿπÿ©.",
      priority: "medium",
    },
    password_changed: {
      title: "ÿ™ŸÖ ÿ™ÿ∫ŸäŸäÿ± ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±",
      content: "ÿ™ŸÖ ÿ™ÿ∫ŸäŸäÿ± ŸÉŸÑŸÖÿ© ŸÖÿ±Ÿàÿ± ÿ≠ÿ≥ÿßÿ®ŸÉ ÿ®ŸÜÿ¨ÿßÿ≠.",
      priority: "high",
    },
    profile_updated: {
      title: "ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÖŸÑŸÅ ÿßŸÑÿ¥ÿÆÿµŸä",
      content: "ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿ´ ŸÖÿπŸÑŸàŸÖÿßÿ™ ŸÖŸÑŸÅŸÉ ÿßŸÑÿ¥ÿÆÿµŸä ÿ®ŸÜÿ¨ÿßÿ≠.",
      priority: "low",
    },
    new_message: {
      title: "ÿ±ÿ≥ÿßŸÑÿ© ÿ¨ÿØŸäÿØÿ©",
      content: data.message || "ŸÑÿØŸäŸÉ ÿ±ÿ≥ÿßŸÑÿ© ÿ¨ÿØŸäÿØÿ©.",
      priority: "medium",
    },
    review_reminder: {
      title: "ŸÉŸäŸÅ ŸÉÿßŸÜÿ™ ÿ™ÿ¨ÿ±ÿ®ÿ™ŸÉÿü",
      content: "ÿ¥ÿßÿ±ŸÉŸÜÿß ÿ™ÿ¨ÿ±ÿ®ÿ™ŸÉ ŸÖÿπ ÿßŸÑŸÖÿ∑ÿπŸÖ ŸÑÿ™ÿ≥ÿßÿπÿØ ÿßŸÑÿ¢ÿÆÿ±ŸäŸÜ.",
      priority: "low",
    },
  };
  
  const template = templates[type] || {
    title: "ÿ•ÿ¥ÿπÿßÿ± ÿ¨ÿØŸäÿØ",
    content: data.content || "ŸÑÿØŸäŸÉ ÿ•ÿ¥ÿπÿßÿ± ÿ¨ÿØŸäÿØ.",
    priority: "medium",
  };
  
  const notification = await Notification.create({
    user: userId,
    type: "system",
    title: template.title,
    content: template.content,
    priority: template.priority,
    data,
    icon: this.getIconByType(type),
    tags: ["user", type, `user_${userId}`],
  });
  
  return notification;
};

notificationSchema.statics.createPromotional = async function(userId, data) {
  const Notification = this;
  
  const notification = await Notification.create({
    user: userId,
    type: "promotion",
    title: data.title || "ÿπÿ±ÿ∂ ÿÆÿßÿµ!",
    content: data.content || "ÿßÿ≥ÿ™ŸÖÿ™ÿπ ÿ®ÿπÿ±Ÿàÿ∂ŸÜÿß ÿßŸÑÿÆÿßÿµÿ© ŸàÿßŸÑŸÖŸÖŸäÿ≤ÿ©.",
    priority: data.priority || "medium",
    data: {
      promotionId: data.promotionId,
      discount: data.discount,
      validUntil: data.validUntil,
      ...data,
    },
    link: data.link,
    icon: data.icon || "üéÅ",
    campaignId: data.campaignId,
    group: data.group,
    tags: ["promotion", "marketing", ...(data.tags || [])],
  });
  
  return notification;
};

notificationSchema.statics.getIconByType = function(type) {
  const icons = {
    system: "üîî",
    order_created: "üõí",
    order_accepted: "‚úÖ",
    order_picked: "üì¶",
    order_delivered: "üöö",
    order_cancelled: "‚ùå",
    driver_assigned: "üöó",
    driver_arrived: "üìç",
    payment_success: "üí≥",
    payment_failed: "‚ö†Ô∏è",
    review_reminder: "‚≠ê",
    promotion: "üéÅ",
    announcement: "üì¢",
    security: "üîí",
    support: "üí¨",
    welcome: "üëã",
    password_changed: "üîë",
    profile_updated: "üë§",
    new_message: "üí¨",
  };
  
  return icons[type] || "üîî";
};

notificationSchema.statics.getUnreadCount = async function(userId) {
  return await this.countDocuments({
    user: userId,
    status: "unread",
    expiresAt: { $gt: new Date() },
  });
};

notificationSchema.statics.markAllAsRead = async function(userId) {
  return await this.updateMany(
    {
      user: userId,
      status: "unread",
    },
    {
      status: "read",
      readAt: new Date(),
    }
  );
};

notificationSchema.statics.cleanupExpired = async function() {
  return await this.deleteMany({
    expiresAt: { $lt: new Date() },
  });
};

// Instance Methods
notificationSchema.methods.markAsRead = async function() {
  this.status = "read";
  this.readAt = new Date();
  return await this.save();
};

notificationSchema.methods.markAsUnread = async function() {
  this.status = "unread";
  this.readAt = null;
  return await this.save();
};

notificationSchema.methods.archive = async function() {
  this.status = "archived";
  return await this.save();
};

notificationSchema.methods.retryDelivery = async function() {
  if (this.delivery.retryCount >= 3) {
    throw new Error("Maximum retry attempts reached");
  }
  
  this.delivery.retryCount += 1;
  this.delivery.pushSent = false;
  this.delivery.emailSent = false;
  this.delivery.smsSent = false;
  
  await this.save();
  
  // TODO: ÿ•ÿπÿßÿØÿ© ŸÖÿ≠ÿßŸàŸÑÿ© ÿßŸÑÿ•ÿ±ÿ≥ÿßŸÑ
  return this;
};

module.exports = mongoose.model("Notification", notificationSchema);
</file>

<file path="src/models/order.model.js">
const mongoose = require("mongoose");

const orderSchema = new mongoose.Schema(
  {
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    restaurant: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Restaurant",
      required: true,
    },
    driver: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      default: null,
    },
    items: [
      {
        name: String,
        qty: Number,
        price: Number,
      },
    ],
    totalPrice: {
      type: Number,
      required: true,
    },
    pickupAddress: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Address",
      required: true
    },
    deliveryAddress: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Address",
      required: true
    },
    status: {
      type: String,
      enum: ["pending", "accepted", "picked", "delivered", "cancelled"],
      default: "pending",
    },
  },
  { timestamps: true }
);

module.exports = mongoose.model("Order", orderSchema);
</file>

<file path="src/models/restaurantAddress.model.js">
const mongoose = require("mongoose");

const restaurantAddressSchema = new mongoose.Schema(
  {
    restaurant: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Restaurant",
      required: true,
    },

    addressLine: {
      type: String,
      required: true,
    },

    city: {
      type: String,
      default: "Niamey",
    },

    latitude: Number,
    longitude: Number,
  },
  { timestamps: true }
);

module.exports = mongoose.model("RestaurantAddress", restaurantAddressSchema);
</file>

<file path="src/models/review.model.js">
const mongoose = require("mongoose");

const reviewSchema = new mongoose.Schema(
  {
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    restaurant: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Restaurant",
      required: true,
    },
    rating: {
      type: Number,
      min: 1,
      max: 5,
      required: true,
    },
    comment: {
      type: String,
      trim: true,
    },
  },
  { timestamps: true }
);

// üö´ ŸÖŸÜÿπ ŸÜŸÅÿ≥ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÖŸÜ ÿ™ŸÇŸäŸäŸÖ ŸÜŸÅÿ≥ ÿßŸÑŸÖÿ∑ÿπŸÖ ŸÖÿ±ÿ™ŸäŸÜ
reviewSchema.index({ user: 1, restaurant: 1 }, { unique: true });

module.exports = mongoose.model("Review", reviewSchema);
</file>

<file path="src/routes/address.routes.js">
const express = require("express");
const router = express.Router();

const addressController = require("../controllers/address.controller");
const auth = require("../middlewares/auth.middleware");

router.post("/", auth, addressController.createAddress);
router.get("/me", auth, addressController.getMyAddresses);
router.delete("/:id", auth, addressController.deleteAddress);

module.exports = router;
</file>

<file path="src/routes/chat.routes.js">
const express = require("express");
const router = express.Router();
const chatController = require("../controllers/chat.controller");
const auth = require("../middlewares/auth.middleware");
const role = require("../middlewares/role.middleware");
const upload = require("../middlewares/upload");
// ŸÅŸä routes/chat.routes.js - ÿ•ÿ∂ÿßŸÅÿ© ŸÅŸä ÿßŸÑÿ£ÿπŸÑŸâ
const Conversation = require("../models/conversation.model");
const Message = require("../models/message.model");

/**
 * üí¨ ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿßÿ™
 */

// ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ŸÖÿ≠ÿßÿØÿ´ÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
router.get("/conversations", auth, chatController.getUserConversations);

// ÿ•ŸÜÿ¥ÿßÿ° ŸÖÿ≠ÿßÿØÿ´ÿ© ÿ¨ÿØŸäÿØÿ©
router.post("/conversations", auth, chatController.createConversation);

// ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ŸÖÿ≠ÿßÿØÿ´ÿ© ŸÖÿπŸäŸÜÿ©
router.get("/conversations/:id", auth, chatController.getConversation);

// ÿ™ÿ≠ÿØŸäÿ´ ŸÖÿ≠ÿßÿØÿ´ÿ©
router.put("/conversations/:id", auth, chatController.updateConversation);

// ÿ•ÿ∂ÿßŸÅÿ© ŸÖÿ¥ÿßÿ±ŸÉ ŸÑŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
router.post("/conversations/:id/participants", auth, chatController.addParticipant);

// ÿ•ÿ≤ÿßŸÑÿ© ŸÖÿ¥ÿßÿ±ŸÉ ŸÖŸÜ ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
router.delete("/conversations/:id/participants/:participantId", auth, chatController.removeParticipant);

/**
 * üí¨ ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ
 */

// ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
router.get("/conversations/:id/messages", auth, chatController.getConversationMessages);

// ÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ÿ≥ÿßŸÑÿ© ŸÜÿµŸäÿ©
router.post("/conversations/:id/messages", auth, chatController.sendMessage);

// ÿ™ÿ≠ÿØŸäÿ´ ÿ±ÿ≥ÿßŸÑÿ©
router.put("/conversations/:conversationId/messages/:messageId", auth, chatController.updateMessage);

// ÿ≠ÿ∞ŸÅ ÿ±ÿ≥ÿßŸÑÿ©
router.delete("/conversations/:conversationId/messages/:messageId", auth, chatController.deleteMessage);

// ÿßŸÑÿ®ÿ≠ÿ´ ŸÅŸä ÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
router.get("/conversations/:id/search", auth, chatController.searchMessages);

// ÿ±ŸÅÿπ ŸÖŸÑŸÅ ŸÑŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
router.post(
  "/conversations/:id/upload",
  auth,
  upload("chat/files").single("file"),
  chatController.uploadFile
);

/**
 * üí¨ ÿßŸÑÿ™ŸÅÿßÿπŸÑÿßÿ™
 */

// ÿ•ÿ∂ÿßŸÅÿ© ÿ±ÿØ ŸÅÿπŸÑ ÿπŸÑŸâ ÿ±ÿ≥ÿßŸÑÿ©
router.post("/conversations/:conversationId/messages/:messageId/reactions", auth, chatController.addReaction);

// ÿ•ÿ≤ÿßŸÑÿ© ÿ±ÿØ ŸÅÿπŸÑ ŸÖŸÜ ÿ±ÿ≥ÿßŸÑÿ©
router.delete("/conversations/:conversationId/messages/:messageId/reactions", auth, chatController.removeReaction);

// ÿ™ÿ´ÿ®Ÿäÿ™ ÿ±ÿ≥ÿßŸÑÿ©
router.post("/conversations/:conversationId/messages/:messageId/pin", auth, chatController.pinMessage);

/**
 * üìä ÿßŸÑÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ŸàÿßŸÑÿ•ÿØÿßÿ±ÿ©
 */

// ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿØÿ±ÿØÿ¥ÿ©
router.get("/stats", auth, chatController.getChatStats);

// ÿØÿπŸÖ ÿßŸÑÿØÿ±ÿØÿ¥ÿßÿ™ (ŸÑŸÑÿ£ÿØŸÖŸÜ ŸÅŸÇÿ∑)
router.get("/admin/support-conversations", auth, role("admin"), async (req, res) => {
  try {
    const { status, department, assignedTo } = req.query;
    
    const query = {
      type: "support",
      deletedAt: null,
    };
    
    if (status) query["metadata.support.status"] = status;
    if (department) query["metadata.support.department"] = department;
    if (assignedTo) query["metadata.support.assignedTo"] = assignedTo;

    const conversations = await Conversation.find(query)
      .populate("participants", "name image")
      .populate("metadata.support.assignedTo", "name image")
      .sort({ lastActivity: -1 })
      .limit(50)
      .lean();

    // ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿØÿπŸÖ
    const stats = await Conversation.aggregate([
      { $match: { type: "support", deletedAt: null } },
      {
        $group: {
          _id: {
            status: "$metadata.support.status",
            department: "$metadata.support.department",
          },
          count: { $sum: 1 },
          avgResponseTime: { $avg: "$stats.avgResponseTime" },
        },
      },
    ]);

    res.json({
      success: true,
      data: {
        conversations,
        stats: stats.reduce((acc, item) => {
          if (!acc[item._id.department]) {
            acc[item._id.department] = {};
          }
          acc[item._id.department][item._id.status] = item.count;
          return acc;
        }, {}),
      },
    });
  } catch (error) {
    console.error("Support conversations error:", error);
    res.status(500).json({ message: "Failed to get support conversations" });
  }
});

// ÿ™ÿπŸäŸäŸÜ ŸÖÿ≠ÿßÿØÿ´ÿ© ÿØÿπŸÖ (ŸÑŸÑÿ£ÿØŸÖŸÜ ŸÅŸÇÿ∑)
router.put("/admin/conversations/:id/assign", auth, role("admin"), async (req, res) => {
  try {
    const { id } = req.params;
    const { assignedTo } = req.body;

    const conversation = await Conversation.findByIdAndUpdate(
      id,
      {
        "metadata.support.assignedTo": assignedTo,
        "metadata.support.status": "pending",
      },
      { new: true }
    )
      .populate("metadata.support.assignedTo", "name image")
      .populate("participants", "name image");

    if (!conversation) {
      return res.status(404).json({ message: "Conversation not found" });
    }

    // ÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ÿ≥ÿßŸÑÿ© ŸÜÿ∏ÿßŸÖ
    await Message.createSystemMessage(
      conversation._id,
      "support_assigned",
      {
        assignedTo: conversation.metadata.support.assignedTo,
        assignedBy: req.user.id,
      }
    );

    res.json({
      success: true,
      message: "Conversation assigned successfully",
      data: { conversation },
    });
  } catch (error) {
    console.error("Assign conversation error:", error);
    res.status(500).json({ message: "Failed to assign conversation" });
  }
});

module.exports = router;
</file>

<file path="src/routes/driver.routes.js">
// src/routes/driver.routes.js
const express = require("express");
const router = express.Router();
const auth = require("../middlewares/auth.middleware");
const role = require("../middlewares/role.middleware");
const DriverLocation = require("../models/driverLocation.model");

// ŸÑŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ŸÉŸÑ ÿßŸÑŸÖŸàÿßŸÇÿπ ŸÅŸä ÿßŸÑŸàŸÇÿ™ ÿßŸÑÿ≠ÿßŸÑŸä
router.get("/", auth, role("admin"), async (req, res) => {
  const locations = await DriverLocation.find()
    .populate("driver", "name phone")
    .sort({ timestamp: -1 });
  res.json(locations);
});

module.exports = router;
</file>

<file path="src/routes/health.routes.js">
const express = require('express');
const router = express.Router();
const healthCheckService = require('../services/healthCheck.service');

// Health check ÿ≥ÿ±Ÿäÿπ
router.get('/', async (req, res) => {
  try {
    const health = await healthCheckService.quickHealthCheck();
    
    res.status(health.status === 'ok' ? 200 : 503).json({
      success: health.status === 'ok',
      ...health
    });
  } catch (error) {
    res.status(503).json({
      success: false,
      status: 'error',
      message: 'Health check failed',
      error: error.message
    });
  }
});

// Health check ŸÖŸÅÿµŸÑ
router.get('/detailed', async (req, res) => {
  try {
    const health = await healthCheckService.fullHealthCheck();
    
    res.status(health.status === 'healthy' ? 200 : 
               health.status === 'warning' ? 200 : 503).json({
      success: health.status !== 'unhealthy',
      ...health
    });
  } catch (error) {
    res.status(503).json({
      success: false,
      status: 'error',
      message: 'Detailed health check failed',
      error: error.message
    });
  }
});

// Health check ŸÑŸÑŸÖÿ±ÿßŸÇÿ®ÿ© (Prometheus format)
router.get('/metrics', async (req, res) => {
  try {
    const health = await healthCheckService.fullHealthCheck();
    
    const metrics = [
      '# HELP app_health Application health status',
      '# TYPE app_health gauge',
      `app_health{status="${health.status}"} ${health.status === 'healthy' ? 1 : health.status === 'warning' ? 0.5 : 0}`,
      
      '# HELP app_uptime Application uptime in seconds',
      '# TYPE app_uptime gauge',
      `app_uptime ${health.uptime}`,
      
      '# HELP app_checks_total Total health checks',
      '# TYPE app_checks_total gauge',
      `app_checks_total ${health.checks.length}`,
      
      '# HELP app_checks_healthy Healthy health checks',
      '# TYPE app_checks_healthy gauge',
      `app_checks_healthy ${health.checks.filter(c => c.status === 'healthy').length}`
    ];

    res.set('Content-Type', 'text/plain');
    res.send(metrics.join('\n'));
  } catch (error) {
    res.status(503).send(`# ERROR: ${error.message}`);
  }
});

// Readiness probe (ŸÑŸÄ Kubernetes/Docker)
router.get('/ready', async (req, res) => {
  try {
    const health = await healthCheckService.quickHealthCheck();
    
    if (health.status === 'ok') {
      res.status(200).json({ status: 'ready' });
    } else {
      res.status(503).json({ status: 'not ready' });
    }
  } catch (error) {
    res.status(503).json({ status: 'not ready', error: error.message });
  }
});

// Liveness probe
router.get('/live', (req, res) => {
  res.status(200).json({ status: 'alive' });
});

module.exports = router;
</file>

<file path="src/routes/notification.routes.js">
const express = require("express");
const router = express.Router();
const notificationController = require("../controllers/notification.controller");
const auth = require("../middlewares/auth.middleware");
const role = require("../middlewares/role.middleware");

/**
 * üîî ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿßŸÑÿ¥ÿÆÿµŸäÿ© (ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ≠ÿßŸÑŸä)
 */

// ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
router.get("/", auth, notificationController.getUserNotifications);

// ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™
router.get("/stats", auth, notificationController.getNotificationStats);

// ÿ™ÿ≠ÿØŸäÿ´ ÿ≠ÿßŸÑÿ© ÿ•ÿ¥ÿπÿßÿ± ŸÖÿπŸäŸÜ
router.put("/:id/status", auth, notificationController.updateNotificationStatus);

// ÿ™ÿ≠ÿØŸäÿØ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ŸÉŸÖŸÇÿ±Ÿàÿ°ÿ©
router.put("/mark-all-read", auth, notificationController.markAllAsRead);

// ÿ≠ÿ∞ŸÅ ÿ•ÿ¥ÿπÿßÿ± ŸÖÿπŸäŸÜ
router.delete("/:id", auth, notificationController.deleteNotification);

// ÿ≠ÿ∞ŸÅ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿßŸÑŸÖŸÇÿ±Ÿàÿ°ÿ©
router.delete("/read/cleanup", auth, notificationController.deleteReadNotifications);

// ÿ™ÿ≠ÿØŸäÿ´ ÿ™ŸÅÿ∂ŸäŸÑÿßÿ™ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™
router.put("/preferences", auth, notificationController.updateNotificationPreferences);

// ÿ™ÿ≥ÿ¨ŸäŸÑ ÿ¨Ÿáÿßÿ≤ ŸÑŸÄ Push Notifications
router.post("/devices", auth, notificationController.registerDevice);

/**
 * üëë ÿ•ÿØÿßÿ±ÿ© ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ (ŸÑŸÑÿ£ÿØŸÖŸÜ ŸÅŸÇÿ∑)
 */

// ÿ•ÿ±ÿ≥ÿßŸÑ ÿ•ÿ¥ÿπÿßÿ± ŸÖÿÆÿµÿµ
router.post("/send", auth, role("admin"), notificationController.sendCustomNotification);

// ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿ≠ŸÖŸÑÿ©
router.get("/campaign/:campaignId/stats", auth, role("admin"), notificationController.getCampaignStats);

module.exports = router;
</file>

<file path="src/routes/restaurantAddress.routes.js">
const express = require("express");
const router = express.Router();
const auth = require("../middlewares/auth.middleware");
const role = require("../middlewares/role.middleware");
const restaurantAddressController = require("../controllers/restaurantAddress.controller");

// ÿ•ŸÜÿ¥ÿßÿ° ÿπŸÜŸàÿßŸÜ ŸÑŸÑŸÖÿ∑ÿπŸÖ (Admin)
router.post("/", auth, role("admin"), restaurantAddressController.createAddress);

// ÿ¨ŸÑÿ® ÿπŸÜÿßŸàŸäŸÜ ŸÖÿ∑ÿπŸÖ ŸÖÿπŸäŸÜ
router.get("/:restaurantId", restaurantAddressController.getAddresses);

module.exports = router;
</file>

<file path="src/routes/restaurantComplete.routes.js">
const express = require("express");
const router = express.Router();
const restaurantCompleteController = require("../controllers/restaurantComplete.controller");
const auth = require("../middlewares/auth.middleware");
const role = require("../middlewares/role.middleware");

/**
 * üöÄ ÿ•ŸÜÿ¥ÿßÿ° ŸÖÿ∑ÿπŸÖ ŸÉÿßŸÖŸÑ (ÿ¨ŸÖŸäÿπ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ŸÅŸä request Ÿàÿßÿ≠ÿØ)
 * POST /api/restaurants/complete
 * 
 * Content-Type: multipart/form-data
 * 
 * Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ:
 * 1. ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ∑ÿπŸÖ ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿäÿ© (ŸÜÿµŸäÿ©)
 * 2. ÿµŸàÿ± ÿßŸÑŸÖÿ∑ÿπŸÖ (ŸÖŸÑŸÅÿßÿ™)
 * 3. ÿπŸÜÿßŸàŸäŸÜ ÿßŸÑŸÖÿ∑ÿπŸÖ (JSON)
 * 4. ÿπŸÜÿßÿµÿ± ÿßŸÑŸÇÿßÿ¶ŸÖÿ© (JSON + ÿµŸàÿ±)
 * 5. ÿ≥ÿßÿπÿßÿ™ ÿßŸÑÿπŸÖŸÑ (JSON)
 */
router.post(
  "/complete",
  auth,
  role("admin"),
  restaurantCompleteController.uploadRestaurantFiles,
  restaurantCompleteController.createCompleteRestaurant
);

/**
 * üîÑ ÿ™ÿ≠ÿØŸäÿ´ ŸÖÿ∑ÿπŸÖ ŸÉÿßŸÖŸÑ
 * PUT /api/restaurants/:id/complete
 */
router.put(
  "/:id/complete",
  auth,
  role("admin"),
  restaurantCompleteController.uploadRestaurantFiles,
  restaurantCompleteController.updateCompleteRestaurant
);

module.exports = router;
</file>

<file path="src/routes/review.routes.js">
const express = require("express");
const router = express.Router({ mergeParams: true });

const reviewController = require("../controllers/review.controller");
const auth = require("../middlewares/auth.middleware");

// ÿ•ÿ∂ÿßŸÅÿ© ÿ™ŸÇŸäŸäŸÖ ŸÑŸÖÿ∑ÿπŸÖ
router.post("/", auth, reviewController.addReview);

// ÿ¨ŸÑÿ® ÿ™ŸÇŸäŸäŸÖÿßÿ™ ŸÖÿ∑ÿπŸÖ
router.get("/", reviewController.getRestaurantReviews);

module.exports = router;
</file>

<file path="src/routes/user.routes.js">
const express = require("express");
const router = express.Router();
const userController = require("../controllers/user.controller");
const auth = require("../middlewares/auth.middleware");
const role = require("../middlewares/role.middleware");
const upload = require("../middlewares/upload");

// 1Ô∏è‚É£ ÿ¨ŸÑÿ® ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ≠ÿßŸÑŸä
router.get("/me", auth, userController.getMyProfile);

// 2Ô∏è‚É£ ÿ±ŸÅÿπ ÿßŸÑÿµŸàÿ±ÿ© ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ≠ÿßŸÑŸä


router.put(
  "/me/avatar",
  auth,
  upload("users").single("image"), // ‚úÖ ŸÖÿ¨ŸÑÿØ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ
  userController.uploadAvatar
);

// 3Ô∏è‚É£ ÿ¨ŸÑÿ® ŸÉŸÑ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ (admin ŸÅŸÇÿ∑)
router.get("/", auth, role("admin"), userController.getUsers);

// 4Ô∏è‚É£ ÿ¨ŸÑÿ® ŸÖÿ≥ÿ™ÿÆÿØŸÖ Ÿàÿßÿ≠ÿØ ÿ≠ÿ≥ÿ® id (admin ŸÅŸÇÿ∑)
router.get("/:id", auth, role("admin"), userController.getUser);

// 5Ô∏è‚É£ ÿ•ŸÜÿ¥ÿßÿ° ŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ¨ÿØŸäÿØ
router.post("/", userController.createUser);

module.exports = router;
</file>

<file path="src/routes/userComplete.routes.js">
const express = require("express");
const router = express.Router();
const userCompleteController = require("../controllers/userComplete.controller");
const authController = require("../controllers/auth.controller");
const auth = require("../middlewares/auth.middleware");
const role = require("../middlewares/role.middleware");
const upload = require("../middlewares/upload");
// ŸÅŸä routes/userComplete.routes.js - ÿ•ÿ∂ÿßŸÅÿ© ŸÅŸä ÿßŸÑÿ£ÿπŸÑŸâ
const User = require("../models/user.model");
const Order = require("../models/order.model");

/**
 * üîê Authentication Routes
 */

// ÿ™ÿ≥ÿ¨ŸäŸÑ ÿ¨ÿØŸäÿØ ŸÖÿ™ŸÇÿØŸÖ
router.post("/auth/register/complete", authController.registerComplete);

// ÿ™ÿ≥ÿ¨ŸäŸÑ ÿØÿÆŸàŸÑ ŸÖÿ™ŸÇÿØŸÖ
router.post("/auth/login/complete", authController.loginComplete);

// ÿ™ÿ£ŸÉŸäÿØ ÿßŸÑÿ≠ÿ≥ÿßÿ®
router.post("/auth/verify", authController.verifyAccount);

// ÿ•ÿπÿßÿØÿ© ÿ•ÿ±ÿ≥ÿßŸÑ ŸÉŸàÿØ ÿßŸÑÿ™ÿ≠ŸÇŸÇ
router.post("/auth/resend-verification", authController.resendVerification);

// ŸÜÿ≥Ÿäÿ™ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±
router.post("/auth/forgot-password", authController.forgotPassword);

// ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±
router.post("/auth/reset-password", authController.resetPassword);

// ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿÆÿ±Ÿàÿ¨
router.post("/auth/logout", auth, authController.logout);

// ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿµŸÑÿßÿ≠Ÿäÿ© Token
router.get("/auth/validate", auth, authController.validateToken);

/**
 * üë§ User Profile Routes (Authenticated)
 */

// ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ ÿßŸÑÿ¥ÿÆÿµŸä ÿßŸÑŸÉÿßŸÖŸÑ
router.get("/users/me/complete", auth, userCompleteController.getMyCompleteProfile);

// ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÖŸÑŸÅ ÿßŸÑÿ¥ÿÆÿµŸä
router.put("/users/me/complete", auth, userCompleteController.updateCompleteProfile);

// ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿµŸàÿ±ÿ© ÿßŸÑÿ¥ÿÆÿµŸäÿ©
router.put(
  "/users/me/avatar",
  auth,
  upload("users/avatars").single("image"),
  userCompleteController.updateAvatar
);

// ÿ™ÿ≠ÿØŸäÿ´ ÿµŸàÿ±ÿ© ÿßŸÑÿ∫ŸÑÿßŸÅ
router.put(
  "/users/me/cover",
  auth,
  upload("users/covers").single("image"),
  userCompleteController.updateCoverImage
);

// ÿ™ÿ∫ŸäŸäÿ± ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±
router.put("/users/me/password", auth, userCompleteController.changePassword);

// ÿ•ÿØÿßÿ±ÿ© ÿßŸÑŸÖŸÅÿ∂ŸÑÿ©
router.post("/users/me/favorites/:restaurantId", auth, userCompleteController.toggleFavorite);

// ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ≥ÿ¨ŸÑ ÿßŸÑŸÜÿ¥ÿßÿ∑ÿßÿ™
router.get("/users/me/activity", auth, userCompleteController.getActivityLog);

// ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
router.get("/users/me/stats", auth, userCompleteController.getUserStats);

// ÿ™ÿ≠ÿØŸäÿ´ ÿ≠ÿßŸÑÿ© ÿßŸÑÿ™Ÿàÿßÿ¨ÿØ
router.put("/users/me/presence", auth, userCompleteController.updatePresence);

/**
 * üëë Admin Routes (Admin only)
 */

// ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ¨ŸÖŸäÿπ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ŸÖÿπ Pagination
router.get("/admin/users", auth, role("admin"), async (req, res) => {
  try {
    const PaginationUtils = require("../utils/pagination.util");
    const paginationOptions = PaginationUtils.getPaginationOptions(req);
    const { skip, limit, sort, search, filters } = paginationOptions;
    
    let query = {};
    
    // ÿßŸÑÿ®ÿ≠ÿ´
    if (search) {
      query.$or = [
        { name: { $regex: search, $options: "i" } },
        { phone: { $regex: search, $options: "i" } },
        { email: { $regex: search, $options: "i" } },
      ];
    }
    
    // ÿßŸÑŸÅŸÑÿßÿ™ÿ±
    if (filters.role) query.role = filters.role;
    if (filters.isVerified !== undefined) query.isVerified = filters.isVerified === "true";
    if (filters.isActive !== undefined) query.isActive = filters.isActive === "true";
    
    if (filters.minDate || filters.maxDate) {
      query.createdAt = {};
      if (filters.minDate) query.createdAt.$gte = new Date(filters.minDate);
      if (filters.maxDate) query.createdAt.$lte = new Date(filters.maxDate);
    }

    const [users, total] = await Promise.all([
      User.find(query)
        .select("-password -verificationCode -resetPasswordToken -activityLog")
        .sort(sort)
        .skip(skip)
        .limit(limit),
      
      User.countDocuments(query),
    ]);

    // ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿ£ÿØŸÖŸÜ
    const stats = await User.aggregate([
      { $match: query },
      {
        $facet: {
          byRole: [
            {
              $group: {
                _id: "$role",
                count: { $sum: 1 },
              },
            },
          ],
          byStatus: [
            {
              $group: {
                _id: "$isActive",
                count: { $sum: 1 },
              },
            },
          ],
          byVerification: [
            {
              $group: {
                _id: "$isVerified",
                count: { $sum: 1 },
              },
            },
          ],
          growth: [
            {
              $group: {
                _id: {
                  $dateToString: { format: "%Y-%m", date: "$createdAt" },
                },
                count: { $sum: 1 },
              },
            },
            { $sort: { _id: -1 } },
            { $limit: 6 },
          ],
        },
      },
    ]);

    const response = PaginationUtils.createPaginationResponse(
      users,
      total,
      paginationOptions,
      {
        stats: {
          byRole: stats[0]?.byRole || [],
          byStatus: stats[0]?.byStatus || [],
          byVerification: stats[0]?.byVerification || [],
          growth: stats[0]?.growth || [],
        },
      }
    );

    res.json(response);
  } catch (error) {
    console.error("Admin users error:", error);
    res.status(500).json({ message: "Failed to fetch users" });
  }
});

// ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ŸÖÿ≥ÿ™ÿÆÿØŸÖ Ÿàÿßÿ≠ÿØ (ŸÑŸÑÿ£ÿØŸÖŸÜ)
router.get("/admin/users/:id", auth, role("admin"), async (req, res) => {
  try {
    const userId = req.params.id;
    
    const user = await User.findById(userId)
      .select("-password -verificationCode -resetPasswordToken")
      .populate("favorites", "name image")
      .lean();

    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    // ÿ¨ŸÑÿ® ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ•ÿ∂ÿßŸÅŸäÿ©
    const [orders, addresses, reviews] = await Promise.all([
      Order.find({ user: userId })
        .populate("restaurant", "name")
        .populate("driver", "name")
        .sort({ createdAt: -1 })
        .limit(10),
      
      Address.find({ user: userId }),
      
      Review.find({ user: userId })
        .populate("restaurant", "name image")
        .sort({ createdAt: -1 })
        .limit(10),
    ]);

    res.json({
      success: true,
      data: {
        user,
        orders,
        addresses,
        reviews,
        summary: {
          totalOrders: orders.length,
          totalAddresses: addresses.length,
          totalReviews: reviews.length,
        },
      },
    });
  } catch (error) {
    console.error("Admin user detail error:", error);
    res.status(500).json({ message: "Failed to fetch user details" });
  }
});

// ÿ™ÿ≠ÿØŸäÿ´ ŸÖÿ≥ÿ™ÿÆÿØŸÖ (ŸÑŸÑÿ£ÿØŸÖŸÜ)
router.put("/admin/users/:id", auth, role("admin"), async (req, res) => {
  try {
    const userId = req.params.id;
    const updateData = req.body;

    // ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑÿ≠ŸÇŸàŸÑ ÿßŸÑŸÖÿ≠ŸÖŸäÿ©
    delete updateData.password;
    delete updateData._id;
    delete updateData.createdAt;

    const user = await User.findByIdAndUpdate(
      userId,
      { $set: updateData },
      { new: true, runValidators: true }
    ).select("-password -verificationCode -resetPasswordToken");

    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    // ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑŸÜÿ¥ÿßÿ∑
    await user.logActivity("admin_updated", {
      updatedBy: req.user.id,
      updatedFields: Object.keys(updateData),
    }, req);

    res.json({
      success: true,
      message: "User updated successfully",
      data: user,
    });
  } catch (error) {
    console.error("Admin update user error:", error);
    res.status(500).json({ message: "Failed to update user" });
  }
});

// ÿ≠ÿ∞ŸÅ ŸÖÿ≥ÿ™ÿÆÿØŸÖ (ŸÑŸÑÿ£ÿØŸÖŸÜ)
router.delete("/admin/users/:id", auth, role("admin"), async (req, res) => {
  try {
    const userId = req.params.id;
    
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸáŸà ÿßŸÑÿ£ÿØŸÖŸÜ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿä
    const user = await User.findById(userId);
    
    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    // ŸÖŸÜÿπ ÿ≠ÿ∞ŸÅ ÿßŸÑÿ£ÿØŸÖŸÜ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿä
    if (user.role === "admin") {
      const adminCount = await User.countDocuments({ role: "admin" });
      if (adminCount <= 1) {
        return res.status(400).json({
          message: "Cannot delete the only admin user",
        });
      }
    }

    // Soft delete - ÿ™ÿπÿ∑ŸäŸÑ ÿßŸÑÿ≠ÿ≥ÿßÿ®
    user.isActive = false;
    await user.save();

    // ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑŸÜÿ¥ÿßÿ∑
    await user.logActivity("account_deactivated", {
      deactivatedBy: req.user.id,
      reason: req.body.reason || "Administrative action",
    }, req);

    res.json({
      success: true,
      message: "User account deactivated",
    });
  } catch (error) {
    console.error("Admin delete user error:", error);
    res.status(500).json({ message: "Failed to delete user" });
  }
});

module.exports = router;
</file>

<file path="src/services/chat.socket.service.js">
const socketService = require("./socket.service");

class ChatSocketService {
  constructor() {
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ£ŸÜ socketService ŸÖŸàÿ¨ŸàÿØ Ÿàÿ®Ÿá io
    if (!socketService || !socketService.io) {
      console.warn("‚ö†Ô∏è Socket.IO not initialized yet. Will retry later...");
      this.socketService = socketService;
      // ÿ™ÿ£ÿ¨ŸäŸÑ ÿ™ŸáŸäÿ¶ÿ© ÿßŸÑŸÄ event handlers ÿ≠ÿ™Ÿâ Ÿäÿ™ŸÖ ÿ™ŸáŸäÿ¶ÿ© Socket.IO
      this.setupChatEventHandlers = this.setupChatEventHandlers.bind(this);
      return;
    }
    
    this.socketService = socketService;
    this.setupChatEventHandlers();
  }

  /**
   * ÿ•ÿπÿØÿßÿØ ŸÖÿπÿßŸÑÿ¨ÿßÿ™ ÿ£ÿ≠ÿØÿßÿ´ ÿßŸÑÿØÿ±ÿØÿ¥ÿ©
   */
  setupChatEventHandlers() {
    const io = this.socketService?.io;
    
    if (!io) {
      console.error("‚ùå Socket.IO is not initialized!");
      return;
    }

    io.on("connection", (socket) => {
      console.log(`üí¨ Chat socket connected: ${socket.id}`);

      // ÿßŸÜÿ∂ŸÖÿßŸÖ ÿ•ŸÑŸâ ŸÖÿ≠ÿßÿØÿ´ÿ©
      socket.on("chat:join", (conversationId) => {
        socket.join(`chat:${conversationId}`);
        console.log(`üë• Socket ${socket.id} joined chat ${conversationId}`);
      });

      // ŸÖÿ∫ÿßÿØÿ±ÿ© ŸÖÿ≠ÿßÿØÿ´ÿ©
      socket.on("chat:leave", (conversationId) => {
        socket.leave(`chat:${conversationId}`);
        console.log(`üëã Socket ${socket.id} left chat ${conversationId}`);
      });

      // ÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ÿ≥ÿßŸÑÿ©
      socket.on("chat:message:send", async (data) => {
        try {
          const { conversationId, content, type = "text", replyTo = null } = data;
          
          console.log(`üì® New message in chat ${conversationId}`);
          
          // ÿ≠ŸÅÿ∏ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ŸÅŸä ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
          const Message = require("../models/message.model");
          const message = await Message.createTextMessage(
            conversationId,
            socket.userId,
            content,
            replyTo
          );

          // ÿ¨ŸÑÿ® ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ŸÖÿπ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ±ÿ≥ŸÑ
          const populatedMessage = await Message.findById(message._id)
            .populate("sender", "name image role")
            .populate("replyTo", "content.text sender type")
            .lean();

          // ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ŸÑÿ¨ŸÖŸäÿπ ÿßŸÑŸÖÿ¥ÿßÿ±ŸÉŸäŸÜ ŸÅŸä ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
          io.to(`chat:${conversationId}`).emit("chat:message:new", {
            conversationId,
            message: populatedMessage,
            timestamp: new Date(),
          });

          // ÿ•ÿ±ÿ≥ÿßŸÑ ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ push ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ÿ∫Ÿäÿ± ÿßŸÑŸÖÿ™ÿµŸÑŸäŸÜ
          await this.sendMessageNotifications(conversationId, populatedMessage);

        } catch (error) {
          console.error("‚ùå Send message error:", error.message);
          socket.emit("chat:message:error", {
            error: "Failed to send message",
            details: error.message,
          });
        }
      });

      // ÿ™ÿ≠ÿØŸäÿ´ ÿ≠ÿßŸÑÿ© ÿßŸÑŸÇÿ±ÿßÿ°ÿ©
      socket.on("chat:message:read", async (data) => {
        try {
          const { conversationId, messageId } = data;
          
          const Message = require("../models/message.model");
          await Message.findByIdAndUpdate(messageId, {
            $push: {
              "delivery.readBy": {
                user: socket.userId,
                readAt: new Date(),
              },
            },
          });

          // ÿ•ÿπŸÑÿßŸÖ ÿßŸÑÿ¢ÿÆÿ±ŸäŸÜ ÿ®ÿ£ŸÜ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿ™ŸÖÿ™ ŸÇÿ±ÿßÿ°ÿ™Ÿáÿß
          socket.to(`chat:${conversationId}`).emit("chat:message:read", {
            conversationId,
            messageId,
            readBy: socket.userId,
            timestamp: new Date(),
          });

        } catch (error) {
          console.error("‚ùå Mark as read error:", error.message);
        }
      });

      // ÿ™ÿ≠ÿØŸäÿ´ ÿ≠ÿßŸÑÿ© ÿßŸÑŸÉÿ™ÿßÿ®ÿ© (Typing indicator)
      socket.on("chat:typing", (data) => {
        const { conversationId, isTyping } = data;
        
        socket.to(`chat:${conversationId}`).emit("chat:typing", {
          conversationId,
          userId: socket.userId,
          isTyping,
          timestamp: new Date(),
        });
      });

      // ÿ±ÿØŸàÿØ ÿßŸÑŸÅÿπŸÑ ÿπŸÑŸâ ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ
      socket.on("chat:message:react", async (data) => {
        try {
          const { conversationId, messageId, emoji } = data;
          
          const Message = require("../models/message.model");
          const message = await Message.findById(messageId);
          
          if (message) {
            await message.addReaction(socket.userId, emoji);
            
            // ÿ•ÿ±ÿ≥ÿßŸÑ ÿ™ÿ≠ÿØŸäÿ´ ÿ±ÿØ ÿßŸÑŸÅÿπŸÑ
            io.to(`chat:${conversationId}`).emit("chat:message:reaction", {
              conversationId,
              messageId,
              userId: socket.userId,
              emoji,
              timestamp: new Date(),
            });
          }
        } catch (error) {
          console.error("‚ùå Reaction error:", error.message);
        }
      });

      // ÿ≠ÿ∞ŸÅ ÿ±ÿ≥ÿßŸÑÿ©
      socket.on("chat:message:delete", async (data) => {
        try {
          const { conversationId, messageId } = data;
          
          const Message = require("../models/message.model");
          await Message.findByIdAndUpdate(messageId, {
            "deleted.isDeleted": true,
            "deleted.deletedAt": new Date(),
            "deleted.deletedBy": socket.userId,
          });

          // ÿ•ÿπŸÑÿßŸÖ ÿßŸÑÿ¢ÿÆÿ±ŸäŸÜ ÿ®ÿ≠ÿ∞ŸÅ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©
          io.to(`chat:${conversationId}`).emit("chat:message:deleted", {
            conversationId,
            messageId,
            deletedBy: socket.userId,
            timestamp: new Date(),
          });

        } catch (error) {
          console.error("‚ùå Delete message error:", error.message);
        }
      });

      // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©
      socket.on("chat:message:edit", async (data) => {
        try {
          const { conversationId, messageId, newContent } = data;
          
          const Message = require("../models/message.model");
          const message = await Message.findById(messageId);
          
          if (message && message.sender.toString() === socket.userId) {
            await message.edit({ text: newContent });
            
            // ÿ•ÿ±ÿ≥ÿßŸÑ ÿ™ÿ≠ÿØŸäÿ´ ÿ™ÿπÿØŸäŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©
            io.to(`chat:${conversationId}`).emit("chat:message:edited", {
              conversationId,
              messageId,
              newContent,
              editedBy: socket.userId,
              timestamp: new Date(),
            });
          }
        } catch (error) {
          console.error("‚ùå Edit message error:", error.message);
        }
      });

      // ÿ™ÿ≠ÿØŸäÿ´ ÿ≠ÿßŸÑÿ© ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
      socket.on("chat:presence", (data) => {
        const { conversationId, isOnline } = data;
        
        socket.to(`chat:${conversationId}`).emit("chat:presence", {
          conversationId,
          userId: socket.userId,
          isOnline,
          timestamp: new Date(),
        });
      });

      // ÿ≠ÿØÿ´ ÿßŸÑÿßŸÜŸÅÿµÿßŸÑ
      socket.on("disconnect", () => {
        console.log(`üí¨ Chat socket disconnected: ${socket.id}`);
      });
    });
  }

  /**
   * ÿ™ŸáŸäÿ¶ÿ© ÿßŸÑŸÄ Socket.IO ŸÑÿßÿ≠ŸÇÿßŸã (ÿπŸÜÿØŸÖÿß ŸäŸÉŸàŸÜ ÿ¨ÿßŸáÿ≤ÿßŸã)
   */
  initializeWithIO(io) {
    if (!this.socketService) {
      this.socketService = { io };
    } else {
      this.socketService.io = io;
    }
    
    // ÿ•ÿπÿØÿßÿØ event handlers ÿßŸÑÿ¢ŸÜ ÿ®ÿπÿØ ÿ£ŸÜ ÿ£ÿµÿ®ÿ≠ io ŸÖÿ™ÿßÿ≠ÿßŸã
    this.setupChatEventHandlers();
    console.log("‚úÖ ChatSocketService initialized with Socket.IO");
  }

  /**
   * ÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ÿ≥ÿßŸÑÿ© ÿ¨ÿØŸäÿØÿ©
   */
  async sendMessage(conversationId, messageData) {
    try {
      const io = this.socketService?.io;
      
      if (!io) {
        console.warn("‚ö†Ô∏è Socket.IO not available for sending message");
        return false;
      }
      
      // ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ŸÑÿ¨ŸÖŸäÿπ ÿßŸÑŸÖÿ¥ÿßÿ±ŸÉŸäŸÜ ŸÅŸä ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
      io.to(`chat:${conversationId}`).emit("chat:message:new", {
        conversationId,
        message: messageData,
        timestamp: new Date(),
      });

      return true;
    } catch (error) {
      console.error("‚ùå Send message via socket error:", error.message);
      return false;
    }
  }

  /**
   * ÿ•ÿ±ÿ≥ÿßŸÑ ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ
   */
  async sendMessageNotifications(conversationId, message) {
    try {
      const Conversation = require("../models/conversation.model");
      const notificationService = require("./notification.service");
      
      const conversation = await Conversation.findById(conversationId)
        .populate("participants", "name preferences");
      
      if (!conversation) return;

      // ÿ•ÿ±ÿ≥ÿßŸÑ ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ÿ∫Ÿäÿ± ÿßŸÑŸÖÿ™ÿµŸÑŸäŸÜ
      for (const participant of conversation.participants) {
        if (participant._id.toString() === message.sender._id.toString()) {
          continue; // ÿ™ÿÆÿ∑Ÿä ÿßŸÑŸÖÿ±ÿ≥ŸÑ
        }

        // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÖÿ™ÿµŸÑÿßŸã
        const isConnected = this.socketService?.isUserConnected?.(participant._id.toString());
        
        if (!isConnected && participant.preferences?.notifications?.push) {
          await notificationService.sendNotification({
            user: participant._id,
            type: "new_message",
            title: `ÿ±ÿ≥ÿßŸÑÿ© ÿ¨ÿØŸäÿØÿ© ŸÖŸÜ ${message.sender.name}`,
            content: message.content.text?.substring(0, 100) || "üìé ŸÖÿ±ŸÅŸÇ",
            data: {
              conversationId,
              messageId: message._id,
              senderId: message.sender._id,
              senderName: message.sender.name,
            },
            priority: "medium",
            link: `/chat/${conversationId}`,
            icon: "üí¨",
            tags: ["chat", "message", `conversation_${conversationId}`],
          });
        }
      }
    } catch (error) {
      console.error("‚ùå Send message notifications error:", error.message);
    }
  }

  /**
   * ÿ™ÿ≠ÿØŸäÿ´ ÿ≠ÿßŸÑÿ© ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
   */
  updateConversationStatus(conversationId, statusData) {
    const io = this.socketService?.io;
    
    if (!io) return;
    
    io.to(`chat:${conversationId}`).emit("chat:status", {
      conversationId,
      ...statusData,
      timestamp: new Date(),
    });
  }

  /**
   * ÿ•ÿ∂ÿßŸÅÿ© ŸÖÿ¥ÿßÿ±ŸÉ ÿ¨ÿØŸäÿØ ŸÑŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
   */
  addParticipantToChat(conversationId, userId) {
    const io = this.socketService?.io;
    
    if (!io) return;
    
    // ÿ•ÿπŸÑÿßŸÖ ÿßŸÑŸÖÿ¥ÿßÿ±ŸÉŸäŸÜ ÿ®ÿ•ÿ∂ÿßŸÅÿ© ÿπÿ∂Ÿà ÿ¨ÿØŸäÿØ
    io.to(`chat:${conversationId}`).emit("chat:participant:added", {
      conversationId,
      userId,
      timestamp: new Date(),
    });

    // ÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ÿ≥ÿßŸÑÿ© ÿ™ÿ±ÿ≠Ÿäÿ® ŸÑŸÑŸÜÿ∏ÿßŸÖ
    io.to(`chat:${conversationId}`).emit("chat:message:new", {
      conversationId,
      message: {
        type: "system",
        content: {
          text: `ÿßŸÜÿ∂ŸÖ ${userId} ÿ•ŸÑŸâ ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©`,
        },
        sender: null,
        delivery: {
          sentAt: new Date(),
        },
      },
      timestamp: new Date(),
    });
  }

  /**
   * ÿ•ÿ≤ÿßŸÑÿ© ŸÖÿ¥ÿßÿ±ŸÉ ŸÖŸÜ ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
   */
  removeParticipantFromChat(conversationId, userId) {
    const io = this.socketService?.io;
    
    if (!io) return;
    
    // ÿ•ÿπŸÑÿßŸÖ ÿßŸÑŸÖÿ¥ÿßÿ±ŸÉŸäŸÜ ÿ®ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑÿπÿ∂Ÿà
    io.to(`chat:${conversationId}`).emit("chat:participant:removed", {
      conversationId,
      userId,
      timestamp: new Date(),
    });

    // ÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ÿ≥ÿßŸÑÿ© ŸàÿØÿßÿπ ŸÑŸÑŸÜÿ∏ÿßŸÖ
    io.to(`chat:${conversationId}`).emit("chat:message:new", {
      conversationId,
      message: {
        type: "system",
        content: {
          text: `ÿ∫ÿßÿØÿ± ${userId} ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©`,
        },
        sender: null,
        delivery: {
          sentAt: new Date(),
        },
      },
      timestamp: new Date(),
    });
  }

  /**
   * ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ£ŸÜ ÿßŸÑÿÆÿØŸÖÿ© ŸÖŸáŸäÿ£ÿ©
   */
  isInitialized() {
    return !!(this.socketService?.io);
  }
}

module.exports = new ChatSocketService();
</file>

<file path="src/services/email.service.js">
const crypto = require('crypto');

class EmailService {
  constructor() {
    this.config = {
      enabled: process.env.EMAIL_ENABLED === 'true',
      service: process.env.EMAIL_SERVICE || 'gmail',
      from: process.env.EMAIL_FROM || 'noreply@fooddelivery.com',
      appName: process.env.APP_NAME || 'Food Delivery'
    };
    
    console.log(`üìß Email service initialized - Enabled: ${this.config.enabled}`);
  }

  async sendEmail(to, subject, html, text = '') {
    try {
      if (!to || !subject) {
        throw new Error('Email and subject are required');
      }

      if (!this.config.enabled) {
        console.log(`üìß [SIMULATED] Email to ${to}: ${subject}`);
        return {
          success: true,
          simulated: true,
          messageId: `simulated-${crypto.randomBytes(8).toString('hex')}`,
          to,
          subject
        };
      }

      // TODO: ÿ•ÿ∂ÿßŸÅÿ© ÿ™ŸÉÿßŸÖŸÑ ŸÖÿπ ÿÆÿØŸÖÿ© ÿ®ÿ±ŸäÿØ ÿ≠ŸÇŸäŸÇŸäÿ©
      // ŸÖÿ´ÿßŸÑ ŸÖÿπ Nodemailer (Ÿäÿ≠ÿ™ÿßÿ¨ ÿ™ÿ´ÿ®Ÿäÿ™ nodemailer):
      /*
      const transporter = nodemailer.createTransport({
        service: this.config.service,
        auth: {
          user: process.env.EMAIL_USER,
          pass: process.env.EMAIL_PASS
        }
      });
      
      const mailOptions = {
        from: this.config.from,
        to,
        subject,
        html,
        text: text || this.htmlToText(html)
      };
      
      const info = await transporter.sendMail(mailOptions);
      */
      
      // Simulation ŸÑŸÑÿ™ŸÜŸÖŸäÿ©
      console.log(`üìß Email sent to ${to}: ${subject}`);
      console.log(`üìß HTML Preview (first 100 chars): ${html.substring(0, 100)}...`);
      
      return {
        success: true,
        messageId: `sent-${Date.now()}-${crypto.randomBytes(4).toString('hex')}`,
        to,
        subject,
        timestamp: new Date()
      };
    } catch (error) {
      console.error('‚ùå Email sending error:', error.message);
      return {
        success: false,
        error: error.message,
        to,
        subject,
        timestamp: new Date()
      };
    }
  }

  htmlToText(html) {
    return html
      .replace(/<[^>]*>/g, ' ')
      .replace(/\s+/g, ' ')
      .trim();
  }

  async sendWelcomeEmail(user) {
    const subject = `ŸÖÿ±ÿ≠ÿ®ÿßŸã ÿ®ŸÉ ŸÅŸä ${this.config.appName}, ${user.name}!`;
    const html = `
      <!DOCTYPE html>
      <html dir="rtl" lang="ar">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>${subject}</title>
        <style>
          body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.6; color: #333; }
          .container { max-width: 600px; margin: 0 auto; padding: 20px; }
          .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0; }
          .content { background: #f9f9f9; padding: 30px; border-radius: 0 0 10px 10px; }
          .welcome-text { font-size: 18px; margin-bottom: 20px; }
          .features { margin: 20px 0; }
          .feature-item { background: white; padding: 15px; margin: 10px 0; border-radius: 5px; border-right: 4px solid #667eea; }
          .footer { text-align: center; margin-top: 30px; padding-top: 20px; border-top: 1px solid #ddd; color: #666; }
          .btn { display: inline-block; background: #667eea; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; margin: 10px 0; }
        </style>
      </head>
      <body>
        <div class="container">
          <div class="header">
            <h1>ŸÖÿ±ÿ≠ÿ®ÿßŸã ${user.name}! üëã</h1>
            <p>ŸÜÿ≠ŸÜ ÿ≥ÿπÿØÿßÿ° ÿ®ÿßŸÜÿ∂ŸÖÿßŸÖŸÉ ÿ•ŸÑŸâ ${this.config.appName}</p>
          </div>
          <div class="content">
            <div class="welcome-text">
              <p>ÿ¥ŸÉÿ±ÿßŸã ŸÑÿ´ŸÇÿ™ŸÉ ÿ®ŸÜÿß. ÿ£ŸÜÿ™ ÿßŸÑÿ¢ŸÜ ÿ¨ÿ≤ÿ° ŸÖŸÜ ŸÖÿ¨ÿ™ŸÖÿπ ${this.config.appName}!</p>
            </div>
            
            <div class="features">
              <h3>üéâ ŸäŸÖŸÉŸÜŸÉ ÿßŸÑÿ¢ŸÜ:</h3>
              <div class="feature-item">
                <strong>üçΩÔ∏è ÿßÿ≥ÿ™ÿπÿ±ÿßÿ∂ ÿßŸÑŸÖÿ∑ÿßÿπŸÖ</strong>
                <p>ÿßŸÉÿ™ÿ¥ŸÅ ÿ£ŸÅÿ∂ŸÑ ÿßŸÑŸÖÿ∑ÿßÿπŸÖ ŸÅŸä ŸÖÿØŸäŸÜÿ™ŸÉ</p>
              </div>
              <div class="feature-item">
                <strong>üöÄ ÿ∑ŸÑÿ® ÿ≥ÿ±Ÿäÿπ</strong>
                <p>ÿßÿ∑ŸÑÿ® Ÿàÿ¨ÿ®ÿ™ŸÉ ÿßŸÑŸÖŸÅÿ∂ŸÑÿ© ŸÅŸä ÿØŸÇÿßÿ¶ŸÇ</p>
              </div>
              <div class="feature-item">
                <strong>üìç ÿ™ÿ™ÿ®ÿπ ÿ≠Ÿä</strong>
                <p>ÿ™ÿ™ÿ®ÿπ ÿ∑ŸÑÿ®ÿßÿ™ŸÉ ŸÅŸä ÿßŸÑŸàŸÇÿ™ ÿßŸÑÿ≠ŸÇŸäŸÇŸä</p>
              </div>
              <div class="feature-item">
                <strong>‚≠ê ÿ™ŸÇŸäŸäŸÖÿßÿ™</strong>
                <p>ÿ¥ÿßÿ±ŸÉ ÿ™ÿ¨ÿ±ÿ®ÿ™ŸÉ ŸÖÿπ ÿßŸÑÿ¢ÿÆÿ±ŸäŸÜ</p>
              </div>
            </div>
            
            <div style="text-align: center; margin: 30px 0;">
              <a href="${process.env.CLIENT_URL || 'https://fooddelivery.com'}/dashboard" class="btn">
                ÿßÿ®ÿØÿ£ ÿßŸÑÿ™ÿ≥ŸàŸÇ ÿßŸÑÿ¢ŸÜ üõí
              </a>
            </div>
            
            <div class="footer">
              <p>ÿ•ÿ∞ÿß ŸÉÿßŸÜ ŸÑÿØŸäŸÉ ÿ£Ÿä ÿßÿ≥ÿ™ŸÅÿ≥ÿßÿ±ÿå ŸÑÿß ÿ™ÿ™ÿ±ÿØÿØ ŸÅŸä ÿßŸÑÿ™ŸàÿßÿµŸÑ ŸÖÿπŸÜÿß ÿπÿ®ÿ±:</p>
              <p>üìß support@fooddelivery.com | üìû 1234567890</p>
              <p style="margin-top: 20px; font-size: 14px;">
                ŸÖÿπ ÿ™ÿ≠Ÿäÿßÿ™ÿå<br>
                ŸÅÿ±ŸäŸÇ <strong>${this.config.appName}</strong>
              </p>
            </div>
          </div>
        </div>
      </body>
      </html>
    `;

    return this.sendEmail(user.email, subject, html);
  }

  async sendVerificationEmail(user, verificationCode) {
    const subject = `ŸÉŸàÿØ ÿßŸÑÿ™ÿ≠ŸÇŸÇ - ${this.config.appName}`;
    const html = `
      <!DOCTYPE html>
      <html dir="rtl" lang="ar">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>${subject}</title>
        <style>
          body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.6; color: #333; }
          .container { max-width: 600px; margin: 0 auto; padding: 20px; }
          .header { background: linear-gradient(135deg, #4CAF50 0%, #2E7D32 100%); color: white; padding: 20px; text-align: center; border-radius: 10px 10px 0 0; }
          .content { background: #f9f9f9; padding: 30px; border-radius: 0 0 10px 10px; }
          .code-container { background: white; padding: 30px; margin: 20px 0; text-align: center; border-radius: 10px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
          .verification-code { font-size: 42px; font-weight: bold; letter-spacing: 10px; color: #2E7D32; margin: 20px 0; }
          .instructions { margin: 20px 0; padding: 15px; background: #E8F5E9; border-radius: 5px; border-right: 4px solid #4CAF50; }
          .footer { text-align: center; margin-top: 30px; padding-top: 20px; border-top: 1px solid #ddd; color: #666; }
          .warning { color: #D32F2F; background: #FFEBEE; padding: 10px; border-radius: 5px; margin: 10px 0; }
        </style>
      </head>
      <body>
        <div class="container">
          <div class="header">
            <h2>üîê ŸÉŸàÿØ ÿßŸÑÿ™ÿ≠ŸÇŸÇ</h2>
          </div>
          <div class="content">
            <p>ŸÖÿ±ÿ≠ÿ®ÿßŸã ${user.name},</p>
            <p>ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑŸÉŸàÿØ ÿßŸÑÿ™ÿßŸÑŸä ŸÑÿ™ŸÅÿπŸäŸÑ ÿ≠ÿ≥ÿßÿ®ŸÉ ŸÅŸä ${this.config.appName}:</p>
            
            <div class="code-container">
              <p style="color: #666; margin-bottom: 10px;">ÿßŸÑŸÉŸàÿØ ÿßŸÑÿµÿßŸÑÿ≠ ŸÑŸÖÿØÿ© 24 ÿ≥ÿßÿπÿ©:</p>
              <div class="verification-code">${verificationCode}</div>
              <p style="color: #999; font-size: 14px; margin-top: 10px;">ÿ£ÿØÿÆŸÑ Ÿáÿ∞ÿß ÿßŸÑŸÉŸàÿØ ŸÅŸä ÿµŸÅÿ≠ÿ© ÿ™ŸÅÿπŸäŸÑ ÿßŸÑÿ≠ÿ≥ÿßÿ®</p>
            </div>
            
            <div class="instructions">
              <h4>üìù ÿ™ÿπŸÑŸäŸÖÿßÿ™:</h4>
              <ol style="padding-right: 20px;">
                <li>ÿßŸÜÿ™ŸÇŸÑ ÿ•ŸÑŸâ ÿµŸÅÿ≠ÿ© ÿ™ŸÅÿπŸäŸÑ ÿßŸÑÿ≠ÿ≥ÿßÿ®</li>
                <li>ÿ£ÿØÿÆŸÑ ŸÉŸàÿØ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ÿ£ÿπŸÑÿßŸá</li>
                <li>ÿßŸÜŸÇÿ± ÿπŸÑŸâ ÿ≤ÿ± "ÿ™ŸÅÿπŸäŸÑ ÿßŸÑÿ≠ÿ≥ÿßÿ®"</li>
                <li>ÿ≥ÿ™ÿ™ŸÖ ÿ•ÿπÿßÿØÿ© ÿ™Ÿàÿ¨ŸäŸáŸÉ ÿ•ŸÑŸâ ŸÑŸàÿ≠ÿ© ÿßŸÑÿ™ÿ≠ŸÉŸÖ</li>
              </ol>
            </div>
            
            <div class="warning">
              ‚ö†Ô∏è <strong>ŸáÿßŸÖ:</strong> ŸÑÿß ÿ™ÿ¥ÿßÿ±ŸÉ Ÿáÿ∞ÿß ÿßŸÑŸÉŸàÿØ ŸÖÿπ ÿ£Ÿä ÿ¥ÿÆÿµ. ŸÅÿ±ŸäŸÇ ${this.config.appName} ŸÑŸÜ Ÿäÿ∑ŸÑÿ® ŸÖŸÜŸÉ ŸÉŸàÿØ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ÿ£ÿ®ÿØÿßŸã.
            </div>
            
            <div class="footer">
              <p>ÿ•ÿ∞ÿß ŸÑŸÖ ÿ™ÿ∑ŸÑÿ® Ÿáÿ∞ÿß ÿßŸÑŸÉŸàÿØÿå ŸäŸÖŸÉŸÜŸÉ ÿ™ÿ¨ÿßŸáŸÑ Ÿáÿ∞ÿß ÿßŸÑÿ®ÿ±ŸäÿØ.</p>
              <p style="margin-top: 20px; font-size: 14px;">
                ŸÖÿπ ÿ™ÿ≠Ÿäÿßÿ™ÿå<br>
                ŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ŸÖŸÜ ŸÅŸä <strong>${this.config.appName}</strong>
              </p>
            </div>
          </div>
        </div>
      </body>
      </html>
    `;

    return this.sendEmail(user.email, subject, html);
  }

async sendNotificationEmail(user, notification) {
  try {
    const icon = notification.icon || 'üîî';
    const subject = `${icon} ${notification.title}`;
    
    const html = `
      <!DOCTYPE html>
      <html dir="rtl" lang="ar">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>${subject}</title>
        <style>
          body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.6; color: #333; }
          .container { max-width: 600px; margin: 0 auto; padding: 20px; }
          .notification-header { background: linear-gradient(135deg, #FF9800 0%, #F57C00 100%); color: white; padding: 25px; text-align: center; border-radius: 10px 10px 0 0; }
          .content { background: #f9f9f9; padding: 30px; border-radius: 0 0 10px 10px; }
          .notification-icon { font-size: 48px; margin-bottom: 15px; }
          .notification-content { background: white; padding: 25px; margin: 20px 0; border-radius: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
          .btn-container { text-align: center; margin: 30px 0; }
          .btn { display: inline-block; background: #FF9800; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; font-weight: bold; }
          .footer { text-align: center; margin-top: 30px; padding-top: 20px; border-top: 1px solid #ddd; color: #666; }
          .metadata { background: #F5F5F5; padding: 15px; border-radius: 5px; margin: 15px 0; font-size: 14px; color: #666; }
        </style>
      </head>
      <body>
        <div class="container">
          <div class="notification-header">
            <div class="notification-icon">${icon}</div>
            <h2>${notification.title}</h2>
          </div>
          <div class="content">
            <div class="notification-content">
              <p style="font-size: 16px; line-height: 1.8;">${notification.content}</p>
            </div>
            
            ${notification.data ? `
            <div class="metadata">
              <h4>üìã ÿ™ŸÅÿßÿµŸäŸÑ ÿ•ÿ∂ÿßŸÅŸäÿ©:</h4>
              <pre style="background: white; padding: 15px; border-radius: 5px; overflow-x: auto;">${JSON.stringify(notification.data, null, 2)}</pre>
            </div>
            ` : ''}
            
            ${notification.link ? `
            <div class="btn-container">
              <a href="${notification.link}" class="btn">
                ÿπÿ±ÿ∂ ÿßŸÑÿ™ŸÅÿßÿµŸäŸÑ ‚Üí
              </a>
            </div>
            ` : ''}
            
            <div class="footer">
              <p>Ÿáÿ∞ÿß ÿ•ÿ¥ÿπÿßÿ± ÿ™ŸÑŸÇÿßÿ¶Ÿä ŸÖŸÜ ${this.config.appName}</p>
              <p style="margin-top: 10px; font-size: 14px;">
                ŸÑÿ™ÿπÿØŸäŸÑ ÿ™ŸÅÿ∂ŸäŸÑÿßÿ™ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ÿå ŸÇŸÖ ÿ®ÿ≤Ÿäÿßÿ±ÿ© <a href="${process.env.CLIENT_URL || 'https://fooddelivery.com'}/settings/notifications">ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™</a>
              </p>
              <p style="margin-top: 20px; font-size: 12px; color: #999;">
                ${new Date().toLocaleString('ar-SA')}
              </p>
            </div>
          </div>
        </div>
      </body>
      </html>
    `;

    const text = this.htmlToText(html);
    
    // ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ®ÿ±ŸäÿØ ÿßŸÑÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜŸä
    const result = await this.sendEmail(user.email, subject, html, text);
    
    return result;
  } catch (error) {
    console.error('‚ùå Send notification email error:', error.message);
    throw error;
  }
}
  async sendPasswordResetEmail(user, resetToken) {
    const resetLink = `${process.env.CLIENT_URL || 'https://fooddelivery.com'}/reset-password?token=${resetToken}&email=${encodeURIComponent(user.email)}`;
    const subject = `ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± - ${this.config.appName}`;
    
    const html = `
      <!DOCTYPE html>
      <html dir="rtl" lang="ar">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>${subject}</title>
        <style>
          body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.6; color: #333; }
          .container { max-width: 600px; margin: 0 auto; padding: 20px; }
          .header { background: linear-gradient(135deg, #D32F2F 0%, #B71C1C 100%); color: white; padding: 25px; text-align: center; border-radius: 10px 10px 0 0; }
          .content { background: #f9f9f9; padding: 30px; border-radius: 0 0 10px 10px; }
          .warning-box { background: #FFF3E0; border-right: 4px solid #FF9800; padding: 20px; margin: 20px 0; border-radius: 5px; }
          .btn-container { text-align: center; margin: 30px 0; }
          .btn { display: inline-block; background: #D32F2F; color: white; padding: 14px 35px; text-decoration: none; border-radius: 5px; font-weight: bold; font-size: 16px; }
          .token-info { background: white; padding: 20px; margin: 20px 0; border-radius: 10px; text-align: center; border: 2px dashed #D32F2F; }
          .token { font-family: monospace; font-size: 18px; color: #D32F2F; padding: 10px; background: #FFEBEE; border-radius: 5px; }
          .footer { text-align: center; margin-top: 30px; padding-top: 20px; border-top: 1px solid #ddd; color: #666; }
          .urgent { color: #D32F2F; font-weight: bold; }
        </style>
      </head>
      <body>
        <div class="container">
          <div class="header">
            <h2>üîê ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±</h2>
            <p>ÿ∑ŸÑÿ® ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ ŸÉŸÑŸÖÿ© ŸÖÿ±Ÿàÿ± ÿ≠ÿ≥ÿßÿ®ŸÉ</p>
          </div>
          <div class="content">
            <p>ŸÖÿ±ÿ≠ÿ®ÿßŸã ${user.name},</p>
            <p>ÿ™ŸÑŸÇŸäŸÜÿß ÿ∑ŸÑÿ®ÿßŸã ŸÑÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ ŸÉŸÑŸÖÿ© ŸÖÿ±Ÿàÿ± ÿ≠ÿ≥ÿßÿ®ŸÉ ŸÅŸä ${this.config.appName}.</p>
            
            <div class="warning-box">
              <h4>‚ö†Ô∏è ÿ•ÿ∞ÿß ŸÑŸÖ ÿ™ÿ∑ŸÑÿ® ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±:</h4>
              <p>ŸäŸÖŸÉŸÜŸÉ ÿ™ÿ¨ÿßŸáŸÑ Ÿáÿ∞ÿß ÿßŸÑÿ®ÿ±ŸäÿØ ÿ®ÿ£ŸÖÿßŸÜ. ŸÉŸÑŸÖÿ© ŸÖÿ±Ÿàÿ±ŸÉ ŸÑŸÜ ÿ™ÿ™ÿ∫Ÿäÿ± ŸÖÿß ŸÑŸÖ ÿ™ŸÜŸÇÿ± ÿπŸÑŸâ ÿßŸÑÿ±ÿßÿ®ÿ∑ ÿ£ÿØŸÜÿßŸá Ÿàÿ™ŸÇŸàŸÖ ÿ®ÿ™ÿπŸäŸäŸÜ ŸÉŸÑŸÖÿ© ŸÖÿ±Ÿàÿ± ÿ¨ÿØŸäÿØÿ©.</p>
            </div>
            
            <div class="btn-container">
              <a href="${resetLink}" class="btn">
                ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ÿßŸÑÿ¢ŸÜ
              </a>
            </div>
            
            <p style="text-align: center; color: #666; margin: 20px 0;">
              ÿ£Ÿà ÿßŸÜÿ≥ÿÆ ÿßŸÑÿ±ÿßÿ®ÿ∑ ÿßŸÑÿ™ÿßŸÑŸä:<br>
              <small>${resetLink}</small>
            </p>
            
            <div class="token-info">
              <p><strong>ÿßŸÑÿ±ŸÇŸÖ ÿßŸÑÿ≥ÿ±Ÿä (Token):</strong></p>
              <div class="token">${resetToken}</div>
              <p style="margin-top: 10px; font-size: 14px; color: #666;">
                ÿµÿßŸÑÿ≠ ŸÑŸÖÿØÿ©: <span class="urgent">10 ÿØŸÇÿßÿ¶ŸÇ ŸÅŸÇÿ∑</span>
              </p>
            </div>
            
            <div class="footer">
              <p class="urgent">üîí ŸÑÿ£ÿ≥ÿ®ÿßÿ® ÿ£ŸÖŸÜŸäÿ©ÿå Ÿáÿ∞ÿß ÿßŸÑÿ±ÿßÿ®ÿ∑ ÿ≥ŸäŸÜÿ™ŸáŸä ÿÆŸÑÿßŸÑ 10 ÿØŸÇÿßÿ¶ŸÇ.</p>
              <p style="margin-top: 20px; font-size: 14px;">
                ŸÖÿπ ÿ™ÿ≠Ÿäÿßÿ™ÿå<br>
                ŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ŸÖŸÜ ŸÅŸä <strong>${this.config.appName}</strong>
              </p>
              <p style="font-size: 12px; color: #999; margin-top: 10px;">
                ${new Date().toLocaleString('ar-SA')}
              </p>
            </div>
          </div>
        </div>
      </body>
      </html>
    `;

    return this.sendEmail(user.email, subject, html);
  }

  async sendOrderStatusEmail(user, order, status) {
    const statusIcons = {
      pending: '‚è≥',
      accepted: '‚úÖ',
      picked: 'üì¶',
      delivered: 'üöö',
      cancelled: '‚ùå'
    };
    
    const statusTitles = {
      pending: 'ÿ∑ŸÑÿ® ŸÇŸäÿØ ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ±',
      accepted: 'ÿ™ŸÖ ŸÇÿ®ŸàŸÑ ÿßŸÑÿ∑ŸÑÿ®',
      picked: 'ÿ™ŸÖ ÿßÿ≥ÿ™ŸÑÿßŸÖ ÿßŸÑÿ∑ŸÑÿ®',
      delivered: 'ÿ™ŸÖ ÿßŸÑÿ™ŸàÿµŸäŸÑ',
      cancelled: 'ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿßŸÑÿ∑ŸÑÿ®'
    };
    
    const icon = statusIcons[status] || 'üîî';
    const title = statusTitles[status] || 'ÿ™ÿ≠ÿØŸäÿ´ ÿπŸÑŸâ ÿ∑ŸÑÿ®ŸÉ';
    const subject = `${icon} ${title} - ÿßŸÑÿ∑ŸÑÿ® #${order._id.toString().slice(-6)}`;
    
    const orderLink = `${process.env.CLIENT_URL || 'https://fooddelivery.com'}/orders/${order._id}`;
    
    const html = `
      <!DOCTYPE html>
      <html dir="rtl" lang="ar">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>${subject}</title>
        <style>
          body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.6; color: #333; }
          .container { max-width: 600px; margin: 0 auto; padding: 20px; }
          .header { background: linear-gradient(135deg, #2196F3 0%, #0D47A1 100%); color: white; padding: 25px; text-align: center; border-radius: 10px 10px 0 0; }
          .order-status { font-size: 48px; margin-bottom: 10px; }
          .content { background: #f9f9f9; padding: 30px; border-radius: 0 0 10px 10px; }
          .order-info { background: white; padding: 25px; margin: 20px 0; border-radius: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
          .info-row { display: flex; justify-content: space-between; padding: 10px 0; border-bottom: 1px solid #eee; }
          .info-label { color: #666; }
          .info-value { font-weight: bold; }
          .items-list { margin: 20px 0; }
          .item { display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #f0f0f0; }
          .btn-container { text-align: center; margin: 30px 0; }
          .btn { display: inline-block; background: #2196F3; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; font-weight: bold; }
          .footer { text-align: center; margin-top: 30px; padding-top: 20px; border-top: 1px solid #ddd; color: #666; }
          .status-badge { display: inline-block; padding: 5px 15px; border-radius: 20px; font-weight: bold; margin: 10px 0; }
          .status-pending { background: #FFF3E0; color: #FF9800; }
          .status-accepted { background: #E8F5E9; color: #4CAF50; }
          .status-picked { background: #E3F2FD; color: #2196F3; }
          .status-delivered { background: #E8F5E9; color: #2E7D32; }
          .status-cancelled { background: #FFEBEE; color: #D32F2F; }
        </style>
      </head>
      <body>
        <div class="container">
          <div class="header">
            <div class="order-status">${icon}</div>
            <h2>${title}</h2>
            <p>ÿ™ÿ≠ÿØŸäÿ´ ÿπŸÑŸâ ÿ∑ŸÑÿ®ŸÉ #${order._id.toString().slice(-6)}</p>
          </div>
          <div class="content">
            <div class="order-info">
              <div class="info-row">
                <span class="info-label">ÿ±ŸÇŸÖ ÿßŸÑÿ∑ŸÑÿ®:</span>
                <span class="info-value">#${order._id.toString().slice(-6)}</span>
              </div>
              <div class="info-row">
                <span class="info-label">ÿßŸÑÿ≠ÿßŸÑÿ©:</span>
                <span class="info-value">
                  <span class="status-badge status-${status}">${title}</span>
                </span>
              </div>
              <div class="info-row">
                <span class="info-label">ÿ™ÿßÿ±ŸäÿÆ ÿßŸÑÿ∑ŸÑÿ®:</span>
                <span class="info-value">${new Date(order.createdAt).toLocaleString('ar-SA')}</span>
              </div>
              <div class="info-row">
                <span class="info-label">ÿßŸÑŸÖÿ¨ŸÖŸàÿπ:</span>
                <span class="info-value">${order.totalPrice.toFixed(2)} ÿØ.ŸÖ</span>
              </div>
              
              ${order.items && order.items.length > 0 ? `
              <div class="items-list">
                <h4>üõí ÿßŸÑÿπŸÜÿßÿµÿ±:</h4>
                ${order.items.map(item => `
                <div class="item">
                  <span>${item.name} √ó ${item.qty}</span>
                  <span>${(item.price * item.qty).toFixed(2)} ÿØ.ŸÖ</span>
                </div>
                `).join('')}
              </div>
              ` : ''}
            </div>
            
            <div class="btn-container">
              <a href="${orderLink}" class="btn">
                ÿπÿ±ÿ∂ ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑÿ∑ŸÑÿ® ‚Üí
              </a>
            </div>
            
            <div class="footer">
              <p>ÿ¥ŸÉÿ±ÿßŸã ŸÑÿßÿÆÿ™Ÿäÿßÿ±ŸÉ ${this.config.appName}</p>
              <p style="margin-top: 10px; font-size: 14px;">
                ŸÑŸÑÿßÿ≥ÿ™ŸÅÿ≥ÿßÿ±ÿßÿ™: support@fooddelivery.com | 1234567890
              </p>
              <p style="margin-top: 20px; font-size: 12px; color: #999;">
                ${new Date().toLocaleString('ar-SA')}
              </p>
            </div>
          </div>
        </div>
      </body>
      </html>
    `;

    return this.sendEmail(user.email, subject, html);
  }
}

module.exports = new EmailService();
</file>

<file path="src/services/healthCheck.service.js">
const mongoose = require('mongoose');
const cache = require('../utils/cache.util');

class HealthCheckService {
  async checkDatabase() {
    try {
      const state = mongoose.connection.readyState;
      const states = ['disconnected', 'connected', 'connecting', 'disconnecting'];
      
      return {
        status: state === 1 ? 'healthy' : 'unhealthy',
        message: `MongoDB is ${states[state]}`,
        connectionState: states[state],
        readyState: state
      };
    } catch (error) {
      return {
        status: 'unhealthy',
        message: error.message,
        error: error.stack
      };
    }
  }

  async checkCache() {
    try {
      const stats = cache.getStats();
      
      return {
        status: 'healthy',
        message: 'Cache is working',
        stats: {
          hits: stats.hits,
          misses: stats.misses,
          keys: stats.keys,
          hitRate: ((stats.hits / (stats.hits + stats.misses)) * 100).toFixed(2) + '%'
        }
      };
    } catch (error) {
      return {
        status: 'unhealthy',
        message: error.message
      };
    }
  }

  async checkDiskSpace() {
    try {
      const checkDiskSpace = require('check-disk-space').default;
      const diskSpace = await checkDiskSpace('/');
      
      const freeGB = (diskSpace.free / 1024 / 1024 / 1024).toFixed(2);
      const totalGB = (diskSpace.size / 1024 / 1024 / 1024).toFixed(2);
      const usagePercent = ((1 - diskSpace.free / diskSpace.size) * 100).toFixed(2);
      
      return {
        status: usagePercent > 90 ? 'warning' : 'healthy',
        message: `Disk space: ${freeGB}GB free of ${totalGB}GB`,
        free: freeGB + 'GB',
        total: totalGB + 'GB',
        usage: usagePercent + '%'
      };
    } catch (error) {
      return {
        status: 'unhealthy',
        message: 'Unable to check disk space'
      };
    }
  }

  async checkMemoryUsage() {
    try {
      const used = process.memoryUsage();
      const memoryUsage = {
        rss: `${Math.round(used.rss / 1024 / 1024)} MB`,
        heapTotal: `${Math.round(used.heapTotal / 1024 / 1024)} MB`,
        heapUsed: `${Math.round(used.heapUsed / 1024 / 1024)} MB`,
        external: `${Math.round(used.external / 1024 / 1024)} MB`,
      };

      const heapUsagePercent = (used.heapUsed / used.heapTotal * 100).toFixed(2);
      
      return {
        status: heapUsagePercent > 85 ? 'warning' : 'healthy',
        message: `Memory usage: ${heapUsagePercent}%`,
        details: memoryUsage,
        heapUsage: heapUsagePercent + '%'
      };
    } catch (error) {
      return {
        status: 'unhealthy',
        message: error.message
      };
    }
  }

  async checkServices() {
    try {
      // ŸäŸÖŸÉŸÜ ÿ•ÿ∂ÿßŸÅÿ© ŸÅÿ≠ÿµ ÿÆÿØŸÖÿßÿ™ ÿÆÿßÿ±ÿ¨Ÿäÿ© ŸáŸÜÿß
      return {
        status: 'healthy',
        message: 'All external services are operational',
        services: {
          // ŸäŸÖŸÉŸÜ ÿ•ÿ∂ÿßŸÅÿ© Cloudinaryÿå SendGridÿå ÿ•ŸÑÿÆ
        }
      };
    } catch (error) {
      return {
        status: 'unhealthy',
        message: error.message
      };
    }
  }

  async fullHealthCheck() {
    const checks = await Promise.allSettled([
      this.checkDatabase(),
      this.checkCache(),
      this.checkDiskSpace(),
      this.checkMemoryUsage(),
      this.checkServices()
    ]);

    const results = checks.map((check, index) => ({
      service: ['Database', 'Cache', 'Disk Space', 'Memory', 'External Services'][index],
      ...(check.status === 'fulfilled' ? check.value : {
        status: 'unhealthy',
        message: check.reason?.message || 'Check failed'
      })
    }));

    const allHealthy = results.every(r => r.status === 'healthy');
    const hasWarning = results.some(r => r.status === 'warning');

    return {
      status: allHealthy ? 'healthy' : hasWarning ? 'warning' : 'unhealthy',
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
      nodeVersion: process.version,
      environment: process.env.NODE_ENV || 'development',
      checks: results
    };
  }

  async quickHealthCheck() {
    const dbCheck = await this.checkDatabase();
    
    return {
      status: dbCheck.status === 'healthy' ? 'ok' : 'error',
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
      database: dbCheck.status
    };
  }
}

module.exports = new HealthCheckService();
</file>

<file path="src/services/notification.service.js">
const Notification = require("../models/notification.model");
const User = require("../models/user.model");
const socketService = require("./socket.service");
const emailService = require("./email.service");
const smsService = require("./sms.service");
const cache = require("../utils/cache.util");

class NotificationService {
  /**
   * ÿ•ÿ±ÿ≥ÿßŸÑ ÿ•ÿ¥ÿπÿßÿ± Ÿàÿßÿ≠ÿØ
   */
  async sendNotification(notificationData) {
    try {
      console.log(`üì® Sending notification to user ${notificationData.user}`);
      
      // ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ•ÿ¥ÿπÿßÿ± ŸÅŸä ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
      const notification = await Notification.create(notificationData);
      
      // ÿ¨ŸÑÿ® ÿ™ŸÅÿ∂ŸäŸÑÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
      const user = await User.findById(notificationData.user).select("preferences");
      
      if (!user) {
        console.error(`User ${notificationData.user} not found`);
        return notification;
      }
      
      // ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿ≠ÿ≥ÿ® ÿßŸÑÿ™ŸÅÿ∂ŸäŸÑÿßÿ™
      const deliveryPromises = [];
      
      // ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿØÿßÿÆŸÑ ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ
      if (notification.settings.inApp) {
        deliveryPromises.push(
          this.sendInAppNotification(notification, user)
        );
      }
      
      // ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ Push (ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÖÿ≥ŸÖŸàÿ≠ÿßŸã)
      if (notification.settings.push && user.preferences?.notifications?.push) {
        deliveryPromises.push(
          this.sendPushNotification(notification, user)
        );
      }
      
      // ÿ•ÿ±ÿ≥ÿßŸÑ Email (ÿ•ÿ∞ÿß ŸÉÿßŸÜ ŸÖÿ≥ŸÖŸàÿ≠ÿßŸã)
      if (notification.settings.email && user.preferences?.notifications?.email) {
        deliveryPromises.push(
          this.sendEmailNotification(notification, user)
        );
      }
      
      // ÿ•ÿ±ÿ≥ÿßŸÑ SMS (ÿ•ÿ∞ÿß ŸÉÿßŸÜ ŸÖÿ≥ŸÖŸàÿ≠ÿßŸã)
      if (notification.settings.sms && user.preferences?.notifications?.sms) {
        deliveryPromises.push(
          this.sendSmsNotification(notification, user)
        );
      }
      
      // ÿ™ŸÜŸÅŸäÿ∞ ÿ¨ŸÖŸäÿπ ÿπŸÖŸÑŸäÿßÿ™ ÿßŸÑÿ•ÿ±ÿ≥ÿßŸÑ ÿ®ÿßŸÑÿ™Ÿàÿßÿ≤Ÿä
      await Promise.allSettled(deliveryPromises);
      
      // ÿ•ÿ®ÿ∑ÿßŸÑ ÿßŸÑŸÉÿßÿ¥
      this.invalidateCache(notification.user);
      
      console.log(`‚úÖ Notification sent: ${notification._id}`);
      return notification;
      
    } catch (error) {
      console.error("‚ùå Notification sending error:", error.message);
      throw error;
    }
  }

  /**
   * ÿ•ÿ±ÿ≥ÿßŸÑ ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ŸÖÿ¨ŸÖÿπÿ©
   */
  async sendBulkNotifications(notificationsData) {
    try {
      console.log(`üì® Sending ${notificationsData.length} notifications in bulk`);
      
      const results = await Promise.allSettled(
        notificationsData.map(data => this.sendNotification(data))
      );
      
      const successful = results.filter(r => r.status === "fulfilled").length;
      const failed = results.filter(r => r.status === "rejected").length;
      
      console.log(`üìä Bulk sending results: ${successful} successful, ${failed} failed`);
      
      return {
        total: notificationsData.length,
        successful,
        failed,
        results: results.map((r, i) => ({
          data: notificationsData[i],
          status: r.status,
          error: r.status === "rejected" ? r.reason.message : null,
        })),
      };
      
    } catch (error) {
      console.error("‚ùå Bulk notification error:", error);
      throw error;
    }
  }

  /**
   * ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿØÿßÿÆŸÑ ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ (Real-time via Socket.io)
   */
  async sendInAppNotification(notification, user) {
    try {
      // ÿ•ÿ±ÿ≥ÿßŸÑ ÿπÿ®ÿ± Socket.io
      socketService.sendToUser(notification.user.toString(), {
        type: "notification:new",
        data: {
          id: notification._id,
          type: notification.type,
          title: notification.title,
          content: notification.content,
          icon: notification.icon,
          link: notification.link,
          priority: notification.priority,
          timeAgo: notification.timeAgo,
          createdAt: notification.createdAt,
        },
      });
      
      notification.delivery.pushSent = true;
      await notification.save();
      
      return { success: true, channel: "inApp" };
      
    } catch (error) {
      console.error("‚ùå In-app notification error:", error.message);
      notification.delivery.pushError = error.message;
      await notification.save();
      
      return { success: false, channel: "inApp", error: error.message };
    }
  }

  /**
   * ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ Push (FCM/APN)
   */
  async sendPushNotification(notification, user) {
    try {
      // TODO: ÿ™ŸÜŸÅŸäÿ∞ ÿ•ÿ±ÿ≥ÿßŸÑ Push notifications ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ FCM ÿ£Ÿà APN
      console.log(`üì± Would send push notification to ${user._id}`);
      
      // ŸÖÿ≠ÿßŸÉÿßÿ© ÿ•ÿ±ÿ≥ÿßŸÑ ŸÜÿßÿ¨ÿ≠ ŸÑŸÑÿ™ÿ∑ŸàŸäÿ±
      notification.delivery.pushSent = true;
      await notification.save();
      
      return { success: true, channel: "push" };
      
    } catch (error) {
      console.error("‚ùå Push notification error:", error.message);
      notification.delivery.pushError = error.message;
      await notification.save();
      
      return { success: false, channel: "push", error: error.message };
    }
  }

  /**
   * ÿ•ÿ±ÿ≥ÿßŸÑ ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿπÿ®ÿ± ÿßŸÑÿ®ÿ±ŸäÿØ ÿßŸÑÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜŸä
   */
  async sendEmailNotification(notification, user) {
    try {
      const emailService = require('./email.service');
      const userDetails = await User.findById(user._id).select("email name");
      
      if (!userDetails) {
        return { success: false, channel: "email", error: "User not found" };
      }
      
      if (!userDetails.email) {
        return { success: false, channel: "email", error: "No email address" };
      }
      
      // ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ®ÿ±ŸäÿØ ÿßŸÑŸÅÿπŸÑŸä
      const result = await emailService.sendNotificationEmail({
        user: userDetails,
        notification: notification
      });
      
      notification.delivery.emailSent = result.success;
      await notification.save();
      
      return { 
        success: result.success, 
        channel: "email",
        messageId: result.messageId 
      };
      
    } catch (error) {
      console.error("‚ùå Email notification error:", error.message);
      notification.delivery.emailError = error.message;
      await notification.save();
      
      return { success: false, channel: "email", error: error.message };
    }
  }

  /**
   * ÿ•ÿ±ÿ≥ÿßŸÑ ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿπÿ®ÿ± SMS
   */
  async sendSmsNotification(notification, user) {
    try {
      // ÿ¨ŸÑÿ® ÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
      const userDetails = await User.findById(user._id).select("phone name");
      
      if (!userDetails || !userDetails.phone) {
        return { success: false, channel: "sms", error: "No phone number" };
      }
      
      // TODO: ÿ™ŸÜŸÅŸäÿ∞ ÿ•ÿ±ÿ≥ÿßŸÑ SMS ŸÅÿπŸÑŸä
      console.log(`üì± Would send SMS to ${userDetails.phone}`);
      
      // ŸÖÿ≠ÿßŸÉÿßÿ© ÿ•ÿ±ÿ≥ÿßŸÑ ŸÜÿßÿ¨ÿ≠ ŸÑŸÑÿ™ÿ∑ŸàŸäÿ±
      notification.delivery.smsSent = true;
      await notification.save();
      
      return { success: true, channel: "sms" };
      
    } catch (error) {
      console.error("‚ùå SMS notification error:", error.message);
      notification.delivery.smsError = error.message;
      await notification.save();
      
      return { success: false, channel: "sms", error: error.message };
    }
  }

  /**
   * ÿ•ŸÜÿ¥ÿßÿ° ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿ™ŸÑŸÇÿßÿ¶Ÿäÿ© ŸÑŸÑÿ∑ŸÑÿ®ÿßÿ™
   */
  async createOrderNotifications(order) {
    try {
      const notifications = [];
      
      // ÿ•ÿ¥ÿπÿßÿ± ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ∑ŸÑÿ® ŸÑŸÑÿπŸÖŸäŸÑ
      notifications.push({
        user: order.user,
        type: "order_created",
        title: "ÿ™ŸÖ ÿ•ŸÜÿ¥ÿßÿ° ÿ∑ŸÑÿ® ÿ¨ÿØŸäÿØ",
        content: `ÿ™ŸÖ ÿ•ŸÜÿ¥ÿßÿ° ÿ∑ŸÑÿ®ŸÉ #${order._id.toString().slice(-6)} ÿ®ŸÜÿ¨ÿßÿ≠.`,
        data: {
          orderId: order._id,
          orderNumber: order._id.toString().slice(-6),
          totalPrice: order.totalPrice,
          restaurant: order.restaurant,
        },
        priority: "high",
        link: `/orders/${order._id}`,
        icon: "üõí",
        tags: ["order", "order_created", `order_${order._id}`],
      });
      
      // ÿ•ÿ¥ÿπÿßÿ± ŸÑŸÑŸÖÿ∑ÿπŸÖ (ÿ•ÿ∞ÿß ŸÉÿßŸÜ ŸÑÿØŸäŸá ÿ≠ÿ≥ÿßÿ® ÿ£ÿØŸÖŸÜ)
      // TODO: ÿ¨ŸÑÿ® ÿ£ÿØŸÖŸÜ ÿßŸÑŸÖÿ∑ÿπŸÖ
      
      // ÿ•ÿ∞ÿß ŸÉÿßŸÜ ŸáŸÜÿßŸÉ ŸÖŸÜÿØŸàÿ® ŸÖÿπŸäŸÜ
      if (order.driver) {
        notifications.push({
          user: order.driver,
          type: "order_assigned",
          title: "ÿ∑ŸÑÿ® ÿ¨ÿØŸäÿØ ŸÖÿπŸäŸÜ ŸÑŸÉ",
          content: `ÿ™ŸÖ ÿ™ÿπŸäŸäŸÜ ÿ∑ŸÑÿ® #${order._id.toString().slice(-6)} ŸÑŸÉ ŸÑŸÑÿ™ŸàÿµŸäŸÑ.`,
          data: {
            orderId: order._id,
            orderNumber: order._id.toString().slice(-6),
            totalPrice: order.totalPrice,
            restaurant: order.restaurant,
            customer: order.user,
          },
          priority: "high",
          link: `/driver/orders/${order._id}`,
          icon: "üöó",
          tags: ["order", "driver", `order_${order._id}`],
        });
      }
      
      // ÿ•ÿ±ÿ≥ÿßŸÑ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™
      const result = await this.sendBulkNotifications(notifications);
      
      return {
        success: true,
        notificationsCount: notifications.length,
        details: result,
      };
      
    } catch (error) {
      console.error("‚ùå Order notifications error:", error.message);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  /**
   * ÿ™ÿ≠ÿØŸäÿ´ ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿ≠ÿßŸÑÿ© ÿßŸÑÿ∑ŸÑÿ®
   */
  async updateOrderStatusNotifications(order, oldStatus, newStatus) {
    try {
      const notificationType = `order_${newStatus}`;
      
      // ÿ•ÿ¥ÿπÿßÿ± ŸÑŸÑÿπŸÖŸäŸÑ
      await this.sendNotification({
        user: order.user,
        type: notificationType,
        title: this.getOrderStatusTitle(newStatus),
        content: this.getOrderStatusContent(order, newStatus),
        data: {
          orderId: order._id,
          orderNumber: order._id.toString().slice(-6),
          oldStatus,
          newStatus,
          totalPrice: order.totalPrice,
        },
        priority: this.getOrderStatusPriority(newStatus),
        link: `/orders/${order._id}`,
        icon: this.getOrderStatusIcon(newStatus),
        tags: ["order", notificationType, `order_${order._id}`],
      });
      
      // ÿ•ÿ∞ÿß ŸÉÿßŸÜ ŸáŸÜÿßŸÉ ŸÖŸÜÿØŸàÿ®ÿå ÿ£ÿ±ÿ≥ŸÑ ŸÑŸá ÿ•ÿ¥ÿπÿßÿ±ÿßŸã ÿ£Ÿäÿ∂ÿßŸã
      if (order.driver && ["picked", "delivered"].includes(newStatus)) {
        await this.sendNotification({
          user: order.driver,
          type: notificationType,
          title: this.getDriverOrderStatusTitle(newStatus),
          content: this.getDriverOrderStatusContent(order, newStatus),
          data: {
            orderId: order._id,
            orderNumber: order._id.toString().slice(-6),
            oldStatus,
            newStatus,
            customer: order.user,
          },
          priority: "medium",
          link: `/driver/orders/${order._id}`,
          icon: this.getOrderStatusIcon(newStatus),
          tags: ["order", "driver", notificationType, `order_${order._id}`],
        });
      }
      
      return { success: true };
      
    } catch (error) {
      console.error("‚ùå Order status notification error:", error.message);
      return { success: false, error: error.message };
    }
  }

  /**
   * ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
   */
  async getUserNotifications(userId, options = {}) {
    try {
      const {
        page = 1,
        limit = 20,
        status,
        type,
        priority,
        unreadOnly = false,
        includeExpired = false,
      } = options;
      
      const skip = (page - 1) * limit;
      
      // ÿ®ŸÜÿßÿ° ÿßŸÑÿßÿ≥ÿ™ÿπŸÑÿßŸÖ
      const query = { user: userId };
      
      if (status) query.status = status;
      if (type) query.type = type;
      if (priority) query.priority = priority;
      
      if (unreadOnly) {
        query.status = "unread";
      }
      
      if (!includeExpired) {
        query.expiresAt = { $gt: new Date() };
      }
      
      // ÿ¨ŸÑÿ® ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ŸÖÿπ pagination
      const [notifications, total] = await Promise.all([
        Notification.find(query)
          .sort({ sentAt: -1, priority: -1 })
          .skip(skip)
          .limit(limit)
          .lean(),
        
        Notification.countDocuments(query),
      ]);
      
      // ÿ¨ŸÑÿ® ÿπÿØÿØ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿ∫Ÿäÿ± ÿßŸÑŸÖŸÇÿ±Ÿàÿ°ÿ©
      const unreadCount = unreadOnly 
        ? total 
        : await Notification.countDocuments({
            user: userId,
            status: "unread",
            expiresAt: { $gt: new Date() },
          });
      
      // ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑŸàŸÇÿ™ ÿßŸÑŸÜÿ≥ÿ®Ÿä
      const notificationsWithTime = notifications.map(notification => ({
        ...notification,
        timeAgo: this.getRelativeTime(notification.sentAt),
        isExpired: notification.expiresAt && new Date(notification.expiresAt) < new Date(),
      }));
      
      return {
        success: true,
        data: {
          notifications: notificationsWithTime,
          pagination: {
            page,
            limit,
            total,
            totalPages: Math.ceil(total / limit),
            hasNextPage: page * limit < total,
            hasPrevPage: page > 1,
          },
          stats: {
            total,
            unreadCount,
            readCount: total - unreadCount,
          },
        },
      };
      
    } catch (error) {
      console.error("‚ùå Get user notifications error:", error.message);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  /**
   * ÿ™ÿ≠ÿØŸäÿ´ ÿ≠ÿßŸÑÿ© ÿßŸÑÿ•ÿ¥ÿπÿßÿ±
   */
  async updateNotificationStatus(userId, notificationId, status) {
    try {
      const notification = await Notification.findOne({
        _id: notificationId,
        user: userId,
      });
      
      if (!notification) {
        return {
          success: false,
          error: "Notification not found",
        };
      }
      
      const oldStatus = notification.status;
      
      switch (status) {
        case "read":
          await notification.markAsRead();
          break;
        case "unread":
          await notification.markAsUnread();
          break;
        case "archived":
          await notification.archive();
          break;
        default:
          return {
            success: false,
            error: "Invalid status",
          };
      }
      
      // ÿ•ÿ®ÿ∑ÿßŸÑ ÿßŸÑŸÉÿßÿ¥
      this.invalidateCache(userId);
      
      return {
        success: true,
        data: {
          id: notification._id,
          oldStatus,
          newStatus: status,
        },
      };
      
    } catch (error) {
      console.error("‚ùå Update notification status error:", error.message);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  /**
   * ÿ™ÿ≠ÿØŸäÿ´ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ŸÉŸÄ ŸÖŸÇÿ±Ÿàÿ°ÿ©
   */
  async markAllAsRead(userId) {
    try {
      const result = await Notification.markAllAsRead(userId);
      
      // ÿ•ÿ®ÿ∑ÿßŸÑ ÿßŸÑŸÉÿßÿ¥
      this.invalidateCache(userId);
      
      return {
        success: true,
        data: {
          modifiedCount: result.modifiedCount,
        },
      };
      
    } catch (error) {
      console.error("‚ùå Mark all as read error:", error.message);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  /**
   * ÿ≠ÿ∞ŸÅ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±
   */
  async deleteNotification(userId, notificationId) {
    try {
      const result = await Notification.findOneAndDelete({
        _id: notificationId,
        user: userId,
      });
      
      if (!result) {
        return {
          success: false,
          error: "Notification not found",
        };
      }
      
      // ÿ•ÿ®ÿ∑ÿßŸÑ ÿßŸÑŸÉÿßÿ¥
      this.invalidateCache(userId);
      
      return {
        success: true,
        data: {
          id: notificationId,
          deleted: true,
        },
      };
      
    } catch (error) {
      console.error("‚ùå Delete notification error:", error.message);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  /**
   * ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿßŸÑŸÖŸÜÿ™ŸáŸäÿ©
   */
  async cleanupExpiredNotifications() {
    try {
      const result = await Notification.cleanupExpired();
      
      console.log(`üßπ Cleaned up ${result.deletedCount} expired notifications`);
      
      return {
        success: true,
        deletedCount: result.deletedCount,
      };
      
    } catch (error) {
      console.error("‚ùå Cleanup notifications error:", error.message);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  /**
   * ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™
   */
  async getNotificationStats(userId) {
    try {
      const cacheKey = `notifications:stats:${userId}`;
      const cachedStats = cache.get(cacheKey);
      
      if (cachedStats) {
        return cachedStats;
      }
      
      const [
        totalCount,
        unreadCount,
        byType,
        byPriority,
        dailyStats,
        weeklyStats,
      ] = await Promise.all([
        // ÿßŸÑÿπÿØÿØ ÿßŸÑŸÉŸÑŸä
        Notification.countDocuments({ user: userId, expiresAt: { $gt: new Date() } }),
        
        // ÿßŸÑÿπÿØÿØ ÿ∫Ÿäÿ± ÿßŸÑŸÖŸÇÿ±Ÿàÿ°
        Notification.countDocuments({ 
          user: userId, 
          status: "unread",
          expiresAt: { $gt: new Date() },
        }),
        
        // ÿ≠ÿ≥ÿ® ÿßŸÑŸÜŸàÿπ
        Notification.aggregate([
          { 
            $match: { 
              user: userId,
              expiresAt: { $gt: new Date() },
            } 
          },
          {
            $group: {
              _id: "$type",
              count: { $sum: 1 },
              unread: {
                $sum: { $cond: [{ $eq: ["$status", "unread"] }, 1, 0] },
              },
            },
          },
          { $sort: { count: -1 } },
        ]),
        
        // ÿ≠ÿ≥ÿ® ÿßŸÑÿ£ŸàŸÑŸàŸäÿ©
        Notification.aggregate([
          { 
            $match: { 
              user: userId,
              expiresAt: { $gt: new Date() },
            } 
          },
          {
            $group: {
              _id: "$priority",
              count: { $sum: 1 },
            },
          },
        ]),
        
        // ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ŸäŸàŸÖŸäÿ© (ÿ¢ÿÆÿ± 7 ÿ£ŸäÿßŸÖ)
        Notification.aggregate([
          {
            $match: {
              user: userId,
              sentAt: { 
                $gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),
              },
            },
          },
          {
            $group: {
              _id: {
                $dateToString: { format: "%Y-%m-%d", date: "$sentAt" },
              },
              count: { $sum: 1 },
              readCount: {
                $sum: { $cond: [{ $eq: ["$status", "read"] }, 1, 0] },
              },
            },
          },
          { $sort: { _id: -1 } },
        ]),
        
        // ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿ£ÿ≥ÿ®ŸàÿπŸäÿ© (ÿ¢ÿÆÿ± 4 ÿ£ÿ≥ÿßÿ®Ÿäÿπ)
        Notification.aggregate([
          {
            $match: {
              user: userId,
              sentAt: { 
                $gte: new Date(Date.now() - 28 * 24 * 60 * 60 * 1000),
              },
            },
          },
          {
            $group: {
              _id: {
                $dateToString: { format: "%Y-%W", date: "$sentAt" },
              },
              count: { $sum: 1 },
            },
          },
          { $sort: { _id: -1 } },
          { $limit: 4 },
        ]),
      ]);
      
      const stats = {
        success: true,
        data: {
          total: totalCount,
          unread: unreadCount,
          read: totalCount - unreadCount,
          byType: byType.reduce((acc, item) => {
            acc[item._id] = item;
            return acc;
          }, {}),
          byPriority: byPriority.reduce((acc, item) => {
            acc[item._id] = item.count;
            return acc;
          }, {}),
          dailyStats: dailyStats,
          weeklyStats: weeklyStats,
          deliveryRate: this.calculateDeliveryRate(byType),
          engagementRate: totalCount > 0 
            ? ((totalCount - unreadCount) / totalCount) * 100 
            : 0,
        },
      };
      
      // ÿ≠ŸÅÿ∏ ŸÅŸä ÿßŸÑŸÉÿßÿ¥ ŸÑŸÖÿØÿ© 5 ÿØŸÇÿßÿ¶ŸÇ
      cache.set(cacheKey, stats, 300);
      
      return stats;
      
    } catch (error) {
      console.error("‚ùå Get notification stats error:", error.message);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  // ====== ÿØŸàÿßŸÑ ŸÖÿ≥ÿßÿπÿØÿ© ======

  getOrderStatusTitle(status) {
    const titles = {
      pending: "ÿ∑ŸÑÿ® ŸÇŸäÿØ ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ±",
      accepted: "ÿ™ŸÖ ŸÇÿ®ŸàŸÑ ÿßŸÑÿ∑ŸÑÿ®",
      picked: "ÿ™ŸÖ ÿßÿ≥ÿ™ŸÑÿßŸÖ ÿßŸÑÿ∑ŸÑÿ®",
      delivered: "ÿ™ŸÖ ÿßŸÑÿ™ŸàÿµŸäŸÑ",
      cancelled: "ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿßŸÑÿ∑ŸÑÿ®",
    };
    
    return titles[status] || "ÿ™ÿ≠ÿØŸäÿ´ ÿπŸÑŸâ ÿ∑ŸÑÿ®ŸÉ";
  }

  getOrderStatusContent(order, status) {
    const contents = {
      pending: `ÿ∑ŸÑÿ®ŸÉ #${order._id.toString().slice(-6)} ŸÇŸäÿØ ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ±.`,
      accepted: `ÿ™ŸÖ ŸÇÿ®ŸàŸÑ ÿ∑ŸÑÿ®ŸÉ #${order._id.toString().slice(-6)} Ÿàÿ¨ÿßÿ±Ÿä ÿ™ÿ¨ŸáŸäÿ≤Ÿá.`,
      picked: `ÿ™ŸÖ ÿßÿ≥ÿ™ŸÑÿßŸÖ ÿ∑ŸÑÿ®ŸÉ #${order._id.toString().slice(-6)} ŸÖŸÜ ÿßŸÑŸÖÿ∑ÿπŸÖ.`,
      delivered: `ÿ™ŸÖ ÿ™ŸàÿµŸäŸÑ ÿ∑ŸÑÿ®ŸÉ #${order._id.toString().slice(-6)} ÿ®ŸÜÿ¨ÿßÿ≠.`,
      cancelled: `ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿ∑ŸÑÿ®ŸÉ #${order._id.toString().slice(-6)}.`,
    };
    
    return contents[status] || `ŸáŸÜÿßŸÉ ÿ™ÿ≠ÿØŸäÿ´ ÿπŸÑŸâ ÿ∑ŸÑÿ®ŸÉ #${order._id.toString().slice(-6)}.`;
  }

  getDriverOrderStatusTitle(status) {
    const titles = {
      picked: "ÿ™ŸÖ ÿßÿ≥ÿ™ŸÑÿßŸÖ ÿßŸÑÿ∑ŸÑÿ® ŸÖŸÜ ÿßŸÑŸÖÿ∑ÿπŸÖ",
      delivered: "ÿ™ŸÖ ÿ™ÿ≥ŸÑŸäŸÖ ÿßŸÑÿ∑ŸÑÿ® ŸÑŸÑÿπŸÖŸäŸÑ",
    };
    
    return titles[status] || "ÿ™ÿ≠ÿØŸäÿ´ ÿπŸÑŸâ ÿßŸÑÿ∑ŸÑÿ®";
  }

  getDriverOrderStatusContent(order, status) {
    const contents = {
      picked: `ÿ™ŸÖ ÿßÿ≥ÿ™ŸÑÿßŸÖ ÿ∑ŸÑÿ® #${order._id.toString().slice(-6)} ŸÖŸÜ ÿßŸÑŸÖÿ∑ÿπŸÖ.`,
      delivered: `ÿ™ŸÖ ÿ™ÿ≥ŸÑŸäŸÖ ÿ∑ŸÑÿ® #${order._id.toString().slice(-6)} ŸÑŸÑÿπŸÖŸäŸÑ.`,
    };
    
    return contents[status] || `ÿ™ÿ≠ÿØŸäÿ´ ÿπŸÑŸâ ÿ∑ŸÑÿ® #${order._id.toString().slice(-6)}.`;
  }

  getOrderStatusPriority(status) {
    const priorities = {
      cancelled: "urgent",
      delivered: "high",
      accepted: "high",
      picked: "medium",
      pending: "low",
    };
    
    return priorities[status] || "medium";
  }

  getOrderStatusIcon(status) {
    const icons = {
      pending: "‚è≥",
      accepted: "‚úÖ",
      picked: "üì¶",
      delivered: "üöö",
      cancelled: "‚ùå",
    };
    
    return icons[status] || "üîî";
  }

  getRelativeTime(date) {
    const now = new Date();
    const past = new Date(date);
    const diffMs = now - past;
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    const diffDays = Math.floor(diffMs / 86400000);
    
    if (diffMins < 1) return "ÿßŸÑÿ¢ŸÜ";
    if (diffMins < 60) return `ŸÖŸÜÿ∞ ${diffMins} ÿØŸÇŸäŸÇÿ©`;
    if (diffHours < 24) return `ŸÖŸÜÿ∞ ${diffHours} ÿ≥ÿßÿπÿ©`;
    if (diffDays < 7) return `ŸÖŸÜÿ∞ ${diffDays} ŸäŸàŸÖ`;
    if (diffDays < 30) return `ŸÖŸÜÿ∞ ${Math.floor(diffDays / 7)} ÿ£ÿ≥ÿ®Ÿàÿπ`;
    if (diffDays < 365) return `ŸÖŸÜÿ∞ ${Math.floor(diffDays / 30)} ÿ¥Ÿáÿ±`;
    return `ŸÖŸÜÿ∞ ${Math.floor(diffDays / 365)} ÿ≥ŸÜÿ©`;
  }

  calculateDeliveryRate(byType) {
    const total = byType.reduce((sum, item) => sum + item.count, 0);
    
    if (total === 0) return 0;
    
    const orderNotifications = byType.filter(item => 
      item._id.startsWith("order_")
    ).reduce((sum, item) => sum + item.count, 0);
    
    return (orderNotifications / total) * 100;
  }

  invalidateCache(userId) {
    cache.del(`notifications:user:${userId}`);
    cache.del(`notifications:stats:${userId}`);
    cache.del(`notifications:unread:${userId}`);
    cache.invalidatePattern(`notifications:*:${userId}`);
  }
}

module.exports = new NotificationService();
</file>

<file path="src/services/sms.service.js">
const crypto = require('crypto');

class SmsService {
  constructor() {
    this.config = {
      enabled: process.env.SMS_ENABLED === 'true',
      provider: process.env.SMS_PROVIDER || 'twilio',
      from: process.env.SMS_FROM || 'FoodDelivery',
      appName: process.env.APP_NAME || 'Food Delivery'
    };
    
    console.log(`üì± SMS service initialized - Enabled: ${this.config.enabled}`);
  }

  async sendSms(to, message) {
    try {
      if (!to || !message) {
        throw new Error('Phone number and message are required');
      }

      // ÿ™ŸÜÿ∏ŸäŸÅ ÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ
      const cleanPhone = this.cleanPhoneNumber(to);
      
      if (!this.isValidPhoneNumber(cleanPhone)) {
        throw new Error(`Invalid phone number: ${to}`);
      }

      if (!this.config.enabled) {
        console.log(`üì± [SIMULATED] SMS to ${cleanPhone}: ${message.substring(0, 50)}...`);
        return {
          success: true,
          simulated: true,
          messageId: `simulated-${crypto.randomBytes(8).toString('hex')}`,
          to: cleanPhone,
          length: message.length,
          timestamp: new Date()
        };
      }

      // TODO: ÿ•ÿ∂ÿßŸÅÿ© ÿ™ŸÉÿßŸÖŸÑ ŸÖÿπ ÿÆÿØŸÖÿ© SMS ÿ≠ŸÇŸäŸÇŸäÿ©
      // ŸÖÿ´ÿßŸÑ ŸÖÿπ Twilio (Ÿäÿ≠ÿ™ÿßÿ¨ ÿ™ÿ´ÿ®Ÿäÿ™ twilio):
      /*
      const client = require('twilio')(
        process.env.TWILIO_ACCOUNT_SID,
        process.env.TWILIO_AUTH_TOKEN
      );
      
      const result = await client.messages.create({
        body: message,
        from: this.config.from,
        to: cleanPhone
      });
      */
      
      // Simulation ŸÑŸÑÿ™ŸÜŸÖŸäÿ©
      console.log(`üì± SMS sent to ${cleanPhone}: ${message.substring(0, 100)}...`);
      
      return {
        success: true,
        messageId: `sms-${Date.now()}-${crypto.randomBytes(4).toString('hex')}`,
        to: cleanPhone,
        length: message.length,
        timestamp: new Date()
      };
    } catch (error) {
      console.error('‚ùå SMS sending error:', error.message);
      return {
        success: false,
        error: error.message,
        to,
        timestamp: new Date()
      };
    }
  }

  cleanPhoneNumber(phone) {
    // ÿ•ÿ≤ÿßŸÑÿ© ÿ¨ŸÖŸäÿπ ÿßŸÑÿ£ÿ≠ÿ±ŸÅ ÿ∫Ÿäÿ± ÿßŸÑÿ±ŸÇŸÖŸäÿ©
    let cleaned = phone.replace(/\D/g, '');
    
    // ÿ•ÿ∂ÿßŸÅÿ© ÿ±ŸÖÿ≤ ÿßŸÑÿØŸàŸÑÿ© ÿ•ÿ∞ÿß ŸÑŸÖ ŸäŸÉŸÜ ŸÖŸàÿ¨ŸàÿØÿßŸã
    if (cleaned.startsWith('0')) {
      cleaned = '212' + cleaned.substring(1); // ŸÖÿ´ÿßŸÑ ŸÑŸÑŸÖÿ∫ÿ±ÿ®
    } else if (!cleaned.startsWith('+') && cleaned.length <= 10) {
      cleaned = '212' + cleaned; // ÿ•ÿ∂ÿßŸÅÿ© ÿ±ŸÖÿ≤ ÿßŸÑÿØŸàŸÑÿ© ÿßŸÅÿ™ÿ±ÿßÿ∂ŸäÿßŸã
    }
    
    return '+' + cleaned;
  }

  isValidPhoneNumber(phone) {
    const phoneRegex = /^\+[1-9]\d{1,14}$/; // E.164 format
    return phoneRegex.test(phone);
  }

  async sendVerificationCode(phone, verificationCode) {
    const message = `ÿ±ŸÖÿ≤ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ÿßŸÑÿÆÿßÿµ ÿ®ŸÉ ŸÅŸä ${this.config.appName} ŸáŸà: ${verificationCode}. ÿµÿßŸÑÿ≠ ŸÑŸÖÿØÿ© 10 ÿØŸÇÿßÿ¶ŸÇ.`;
    
    return this.sendSms(phone, message);
  }

  async sendWelcomeSms(user) {
    const message = `ŸÖÿ±ÿ≠ÿ®ÿßŸã ${user.name}! ÿ¥ŸÉÿ±ÿßŸã ŸÑÿßŸÜÿ∂ŸÖÿßŸÖŸÉ ÿ•ŸÑŸâ ${this.config.appName}. ŸäŸÖŸÉŸÜŸÉ ÿßŸÑÿ¢ŸÜ ÿ∑ŸÑÿ® ÿßŸÑÿ∑ÿπÿßŸÖ ŸÖŸÜ ÿ£ŸÅÿ∂ŸÑ ÿßŸÑŸÖÿ∑ÿßÿπŸÖ.`;
    
    return this.sendSms(user.phone, message);
  }

  async sendOrderStatusSms(user, order, status) {
    const statusMessages = {
      pending: 'ÿ™ŸÖ ÿßÿ≥ÿ™ŸÑÿßŸÖ ÿ∑ŸÑÿ®ŸÉ ÿ®ŸÜÿ¨ÿßÿ≠ Ÿàÿ¨ÿßÿ±Ÿä ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©.',
      accepted: 'ÿ™ŸÖ ŸÇÿ®ŸàŸÑ ÿ∑ŸÑÿ®ŸÉ Ÿàÿ¨ÿßÿ±Ÿä ÿ™ÿ¨ŸáŸäÿ≤Ÿá.',
      picked: 'ÿ™ŸÖ ÿßÿ≥ÿ™ŸÑÿßŸÖ ÿ∑ŸÑÿ®ŸÉ ŸÖŸÜ ÿßŸÑŸÖÿ∑ÿπŸÖ Ÿàÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ŸàÿµŸäŸÑ.',
      delivered: 'ÿ™ŸÖ ÿ™ŸàÿµŸäŸÑ ÿ∑ŸÑÿ®ŸÉ ÿ®ŸÜÿ¨ÿßÿ≠. ŸÜÿ™ŸÖŸÜŸâ ŸÑŸÉ Ÿàÿ¨ÿ®ÿ© ÿ¥ŸáŸäÿ©!',
      cancelled: 'ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿ∑ŸÑÿ®ŸÉ.'
    };
    
    const message = `${statusMessages[status] || 'ÿ™ÿ≠ÿØŸäÿ´ ÿπŸÑŸâ ÿ∑ŸÑÿ®ŸÉ.'} ÿ±ŸÇŸÖ ÿßŸÑÿ∑ŸÑÿ®: ${order._id.toString().slice(-6)}. ÿßŸÑŸÖÿ¨ŸÖŸàÿπ: ${order.totalPrice.toFixed(2)} ÿØ.ŸÖ`;
    
    return this.sendSms(user.phone, message);
  }

  async sendDriverAssignedSms(user, order, driver) {
    const message = `ÿ™ŸÖ ÿ™ÿπŸäŸäŸÜ ŸÖŸÜÿØŸàÿ® ${driver.name} ŸÑÿ™ŸàÿµŸäŸÑ ÿ∑ŸÑÿ®ŸÉ ÿ±ŸÇŸÖ ${order._id.toString().slice(-6)}. ŸäŸÖŸÉŸÜŸÉ ÿ™ÿ™ÿ®ÿπ ÿßŸÑŸÖŸÜÿØŸàÿ® ŸÅŸä ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ.`;
    
    return this.sendSms(user.phone, message);
  }

  async sendPasswordResetSms(user, resetToken) {
    const message = `ÿ±ŸÖÿ≤ ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±: ${resetToken}. ÿµÿßŸÑÿ≠ ŸÑŸÖÿØÿ© 10 ÿØŸÇÿßÿ¶ŸÇ. ${this.config.appName}`;
    
    return this.sendSms(user.phone, message);
  }

  async sendPromotionalSms(phone, promotion) {
    const message = `ÿπÿ±ÿ∂ ÿÆÿßÿµ ŸÖŸÜ ${this.config.appName}: ${promotion.title} - ${promotion.description}. ÿµÿßŸÑÿ≠ ÿ≠ÿ™Ÿâ: ${new Date(promotion.validUntil).toLocaleDateString('ar-SA')}`;
    
    return this.sendSms(phone, message);
  }

  async sendBulkSms(phones, message, options = {}) {
    const results = {
      total: phones.length,
      successful: 0,
      failed: 0,
      details: []
    };
    
    // ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿ®ÿ¥ŸÉŸÑ ŸÖÿ™Ÿàÿßÿ≤Ÿä ŸÖÿπ rate limiting
    const batchSize = options.batchSize || 10;
    const delayBetweenBatches = options.delayBetweenBatches || 1000; // 1 second
    
    for (let i = 0; i < phones.length; i += batchSize) {
      const batch = phones.slice(i, i + batchSize);
      const batchPromises = batch.map(phone => this.sendSms(phone, message));
      
      try {
        const batchResults = await Promise.allSettled(batchPromises);
        
        batchResults.forEach((result, index) => {
          const phone = batch[index];
          if (result.status === 'fulfilled' && result.value.success) {
            results.successful++;
            results.details.push({
              phone,
              success: true,
              messageId: result.value.messageId
            });
          } else {
            results.failed++;
            results.details.push({
              phone,
              success: false,
              error: result.reason?.message || result.value?.error || 'Unknown error'
            });
          }
        });
        
        console.log(`üì± Batch ${Math.floor(i/batchSize) + 1} completed: ${results.successful}/${results.total} successful`);
        
        // ÿ™ÿ£ÿÆŸäÿ± ÿ®ŸäŸÜ ÿßŸÑÿØŸÅÿπÿßÿ™ ŸÑÿ™ÿ¨ŸÜÿ® rate limiting
        if (i + batchSize < phones.length) {
          await new Promise(resolve => setTimeout(resolve, delayBetweenBatches));
        }
      } catch (error) {
        console.error('‚ùå Batch SMS error:', error.message);
        batch.forEach(phone => {
          results.failed++;
          results.details.push({
            phone,
            success: false,
            error: error.message
          });
        });
      }
    }
    
    return results;
  }
}

module.exports = new SmsService();
</file>

<file path="src/services/socket.service.js">
const socketIo = require("socket.io");

class SocketService {
  constructor() {
    this.io = null;
    this.userSockets = new Map();
    this.userRooms = new Map();
    this.chatSocketService = null;
  }

  initialize(server) {
    try {
      this.io = socketIo(server, {
        cors: {
          origin: process.env.CLIENT_URL || "http://localhost:3001",
          methods: ["GET", "POST"],
          credentials: true,
        },
        pingTimeout: 60000,
        pingInterval: 25000,
      });

      this.setupEventHandlers();
      console.log("‚úÖ Socket.io initialized");
      
      // ÿ™ŸáŸäÿ¶ÿ© ÿÆÿØŸÖÿßÿ™ ÿßŸÑÿØÿ±ÿØÿ¥ÿ©
      this.initializeChatServices();
      
      return this.io;
    } catch (error) {
      console.error("‚ùå Failed to initialize Socket.io:", error.message);
      throw error;
    }
  }

  setupEventHandlers() {
    if (!this.io) {
      console.error("‚ùå Cannot setup event handlers: Socket.io not initialized");
      return;
    }

    this.io.on("connection", (socket) => {
      console.log(`üü¢ New socket connection: ${socket.id}`);

      // ÿ™ÿπŸäŸäŸÜ ŸÖÿπÿ±ŸÅ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÑŸÑŸÄ socket
      socket.userId = null;

      socket.on("authenticate", async (userId) => {
        try {
          if (!userId) {
            socket.emit("error", { message: "User ID is required" });
            return;
          }

          socket.userId = userId.toString();
          
          socket.join(`user:${userId}`);
          this.userSockets.set(userId.toString(), socket.id);
          
          // ÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑÿ∫ÿ±ŸÅ ÿßŸÑÿ™Ÿä ÿßŸÜÿ∂ŸÖ ÿ•ŸÑŸäŸáÿß ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
          if (!this.userRooms.has(userId.toString())) {
            this.userRooms.set(userId.toString(), new Set());
          }
          this.userRooms.get(userId.toString()).add(`user:${userId}`);
          
          console.log(`üë§ User ${userId} authenticated and joined their room`);
          
          socket.emit("authenticated", {
            message: "Successfully authenticated",
            userId: userId,
            timestamp: new Date(),
          });

          // ÿ•ÿπŸÑÿßŸÖ ÿßŸÑÿ¢ÿÆÿ±ŸäŸÜ ÿ®ÿßÿ™ÿµÿßŸÑ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
          socket.broadcast.emit("user:connected", {
            userId: userId,
            socketId: socket.id,
            timestamp: new Date(),
          });
        } catch (error) {
          console.error("Authentication error:", error.message);
          socket.emit("error", { message: "Failed to authenticate" });
        }
      });

      socket.on("join", async (userId) => {
        try {
          if (!userId) {
            socket.emit("error", { message: "User ID is required" });
            return;
          }

          socket.userId = userId.toString();
          
          socket.join(`user:${userId}`);
          this.userSockets.set(userId.toString(), socket.id);
          
          // ÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑÿ∫ÿ±ŸÅ ÿßŸÑÿ™Ÿä ÿßŸÜÿ∂ŸÖ ÿ•ŸÑŸäŸáÿß ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
          if (!this.userRooms.has(userId.toString())) {
            this.userRooms.set(userId.toString(), new Set());
          }
          this.userRooms.get(userId.toString()).add(`user:${userId}`);
          
          console.log(`üë§ User ${userId} joined their room`);
          
          socket.emit("welcome", {
            message: "Connected to notification server",
            userId: userId,
            timestamp: new Date(),
          });

          // ÿ•ÿπŸÑÿßŸÖ ÿßŸÑÿ¢ÿÆÿ±ŸäŸÜ ÿ®ÿßÿ™ÿµÿßŸÑ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
          socket.broadcast.emit("user:connected", {
            userId: userId,
            socketId: socket.id,
            timestamp: new Date(),
          });
        } catch (error) {
          console.error("Join error:", error.message);
          socket.emit("error", { message: "Failed to join room" });
        }
      });

      socket.on("order:subscribe", (orderId) => {
        try {
          if (!orderId) {
            socket.emit("error", { message: "Order ID is required" });
            return;
          }

          socket.join(`order:${orderId}`);
          
          // ÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑÿ∫ÿ±ŸÅÿ© ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
          const userId = this.getUserIdBySocket(socket.id);
          if (userId && this.userRooms.has(userId)) {
            this.userRooms.get(userId).add(`order:${orderId}`);
          }
          
          console.log(`üì¶ Socket ${socket.id} subscribed to order ${orderId}`);
        } catch (error) {
          console.error("Order subscribe error:", error.message);
        }
      });

      socket.on("restaurant:subscribe", (restaurantId) => {
        try {
          if (!restaurantId) {
            socket.emit("error", { message: "Restaurant ID is required" });
            return;
          }

          socket.join(`restaurant:${restaurantId}`);
          
          const userId = this.getUserIdBySocket(socket.id);
          if (userId && this.userRooms.has(userId)) {
            this.userRooms.get(userId).add(`restaurant:${restaurantId}`);
          }
          
          console.log(`üè™ Socket ${socket.id} subscribed to restaurant ${restaurantId}`);
        } catch (error) {
          console.error("Restaurant subscribe error:", error.message);
        }
      });

      socket.on("presence:update", (data) => {
        try {
          const { userId, isOnline } = data;
          
          if (!userId) {
            socket.emit("error", { message: "User ID is required" });
            return;
          }

          socket.broadcast.emit("presence:changed", {
            userId,
            isOnline: Boolean(isOnline),
            timestamp: new Date(),
          });
        } catch (error) {
          console.error("Presence update error:", error.message);
        }
      });

      socket.on("message:send", async (data) => {
        try {
          const { to, message, type = "chat" } = data;
          
          if (!to || !message) {
            socket.emit("error", { message: "To and message are required" });
            return;
          }

          const from = this.getUserIdBySocket(socket.id);
          if (!from) {
            socket.emit("error", { message: "User not authenticated" });
            return;
          }

          this.sendToUser(to, {
            type: "message:new",
            data: {
              from,
              message,
              type,
              timestamp: new Date(),
            },
          });
          
          socket.emit("message:sent", {
            to,
            message,
            timestamp: new Date(),
          });
        } catch (error) {
          console.error("Message send error:", error.message);
          socket.emit("error", { message: "Failed to send message" });
        }
      });

      socket.on("driver:location:update", (data) => {
        try {
          const { driverId, orderId, location } = data;
          
          if (!driverId || !location) {
            socket.emit("error", { message: "Driver ID and location are required" });
            return;
          }

          if (orderId) {
            this.io.to(`order:${orderId}`).emit("driver:location:updated", {
              driverId,
              location,
              timestamp: new Date(),
            });
          }
          
          this.io.to("admin:room").emit("driver:location:updated", {
            driverId,
            location,
            timestamp: new Date(),
          });
        } catch (error) {
          console.error("Driver location update error:", error.message);
          socket.emit("error", { message: "Failed to update location" });
        }
      });

      socket.on("disconnect", (reason) => {
        console.log(`üî¥ Socket disconnected: ${socket.id}, reason: ${reason}`);
        
        const userId = this.getUserIdBySocket(socket.id);
        if (userId) {
          this.userSockets.delete(userId.toString());
          
          // ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑÿ∫ÿ±ŸÅ
          if (this.userRooms.has(userId.toString())) {
            const rooms = this.userRooms.get(userId.toString());
            rooms.forEach(room => {
              if (this.io) {
                socket.leave(room);
              }
            });
            this.userRooms.delete(userId.toString());
          }
          
          if (this.io) {
            socket.broadcast.emit("user:disconnected", {
              userId,
              socketId: socket.id,
              reason,
              timestamp: new Date(),
            });
          }
        }
      });

      socket.on("error", (error) => {
        console.error(`Socket error ${socket.id}:`, error);
      });
    });
  }

  getUserIdBySocket(socketId) {
    // ÿßŸÑÿ®ÿ≠ÿ´ ŸÅŸä userSockets
    for (const [userId, sid] of this.userSockets.entries()) {
      if (sid === socketId) {
        return userId;
      }
    }
    return null;
  }

  sendToUser(userId, data) {
    try {
      if (!this.io) {
        console.error("‚ùå Socket.io not initialized");
        return { success: false, error: "Socket.io not initialized" };
      }

      const socketId = this.userSockets.get(userId.toString());
      
      if (socketId) {
        this.io.to(socketId).emit(data.type, data.data || data);
        console.log(`üì® Sent ${data.type} to user ${userId}`);
        return { success: true, delivered: true };
      }
      
      console.log(`üì≠ User ${userId} is not connected, notification queued`);
      return { success: true, delivered: false, queued: true };
    } catch (error) {
      console.error("Send to user error:", error);
      return { success: false, error: error.message };
    }
  }

  sendToUsers(userIds, data) {
    const results = {
      total: userIds.length,
      delivered: 0,
      queued: 0,
      failed: 0,
      errors: []
    };
    
    userIds.forEach(userId => {
      const result = this.sendToUser(userId, data);
      if (result.success) {
        if (result.delivered) {
          results.delivered++;
        } else {
          results.queued++;
        }
      } else {
        results.failed++;
        results.errors.push({ userId, error: result.error });
      }
    });
    
    return results;
  }

  sendToRoom(room, data) {
    try {
      if (!this.io) {
        console.error("‚ùå Socket.io not initialized");
        return { success: false, error: "Socket.io not initialized" };
      }

      this.io.to(room).emit(data.type, data.data || data);
      console.log(`üì® Sent ${data.type} to room ${room}`);
      return { success: true };
    } catch (error) {
      console.error("Send to room error:", error);
      return { success: false, error: error.message };
    }
  }

  broadcast(data, excludeSocketId = null) {
    try {
      if (!this.io) {
        console.error("‚ùå Socket.io not initialized");
        return { success: false, error: "Socket.io not initialized" };
      }

      if (excludeSocketId) {
        this.io.except(excludeSocketId).emit(data.type, data.data || data);
      } else {
        this.io.emit(data.type, data.data || data);
      }
      
      console.log(`üì¢ Broadcast ${data.type} to all connected clients`);
      return { success: true };
    } catch (error) {
      console.error("Broadcast error:", error);
      return { success: false, error: error.message };
    }
  }

  getConnectedUsersCount() {
    return this.userSockets.size;
  }

  isUserConnected(userId) {
    return this.userSockets.has(userId.toString());
  }

  getConnectedUsers() {
    return Array.from(this.userSockets.keys());
  }

  initializeChatServices() {
    try {
      if (!this.io) {
        console.warn("‚ö†Ô∏è Socket.io not initialized yet, chat service will be delayed");
        return null;
      }

      const ChatSocketService = require("./chat.socket.service");
      
      // ÿ•ŸÜÿ¥ÿßÿ° ŸÜÿ≥ÿÆÿ© ÿ¨ÿØŸäÿØÿ© ŸÖŸÜ ChatSocketService
      const chatSocketService = ChatSocketService;
      
      // ÿ™ŸÖÿ±Ÿäÿ± instance ÿßŸÑŸÄ Socket.io ŸÑÿÆÿØŸÖÿ© ÿßŸÑÿØÿ±ÿØÿ¥ÿ©
      if (chatSocketService.initializeWithIO) {
        chatSocketService.initializeWithIO(this.io);
      }
      
      // ÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑŸÖÿ±ÿ¨ÿπ ŸÑŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ŸÑÿßÿ≠ŸÇÿßŸã
      this.chatSocketService = chatSocketService;
      
      console.log("‚úÖ Chat socket service initialized");
      return chatSocketService;
    } catch (error) {
      console.error("‚ùå Chat service initialization failed:", error.message);
      return null;
    }
  }

  // ÿØÿßŸÑÿ© ŸÑŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ instance ÿßŸÑŸÄ Socket.io ŸÑŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿÆÿßÿ±ÿ¨Ÿä
  getIO() {
    if (!this.io) {
      console.warn("‚ö†Ô∏è Socket.io not initialized yet");
    }
    return this.io;
  }

  // ÿØÿßŸÑÿ© ŸÑŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ™ŸáŸäÿ¶ÿ© ÿßŸÑÿÆÿØŸÖÿ©
  isInitialized() {
    return !!this.io;
  }
}

const socketServiceInstance = new SocketService();

module.exports = {
  initialize: (server) => socketServiceInstance.initialize(server),
  sendToUser: (userId, data) => socketServiceInstance.sendToUser(userId, data),
  sendToUsers: (userIds, data) => socketServiceInstance.sendToUsers(userIds, data),
  sendToRoom: (room, data) => socketServiceInstance.sendToRoom(room, data),
  broadcast: (data, excludeSocketId) => socketServiceInstance.broadcast(data, excludeSocketId),
  isUserConnected: (userId) => socketServiceInstance.isUserConnected(userId),
  getConnectedUsers: () => socketServiceInstance.getConnectedUsers(),
  getConnectedUsersCount: () => socketServiceInstance.getConnectedUsersCount(),
  initializeChatServices: () => socketServiceInstance.initializeChatServices(),
  getIO: () => socketServiceInstance.getIO(),
  isInitialized: () => socketServiceInstance.isInitialized(),
  instance: socketServiceInstance
};
</file>

<file path="src/utils/cache.util.js">
const NodeCache = require('node-cache');
const { businessLogger } = require('./logger.util');

class CacheService {
  constructor() {
    this.cache = new NodeCache({
      stdTTL: process.env.CACHE_TTL ? parseInt(process.env.CACHE_TTL) : 300,
      checkperiod: 60,
      useClones: false,
      deleteOnExpire: true
    });
    
    this.stats = {
      hits: 0,
      misses: 0,
      sets: 0,
      deletes: 0,
      invalidations: 0,
      errors: 0
    };
    
    console.log('‚úÖ Cache service initialized with TTL:', this.cache.options.stdTTL);
  }

  set(key, value, ttl = null) {
    try {
      const success = this.cache.set(key, value, ttl || this.cache.options.stdTTL);
      if (success) {
        this.stats.sets++;
        businessLogger.debug('Cache Set', { key, ttl, size: JSON.stringify(value).length });
      }
      return success;
    } catch (error) {
      this.stats.errors++;
      businessLogger.error('Cache Set Error', { key, error: error.message });
      return false;
    }
  }

  get(key) {
    try {
      const value = this.cache.get(key);
      if (value !== undefined) {
        this.stats.hits++;
        businessLogger.debug('Cache Hit', { key });
      } else {
        this.stats.misses++;
        businessLogger.debug('Cache Miss', { key });
      }
      return value;
    } catch (error) {
      this.stats.errors++;
      businessLogger.error('Cache Get Error', { key, error: error.message });
      return undefined;
    }
  }

  mget(keys) {
    try {
      const values = this.cache.mget(keys);
      const hitCount = Object.keys(values).filter(k => values[k] !== undefined).length;
      this.stats.hits += hitCount;
      this.stats.misses += (keys.length - hitCount);
      return values;
    } catch (error) {
      this.stats.errors++;
      businessLogger.error('Cache MGet Error', { keys, error: error.message });
      return {};
    }
  }

  has(key) {
    return this.cache.has(key);
  }

  del(key) {
    try {
      const deleted = this.cache.del(key);
      if (deleted > 0) {
        this.stats.deletes++;
        businessLogger.debug('Cache Delete', { key });
      }
      return deleted;
    } catch (error) {
      this.stats.errors++;
      businessLogger.error('Cache Delete Error', { key, error: error.message });
      return 0;
    }
  }

  flush() {
    try {
      const keys = this.cache.keys();
      this.stats.deletes += keys.length;
      this.cache.flushAll();
      businessLogger.info('Cache Flush', { keysCount: keys.length });
      return keys.length;
    } catch (error) {
      this.stats.errors++;
      businessLogger.error('Cache Flush Error', { error: error.message });
      return 0;
    }
  }

  getStats() {
    // ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ node-cache ÿ®ÿ∑ÿ±ŸäŸÇÿ© ŸÖÿ™ŸàÿßŸÅŸÇÿ©
    const keys = this.cache.keys();
    const stats = this.cache.getStats ? this.cache.getStats() : {};
    
    return {
      ...stats,
      advanced: {
        ...this.stats,
        hitRate: this.stats.hits + this.stats.misses > 0 
          ? ((this.stats.hits / (this.stats.hits + this.stats.misses)) * 100).toFixed(2) + '%'
          : '0%',
        efficiency: this.stats.hits > 0 
          ? ((this.stats.hits / (this.stats.hits + this.stats.misses + this.stats.errors)) * 100).toFixed(2) + '%'
          : '0%',
        size: this.calculateCacheSize(),
        avgEntrySize: this.calculateAverageEntrySize()
      },
      keys: keys,
      keyCount: keys.length,
      memoryUsage: process.memoryUsage()
    };
  }

  generateKey(req) {
    try {
      const { originalUrl, method, user, query, params, body } = req;
      const userId = user?.id || 'guest';
      const userRole = user?.role || 'anonymous';
      
      // ÿ•ÿ≤ÿßŸÑÿ© query parameters ÿ∫Ÿäÿ± ÿßŸÑÿ∂ÿ±Ÿàÿ±Ÿäÿ©
      const filteredQuery = { ...query };
      delete filteredQuery._; // ÿ•ÿ≤ÿßŸÑÿ© timestamp
      delete filteredQuery.cache; // ÿ•ÿ≤ÿßŸÑÿ© ŸÖÿπÿßŸÖŸÑÿßÿ™ ÿßŸÑŸÉÿßÿ¥
      
      const queryStr = JSON.stringify(filteredQuery);
      const paramsStr = JSON.stringify(params);
      
      // ÿ•ŸÜÿ¥ÿßÿ° hash ŸÖŸÜ ÿßŸÑŸÄ body (ÿ®ÿ™ÿ¨ÿßŸáŸÑ ÿ®ÿπÿ∂ ÿßŸÑÿ≠ŸÇŸàŸÑ)
      let bodyHash = 'no-body';
      if (body && Object.keys(body).length > 0) {
        const filteredBody = { ...body };
        
        // ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑÿ≠ŸÇŸàŸÑ ÿßŸÑÿ≠ÿ≥ÿßÿ≥ÿ© ÿ£Ÿà ÿßŸÑŸÉÿ®Ÿäÿ±ÿ©
        delete filteredBody.password;
        delete filteredBody.confirmPassword;
        delete filteredBody.token;
        delete filteredBody.image;
        delete filteredBody.file;
        delete filteredBody.files;
        
        if (Object.keys(filteredBody).length > 0) {
          const crypto = require('crypto');
          bodyHash = crypto
            .createHash('md5')
            .update(JSON.stringify(filteredBody))
            .digest('hex')
            .substring(0, 8);
        }
      }
      
      // ÿ•ŸÜÿ¥ÿßÿ° ŸÖŸÅÿ™ÿßÿ≠ ÿ£ŸÉÿ´ÿ± ÿ™ŸÜÿ∏ŸäŸÖÿßŸã
      const keyParts = [
        method.toUpperCase(),
        originalUrl.split('?')[0], // ÿ•ÿ≤ÿßŸÑÿ© query string ŸÖŸÜ URL
        userId,
        userRole,
        queryStr !== '{}' ? queryStr : '',
        paramsStr !== '{}' ? paramsStr : '',
        bodyHash
      ].filter(part => part && part !== '' && part !== '{}');
      
      return keyParts.join(':');
    } catch (error) {
      console.error('‚ùå Cache key generation error:', error.message);
      // ŸÖŸÅÿ™ÿßÿ≠ ÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä ŸÅŸä ÿ≠ÿßŸÑÿ© ÿßŸÑÿÆÿ∑ÿ£
      return `fallback:${Date.now()}:${Math.random().toString(36).substr(2, 9)}`;
    }
  }

  async cacheWithFallback(key, fetchFunction, ttl = 300, fallbackFunction = null) {
    const cached = this.get(key);
    if (cached !== undefined && cached !== null) {
      return cached;
    }

    try {
      const data = await fetchFunction();
      this.set(key, data, ttl);
      return data;
    } catch (error) {
      businessLogger.error('Cache Fallback Error', { key, error: error.message });
      
      if (fallbackFunction) {
        try {
          const fallbackData = await fallbackFunction();
          businessLogger.warn('Using Cache Fallback', { key });
          return fallbackData;
        } catch (fallbackError) {
          throw new Error(`Primary and fallback both failed: ${error.message}`);
        }
      }
      
      throw error;
    }
  }

  invalidatePattern(pattern) {
    try {
      const keys = this.cache.keys();
      if (!pattern || pattern === '*') {
        return this.flush();
      }
      
      const regexPattern = pattern
        .replace(/\*/g, '.*')
        .replace(/\?/g, '.');
      
      const regex = new RegExp(`^${regexPattern}$`, 'i');
      const matchedKeys = keys.filter(key => regex.test(key));
      
      matchedKeys.forEach(key => this.del(key));
      this.stats.invalidations += matchedKeys.length;
      
      businessLogger.debug('Cache Pattern Invalidation', { 
        pattern, 
        matchedKeys: matchedKeys.length,
        keys: matchedKeys 
      });
      
      return matchedKeys.length;
    } catch (error) {
      this.stats.errors++;
      businessLogger.error('Cache Pattern Invalidation Error', { pattern, error: error.message });
      return 0;
    }
  }

  clearByPattern(pattern) {
    return this.invalidatePattern(pattern);
  }

  getCacheInfo() {
    const total = this.stats.hits + this.stats.misses;
    return {
      keys: this.cache.keys().length,
      hits: this.stats.hits,
      misses: this.stats.misses,
      sets: this.stats.sets,
      deletes: this.stats.deletes,
      hitRate: total > 0 ? ((this.stats.hits / total) * 100).toFixed(2) + '%' : '0%',
      invalidationCount: this.stats.invalidations,
      errorCount: this.stats.errors,
      size: this.calculateCacheSize(),
      avgEntrySize: this.calculateAverageEntrySize()
    };
  }

  smartCleanup(minHits = 2, maxAgeHours = 24) {
    const keys = this.cache.keys();
    const now = Date.now();
    const maxAgeMs = maxAgeHours * 60 * 60 * 1000;
    
    let cleaned = 0;
    
    keys.forEach(key => {
      try {
        const ttl = this.cache.getTtl(key);
        if (ttl) {
          const age = now - (ttl - (this.cache.options.stdTTL * 1000));
          const isOld = age > maxAgeMs;
          
          if (isOld) {
            this.del(key);
            cleaned++;
          }
        }
      } catch (error) {
        console.error(`Error checking key ${key}:`, error.message);
      }
    });
    
    businessLogger.info('Cache Smart Cleanup', { cleaned, totalKeys: keys.length });
    return cleaned;
  }

  calculateCacheSize() {
    try {
      const keys = this.cache.keys();
      let totalSize = 0;
      
      keys.forEach(key => {
        const value = this.cache.get(key);
        if (value) {
          try {
            totalSize += Buffer.byteLength(JSON.stringify(value), 'utf8');
          } catch (error) {
            // ÿ™ÿ¨ÿßŸáŸÑ ÿßŸÑÿ£ÿÆÿ∑ÿßÿ° ŸÅŸä ÿ≠ÿ≥ÿßÿ® ÿßŸÑÿ≠ÿ¨ŸÖ
          }
        }
      });
      
      return {
        bytes: totalSize,
        kilobytes: (totalSize / 1024).toFixed(2),
        megabytes: (totalSize / 1024 / 1024).toFixed(2)
      };
    } catch (error) {
      return { bytes: 0, kilobytes: '0.00', megabytes: '0.00' };
    }
  }

  calculateAverageEntrySize() {
    const keys = this.cache.keys();
    if (keys.length === 0) return 0;
    
    const sizeInfo = this.calculateCacheSize();
    return Math.round(sizeInfo.bytes / keys.length);
  }

  // ÿØÿßŸÑÿ© ŸÖÿ≥ÿßÿπÿØÿ© ÿ¨ÿØŸäÿØÿ©: ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿµÿ≠ÿ© ÿßŸÑŸÖŸÅÿ™ÿßÿ≠
  isValidKey(key) {
    if (!key || typeof key !== 'string') return false;
    if (key.length > 1000) return false; // ŸÖŸÅÿ™ÿßÿ≠ ÿ∑ŸàŸäŸÑ ÿ¨ÿØÿßŸã
    if (key.includes('\n') || key.includes('\r')) return false; // ÿ£ÿ≠ÿ±ŸÅ ÿ∫Ÿäÿ± ŸÖÿ≥ŸÖŸàÿ≠ÿ©
    return true;
  }

  // ÿØÿßŸÑÿ© ŸÖÿ≥ÿßÿπÿØÿ© ÿ¨ÿØŸäÿØÿ©: ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑŸÉÿßÿ¥ ÿßŸÑŸÇÿØŸäŸÖ
  cleanupOldCache(maxAgeMinutes = 60) {
    const keys = this.cache.keys();
    const now = Date.now();
    const maxAgeMs = maxAgeMinutes * 60 * 1000;
    
    let cleaned = 0;
    
    keys.forEach(key => {
      try {
        const ttl = this.cache.getTtl(key);
        if (ttl) {
          const age = now - (ttl - (this.cache.options.stdTTL * 1000));
          if (age > maxAgeMs) {
            this.del(key);
            cleaned++;
          }
        }
      } catch (error) {
        // ÿ™ÿ¨ÿßŸáŸÑ ÿßŸÑÿ£ÿÆÿ∑ÿßÿ°
      }
    });
    
    return cleaned;
  }
}

module.exports = new CacheService();
</file>

<file path="src/utils/logger.util.js">
const winston = require('winston');
const { combine, timestamp, printf, colorize, errors } = winston.format;

// ÿ™ŸÜÿ≥ŸäŸÇ ÿßŸÑŸÄ logs
const logFormat = printf(({ level, message, timestamp, stack, ...meta }) => {
  let log = `${timestamp} [${level}]: ${message}`;
  
  if (stack) {
    log += `\n${stack}`;
  }
  
  if (Object.keys(meta).length > 0) {
    log += `\n${JSON.stringify(meta, null, 2)}`;
  }
  
  return log;
});

// ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑŸÄ logger
const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: combine(
    errors({ stack: true }),
    timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
    logFormat
  ),
  transports: [
    // logs ŸÑŸÑŸÄ console ŸÅŸä ÿßŸÑÿ™ÿ∑ŸàŸäÿ±
    new winston.transports.Console({
      format: combine(
        colorize(),
        logFormat
      )
    }),
    // logs ŸÑŸÑÿ£ÿÆÿ∑ÿßÿ° ŸÅŸä ŸÖŸÑŸÅ
    new winston.transports.File({ 
      filename: 'logs/error.log', 
      level: 'error',
      maxsize: 5242880, // 5MB
      maxFiles: 5
    }),
    // logs ŸÑŸÑŸÖÿπŸÑŸàŸÖÿßÿ™ ŸÅŸä ŸÖŸÑŸÅ
    new winston.transports.File({ 
      filename: 'logs/combined.log',
      maxsize: 5242880, // 5MB
      maxFiles: 5
    })
  ],
  // ÿπÿØŸÖ ÿ•ŸäŸÇÿßŸÅ ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ ÿπŸÜÿØ ÿ≠ÿØŸàÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑŸÄ logging
  exitOnError: false
});

// Middleware ŸÑŸÄ logging ÿ∑ŸÑÿ®ÿßÿ™ HTTP
const httpLogger = (req, res, next) => {
  const start = Date.now();
  
  res.on('finish', () => {
    const duration = Date.now() - start;
    const logData = {
      method: req.method,
      url: req.originalUrl,
      status: res.statusCode,
      duration: `${duration}ms`,
      ip: req.ip,
      userAgent: req.get('user-agent'),
      userId: req.user?.id || 'guest'
    };

    if (res.statusCode >= 400) {
      logger.error('HTTP Request Error', logData);
    } else if (res.statusCode >= 300) {
      logger.warn('HTTP Request Warning', logData);
    } else {
      logger.info('HTTP Request', logData);
    }
  });

  next();
};

// Middleware ŸÑŸÄ logging ÿßŸÑÿ£ÿÆÿ∑ÿßÿ°
const errorLogger = (error, req, res, next) => {
  logger.error('Unhandled Error', {
    message: error.message,
    stack: error.stack,
    url: req.originalUrl,
    method: req.method,
    ip: req.ip,
    userId: req.user?.id || 'guest'
  });

  next(error);
};

// ÿØÿßŸÑÿ© ŸÑŸÄ logging ÿßŸÑÿπŸÖŸÑŸäÿßÿ™ ÿßŸÑÿ™ÿ¨ÿßÿ±Ÿäÿ©
const businessLogger = {
  info: (action, data) => {
    logger.info(`Business Action: ${action}`, data);
  },
  warn: (action, data) => {
    logger.warn(`Business Warning: ${action}`, data);
  },
  error: (action, data) => {
    logger.error(`Business Error: ${action}`, data);
  },
  debug: (action, data) => {
    logger.debug(`Business Debug: ${action}`, data);
  }
};

module.exports = {
  logger,
  httpLogger,
  errorLogger,
  businessLogger
};
</file>

<file path="src/utils/pagination.util.js">
/**
 * üéØ ÿ£ÿØŸàÿßÿ™ ÿßŸÑŸÖÿ≥ÿßÿπÿØÿ© ŸÑŸÑÿ™ÿπÿßŸÖŸÑ ŸÖÿπ Pagination
 */

class PaginationUtils {
  /**
   * ÿ™ÿ≠ŸàŸäŸÑ query parameters ÿ•ŸÑŸâ options ŸÑŸÑŸÄ pagination
   */
  static getPaginationOptions(req) {
    const page = Math.max(1, parseInt(req.query.page) || 1);
    const limit = Math.min(100, Math.max(1, parseInt(req.query.limit) || 10));
    const skip = (page - 1) * limit;
    
    // ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ™ÿ±ÿ™Ÿäÿ® ÿßŸÑŸÅÿ±ÿ≤
    let sort = {};
    if (req.query.sortBy) {
      const sortOrder = req.query.sortOrder === 'desc' ? -1 : 1;
      sort[req.query.sortBy] = sortOrder;
    } else {
      sort = { createdAt: -1 }; // ÿßŸÑÿ™ÿ±ÿ™Ÿäÿ® ÿßŸÑÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä
    }
    
    // ÿßŸÑÿ®ÿ≠ÿ´ ÿßŸÑŸÜÿµŸä
    const search = req.query.search || '';
    const searchFields = req.query.searchFields ? req.query.searchFields.split(',') : [];
    
    return {
      page,
      limit,
      skip,
      sort,
      search,
      searchFields,
      filters: this.parseFilters(req.query),
    };
  }

  /**
   * ÿ™ÿ≠ŸàŸäŸÑ query filters ÿ•ŸÑŸâ ŸÉÿßÿ¶ŸÜ ŸÇÿßÿ®ŸÑ ŸÑŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ
   */
  static parseFilters(query) {
    const filters = {};
    
    // ŸÅŸÑÿ™ÿ±ÿ© ÿ≠ÿ≥ÿ® ÿßŸÑÿ≠ŸÇŸàŸÑ ÿßŸÑÿ®ÿ≥Ÿäÿ∑ÿ©
    Object.keys(query).forEach(key => {
      if (key.startsWith('filter[') && key.endsWith(']')) {
        const field = key.substring(7, key.length - 1);
        const value = query[key];
        
        if (value !== undefined && value !== '') {
          // ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑŸÇŸäŸÖ ÿßŸÑÿÆÿßÿµÿ©
          if (value === 'true' || value === 'false') {
            filters[field] = value === 'true';
          } else if (!isNaN(value) && value !== '') {
            filters[field] = Number(value);
          } else {
            filters[field] = value;
          }
        }
      }
    });

    // ŸÅŸÑÿ™ÿ±ÿ© ÿßŸÑŸÜÿ∑ÿßŸÇÿßÿ™ (between)
    if (query.minPrice || query.maxPrice) {
      filters.price = {};
      if (query.minPrice) filters.price.$gte = Number(query.minPrice);
      if (query.maxPrice) filters.price.$lte = Number(query.maxPrice);
    }

    if (query.minDate || query.maxDate) {
      filters.createdAt = {};
      if (query.minDate) filters.createdAt.$gte = new Date(query.minDate);
      if (query.maxDate) filters.createdAt.$lte = new Date(query.maxDate);
    }

    // ŸÅŸÑÿ™ÿ±ÿ© ÿßŸÑŸÖÿµŸÅŸàŸÅÿßÿ™ (array)
    if (query.tags) {
      filters.tags = { $in: query.tags.split(',') };
    }

    if (query.categories) {
      filters.category = { $in: query.categories.split(',') };
    }

    return filters;
  }

  /**
   * ÿ•ŸÜÿ¥ÿßÿ° ÿßÿ≥ÿ™ÿ¨ÿßÿ®ÿ© pagination ŸÖŸàÿ≠ÿØÿ©
   */
  static createPaginationResponse(data, total, paginationOptions, extra = {}) {
    const { page, limit } = paginationOptions;
    const totalPages = Math.ceil(total / limit);
    
    return {
      success: true,
      data: data,
      pagination: {
        page,
        limit,
        total,
        totalPages,
        hasNextPage: page < totalPages,
        hasPrevPage: page > 1,
        nextPage: page < totalPages ? page + 1 : null,
        prevPage: page > 1 ? page - 1 : null,
      },
      ...extra,
      timestamp: new Date(),
    };
  }

  /**
   * ÿ®ŸÜÿßÿ° ÿ±Ÿàÿßÿ®ÿ∑ pagination ŸÑŸÑŸÄ HATEOAS
   */
  static buildPaginationLinks(req, paginationData) {
    const { page, limit, totalPages } = paginationData;
    const baseUrl = `${req.protocol}://${req.get('host')}${req.baseUrl}${req.path}`;
    
    const links = {
      self: `${baseUrl}?page=${page}&limit=${limit}`,
      first: `${baseUrl}?page=1&limit=${limit}`,
      last: `${baseUrl}?page=${totalPages}&limit=${limit}`,
    };

    if (page < totalPages) {
      links.next = `${baseUrl}?page=${page + 1}&limit=${limit}`;
    }

    if (page > 1) {
      links.prev = `${baseUrl}?page=${page - 1}&limit=${limit}`;
    }

    return links;
  }

  /**
   * ÿ•ŸÜÿ¥ÿßÿ° ÿßÿ≥ÿ™ÿπŸÑÿßŸÖ ÿ®ÿ≠ÿ´ ŸÜÿµŸä
   */
  static buildSearchQuery(search, searchFields = []) {
    if (!search || searchFields.length === 0) return {};
    
    const searchQuery = {
      $or: searchFields.map(field => ({
        [field]: { $regex: search, $options: 'i' }
      }))
    };
    
    return searchQuery;
  }

  /**
   * ŸÖÿπÿßŸÑÿ¨ÿ© aggregation pipeline ŸÑŸÑŸÄ pagination
   */
  static getAggregationPipeline(paginationOptions, matchStage = {}) {
    const { skip, limit, sort } = paginationOptions;
    
    return [
      { $match: matchStage },
      { $sort: sort },
      { $skip: skip },
      { $limit: limit },
    ];
  }

  /**
   * ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿµÿ≠ÿ© ŸÖÿπÿßŸÖŸÑÿßÿ™ pagination
   */
  static validatePaginationParams(req, res, next) {
    const page = parseInt(req.query.page);
    const limit = parseInt(req.query.limit);
    
    if (page && (isNaN(page) || page < 1)) {
      return res.status(400).json({
        success: false,
        message: 'Page must be a positive number',
      });
    }
    
    if (limit && (isNaN(limit) || limit < 1 || limit > 100)) {
      return res.status(400).json({
        success: false,
        message: 'Limit must be between 1 and 100',
      });
    }
    
    next();
  }
}

module.exports = PaginationUtils;
</file>

<file path="tests/auth.test.js">
const request = require('supertest');
const app = require('../src/app');
const User = require('../src/models/user.model');

describe('Authentication API', () => {
  describe('POST /api/auth/register', () => {
    it('should register a new user', async () => {
      const userData = {
        name: 'Test User',
        phone: '+1234567890',
        password: 'password123'
      };

      const response = await request(app)
        .post('/api/auth/register')
        .send(userData)
        .expect(201);

      expect(response.body).toHaveProperty('success', true);
      expect(response.body.data.user).toHaveProperty('phone', userData.phone);
    });

    it('should not register with duplicate phone', async () => {
      const userData = {
        name: 'Test User',
        phone: '+1234567890',
        password: 'password123'
      };

      // Create first user
      await request(app).post('/api/auth/register').send(userData);

      // Try to create duplicate
      const response = await request(app)
        .post('/api/auth/register')
        .send(userData)
        .expect(400);

      expect(response.body).toHaveProperty('success', false);
    });
  });

  describe('POST /api/auth/login', () => {
    beforeEach(async () => {
      await User.create({
        name: 'Test User',
        phone: '+1234567890',
        password: '$2a$10$N9qo8uLOickgx2ZMRZoMy.MrqK.3.6Z6C.YGVmZ7yT7K7Ql.9.9mW' // password123
      });
    });

    it('should login with correct credentials', async () => {
      const response = await request(app)
        .post('/api/auth/login')
        .send({
          phone: '+1234567890',
          password: 'password123'
        })
        .expect(200);

      expect(response.body).toHaveProperty('success', true);
      expect(response.body).toHaveProperty('token');
    });

    it('should not login with wrong password', async () => {
      const response = await request(app)
        .post('/api/auth/login')
        .send({
          phone: '+1234567890',
          password: 'wrongpassword'
        })
        .expect(400);

      expect(response.body).toHaveProperty('success', false);
    });
  });
});
</file>

<file path="tests/cache.test.js">
// tests/cache.test.js
const cache = require('../src/utils/cache.util');

describe('Cache Service', () => {
  beforeEach(() => {
    cache.flush();
  });

  test('should set and get value', async () => {
    cache.set('test-key', 'test-value');
    const value = cache.get('test-key');
    expect(value).toBe('test-value');
  });

  test('should invalidate by pattern', async () => {
    cache.set('user:1:profile', { name: 'John' });
    cache.set('user:2:profile', { name: 'Jane' });
    cache.set('order:123', { id: 123 });
    
    const removed = cache.invalidatePattern('user:*');
    expect(removed).toBe(2);
    expect(cache.get('user:1:profile')).toBeUndefined();
    expect(cache.get('order:123')).toBeDefined();
  });
});

// tests/validation.test.js
const { validateRegister } = require('../src/middlewares/validation.middleware');

describe('Validation Middleware', () => {
  test('should validate register data correctly', () => {
    const req = {
      body: {
        name: 'John',
        phone: '+1234567890',
        password: 'password123',
        email: 'john@example.com'
      }
    };
    
    const res = {};
    const next = jest.fn();
    
    validateRegister(req, res, next);
    expect(next).toHaveBeenCalled();
  });
});
</file>

<file path="tests/setup.js">
const mongoose = require('mongoose');
const { MongoMemoryServer } = require('mongodb-memory-server');

let mongoServer;

beforeAll(async () => {
  mongoServer = await MongoMemoryServer.create();
  const mongoUri = mongoServer.getUri();
  
  await mongoose.connect(mongoUri, {
    useNewUrlParser: true,
    useUnifiedTopology: true
  });
});

afterAll(async () => {
  await mongoose.disconnect();
  await mongoServer.stop();
});

afterEach(async () => {
  const collections = mongoose.connection.collections;
  
  for (const key in collections) {
    const collection = collections[key];
    await collection.deleteMany();
  }
});
</file>

<file path="src/controllers/aggregate.controller.js">
const User = require('../models/user.model');
const Address = require('../models/address.model');
const Order = require('../models/order.model');
const Restaurant = require('../models/restaurant.model');
const RestaurantAddress = require('../models/restaurantAddress.model');
const Review = require('../models/review.model');
const Item = require('../models/item.model');
const DriverLocation = require('../models/driverLocation.model');
const cache = require('../utils/cache.util');
const PaginationUtils = require('../utils/pagination.util');

/**
 * 1Ô∏è‚É£ ÿ®ŸäÿßŸÜÿßÿ™ ŸÑŸàÿ≠ÿ© ÿ™ÿ≠ŸÉŸÖ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÖÿπ ÿßŸÑŸÉÿßÿ¥
 * GET /api/aggregate/dashboard
 */
exports.getDashboardData = async (req, res) => {
  try {
    const userId = req.user.id;
    const cacheKey = `dashboard:${userId}`;
    
    const cachedData = cache.get(cacheKey);
    if (cachedData) {
      console.log('üìä Serving dashboard from cache');
      return res.json({
        ...cachedData,
        cached: true,
        timestamp: new Date()
      });
    }

    console.log('üîÑ Fetching dashboard from database');
    
    const [
      user,
      addresses,
      orders,
      restaurants,
      reviews,
      unreadNotifications
    ] = await Promise.all([
      User.findById(userId)
        .select('name phone role image email stats isVerified lastLogin')
        .lean(),
      
      Address.find({ user: userId })
        .select('label addressLine city isDefault')
        .sort({ isDefault: -1, createdAt: -1 })
        .limit(5)
        .lean(),
      
      Order.find({ user: userId })
        .populate('driver', 'name phone image')
        .populate('restaurant', 'name image')
        .populate('pickupAddress', 'addressLine city')
        .populate('deliveryAddress', 'addressLine city')
        .select('status totalPrice createdAt items')
        .sort({ createdAt: -1 })
        .limit(5)
        .lean(),
      
      Restaurant.find({ isOpen: true })
        .select('name image description type averageRating deliveryFee')
        .sort({ averageRating: -1 })
        .limit(10)
        .lean(),
      
      Review.find({ user: userId })
        .populate('restaurant', 'name image')
        .select('rating comment createdAt')
        .sort({ createdAt: -1 })
        .limit(5)
        .lean(),
      
      // ÿ¨ŸÑÿ® ÿπÿØÿØ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿ∫Ÿäÿ± ÿßŸÑŸÖŸÇÿ±Ÿàÿ°ÿ©
      (async () => {
        const Notification = require('../models/notification.model');
        return await Notification.countDocuments({
          user: userId,
          status: 'unread',
          expiresAt: { $gt: new Date() }
        });
      })()
    ]);

    const responseData = {
      success: true,
      data: {
        user,
        addresses,
        recentOrders: orders,
        topRestaurants: restaurants,
        recentReviews: reviews,
        stats: {
          totalOrders: user?.stats?.totalOrders || 0,
          totalSpent: user?.stats?.totalSpent || 0,
          favoriteRestaurants: restaurants.length,
          unreadNotifications: unreadNotifications || 0,
          addressesCount: addresses.length
        }
      },
      cached: false,
      timestamp: new Date()
    };

    cache.set(cacheKey, responseData, 180);
    
    res.json(responseData);
  } catch (error) {
    console.error('‚ùå Dashboard aggregation error:', error.message);
    res.status(500).json({ 
      success: false, 
      message: 'Failed to load dashboard data',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

/**
 * üîÑ ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿßŸÑŸÖÿ∑ÿßÿπŸÖ ŸÖÿπ Pagination
 * GET /api/aggregate/restaurants
 */
exports.getRestaurantsPaginated = async (req, res) => {
  try {
    const paginationOptions = PaginationUtils.getPaginationOptions(req);
    const { skip, limit, sort, search, filters } = paginationOptions;
    
    let query = { isOpen: true };
    
    if (search) {
      query.$or = [
        { name: { $regex: search, $options: 'i' } },
        { description: { $regex: search, $options: 'i' } },
        { tags: { $regex: search, $options: 'i' } },
      ];
    }
    
    if (filters.type) {
      query.type = filters.type;
    }
    
    if (filters.tags) {
      query.tags = { $in: filters.tags };
    }
    
    if (filters.minRating) {
      query.averageRating = { $gte: Number(filters.minRating) };
    }

    const cacheKey = `restaurants:${JSON.stringify(query)}:${skip}:${limit}:${JSON.stringify(sort)}`;
    const cachedData = cache.get(cacheKey);
    
    if (cachedData) {
      console.log('üìä Serving paginated restaurants from cache');
      return res.json({
        ...cachedData,
        cached: true,
      });
    }

    console.log(`üîÑ Fetching restaurants (page ${paginationOptions.page})`);
    
    const [restaurants, total] = await Promise.all([
      Restaurant.find(query)
        .select('name image description type averageRating deliveryFee estimatedDeliveryTime tags openingHours')
        .populate('createdBy', 'name phone')
        .sort(sort)
        .skip(skip)
        .limit(limit)
        .lean(),
      
      Restaurant.countDocuments(query),
    ]);

    const restaurantsWithAddresses = await Promise.all(
      restaurants.map(async (restaurant) => {
        const addresses = await RestaurantAddress.find({
          restaurant: restaurant._id,
        })
        .select('addressLine city latitude longitude')
        .limit(3)
        .lean();
        
        const itemsCount = await Item.countDocuments({
          restaurant: restaurant._id,
          isAvailable: true
        });
        
        const reviewsCount = await Review.countDocuments({
          restaurant: restaurant._id
        });
        
        return {
          ...restaurant,
          addresses,
          stats: {
            itemsCount,
            reviewsCount,
            addressesCount: addresses.length
          }
        };
      })
    );

    const responseData = PaginationUtils.createPaginationResponse(
      restaurantsWithAddresses,
      total,
      paginationOptions,
      {
        searchTerm: search || null,
        filtersApplied: Object.keys(filters).length > 0 ? filters : null,
      }
    );

    cache.set(cacheKey, responseData, 120);
    
    responseData.links = PaginationUtils.buildPaginationLinks(req, responseData.pagination);
    
    res.json(responseData);
  } catch (error) {
    console.error('‚ùå Paginated restaurants error:', error.message);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch restaurants',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

/**
 * üîÑ ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿπŸÜÿßÿµÿ± ÿßŸÑŸÖÿ∑ÿπŸÖ ŸÖÿπ Pagination
 * GET /api/aggregate/items
 */
exports.getItemsPaginated = async (req, res) => {
  try {
    const paginationOptions = PaginationUtils.getPaginationOptions(req);
    const { skip, limit, sort, filters } = paginationOptions;
    
    let query = { isAvailable: true };
    
    if (filters.restaurant) {
      query.restaurant = filters.restaurant;
    }
    
    if (filters.category) {
      query.category = filters.category;
    }
    
    if (filters.minPrice || filters.maxPrice) {
      query.price = {};
      if (filters.minPrice) query.price.$gte = Number(filters.minPrice);
      if (filters.maxPrice) query.price.$lte = Number(filters.maxPrice);
    }
    
    if (filters.tags) {
      query.tags = { $in: filters.tags };
    }
    
    if (filters.isVegetarian !== undefined) {
      query.isVegetarian = filters.isVegetarian === 'true';
    }
    
    if (filters.isVegan !== undefined) {
      query.isVegan = filters.isVegan === 'true';
    }

    const cacheKey = `items:${JSON.stringify(query)}:${skip}:${limit}:${JSON.stringify(sort)}`;
    const cachedData = cache.get(cacheKey);
    
    if (cachedData) {
      console.log('üçΩÔ∏è Serving paginated items from cache');
      return res.json({
        ...cachedData,
        cached: true,
      });
    }

    const [items, total] = await Promise.all([
      Item.find(query)
        .populate('restaurant', 'name image type averageRating')
        .sort(sort)
        .skip(skip)
        .limit(limit)
        .lean(),
      
      Item.countDocuments(query),
    ]);

    const categories = await Item.distinct('category', query);
    
    const priceStats = await Item.aggregate([
      { $match: query },
      {
        $group: {
          _id: null,
          minPrice: { $min: '$price' },
          maxPrice: { $max: '$price' },
          avgPrice: { $avg: '$price' }
        }
      }
    ]);

    const responseData = PaginationUtils.createPaginationResponse(
      items,
      total,
      paginationOptions,
      {
        categories,
        priceRange: priceStats[0] || { minPrice: 0, maxPrice: 0, avgPrice: 0 },
        totalRestaurants: await Item.distinct('restaurant', query).then(ids => ids.length)
      }
    );

    cache.set(cacheKey, responseData, 180);
    responseData.links = PaginationUtils.buildPaginationLinks(req, responseData.pagination);
    
    res.json(responseData);
  } catch (error) {
    console.error('‚ùå Paginated items error:', error.message);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch items',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

/**
 * üîÑ ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿßŸÑÿ∑ŸÑÿ®ÿßÿ™ ŸÖÿπ Pagination (ŸÑŸÑÿ£ÿØŸÖŸÜ)
 * GET /api/aggregate/orders/admin
 */
exports.getOrdersPaginatedAdmin = async (req, res) => {
  try {
    if (req.user.role !== 'admin') {
      return res.status(403).json({
        success: false,
        message: 'Access denied. Admin only.',
      });
    }

    const paginationOptions = PaginationUtils.getPaginationOptions(req);
    const { skip, limit, sort, filters } = paginationOptions;
    
    let query = {};
    
    if (filters.status) {
      query.status = filters.status;
    }
    
    if (filters.restaurant) {
      query.restaurant = filters.restaurant;
    }
    
    if (filters.driver) {
      query.driver = filters.driver;
    }
    
    if (filters.user) {
      query.user = filters.user;
    }
    
    if (filters.minDate || filters.maxDate) {
      query.createdAt = {};
      if (filters.minDate) query.createdAt.$gte = new Date(filters.minDate);
      if (filters.maxDate) query.createdAt.$lte = new Date(filters.maxDate);
    }

    const cacheKey = `orders:admin:${JSON.stringify(query)}:${skip}:${limit}`;
    const cachedData = cache.get(cacheKey);
    
    if (cachedData) {
      console.log('üì¶ Serving admin orders from cache');
      return res.json({
        ...cachedData,
        cached: true,
      });
    }

    const [orders, total] = await Promise.all([
      Order.find(query)
        .populate('user', 'name phone email')
        .populate('driver', 'name phone')
        .populate('restaurant', 'name image')
        .populate('pickupAddress', 'addressLine city')
        .populate('deliveryAddress', 'addressLine city')
        .sort(sort)
        .skip(skip)
        .limit(limit)
        .lean(),
      
      Order.countDocuments(query),
    ]);

    const stats = await Order.aggregate([
      { $match: query },
      {
        $group: {
          _id: '$status',
          count: { $sum: 1 },
          totalRevenue: { $sum: '$totalPrice' },
          avgOrderValue: { $avg: '$totalPrice' }
        },
      },
    ]);

    const totalRevenue = stats.reduce((sum, stat) => sum + stat.totalRevenue, 0);
    const totalOrders = stats.reduce((sum, stat) => sum + stat.count, 0);

    const responseData = PaginationUtils.createPaginationResponse(
      orders,
      total,
      paginationOptions,
      {
        stats: stats.reduce((acc, curr) => {
          acc[curr._id] = {
            count: curr.count,
            revenue: curr.totalRevenue,
            avgValue: curr.avgOrderValue
          };
          return acc;
        }, {}),
        summary: {
          totalRevenue,
          totalOrders,
          avgOrderValue: totalOrders > 0 ? totalRevenue / totalOrders : 0
        }
      }
    );

    cache.set(cacheKey, responseData, 60);
    responseData.links = PaginationUtils.buildPaginationLinks(req, responseData.pagination);
    
    res.json(responseData);
  } catch (error) {
    console.error('‚ùå Paginated orders admin error:', error.message);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch orders',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

/**
 * 2Ô∏è‚É£ ÿ™ŸÅÿßÿµŸäŸÑ ŸÖÿ∑ÿπŸÖ ŸÉÿßŸÖŸÑÿ© ŸÖÿπ ÿßŸÑŸÉÿßÿ¥
 * GET /api/aggregate/restaurants/:id/full
 */
exports.getRestaurantDetails = async (req, res) => {
  try {
    const { id } = req.params;
    
    if (!require('mongoose').Types.ObjectId.isValid(id)) {
      return res.status(400).json({ 
        success: false, 
        message: 'ŸÖÿπÿ±ŸêŸëŸÅ ÿßŸÑŸÖÿ∑ÿπŸÖ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠' 
      });
    }
    
    const cacheKey = `restaurant:full:${id}`;
    
    const cachedData = cache.get(cacheKey);
    if (cachedData) {
      console.log(`üè™ Serving restaurant ${id} from cache`);
      return res.json({
        ...cachedData,
        cached: true
      });
    }

    console.log(`üîÑ Fetching restaurant ${id} from database`);
    
    const [
      restaurant,
      addresses,
      reviews,
      items,
      categories
    ] = await Promise.all([
      Restaurant.findById(id)
        .populate('createdBy', 'name phone email')
        .lean(),
      
      RestaurantAddress.find({ restaurant: id })
        .select('addressLine city latitude longitude')
        .lean(),
      
      Review.find({ restaurant: id })
        .populate('user', 'name image')
        .select('rating comment createdAt')
        .sort({ createdAt: -1 })
        .limit(10)
        .lean(),
      
      Item.find({ restaurant: id, isAvailable: true })
        .select('name price image description category ingredients preparationTime')
        .sort({ category: 1, name: 1 })
        .lean(),
      
      Item.distinct('category', { restaurant: id, isAvailable: true })
    ]);

    if (!restaurant) {
      return res.status(404).json({ 
        success: false, 
        message: 'ÿßŸÑŸÖÿ∑ÿπŸÖ ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ' 
      });
    }

    const reviewStats = await Review.aggregate([
      { $match: { restaurant: restaurant._id } },
      {
        $group: {
          _id: null,
          averageRating: { $avg: '$rating' },
          totalReviews: { $sum: 1 },
          ratingDistribution: {
            $push: {
              rating: '$rating',
              count: 1
            }
          }
        }
      }
    ]);

    const responseData = {
      success: true,
      data: {
        restaurant,
        addresses,
        reviews,
        items,
        categories,
        stats: {
          reviewCount: reviews.length,
          itemCount: items.length,
          addressCount: addresses.length,
          averageRating: reviewStats[0]?.averageRating?.toFixed(1) || 0,
          totalReviews: reviewStats[0]?.totalReviews || 0
        }
      },
      cached: false,
      timestamp: new Date()
    };

    cache.set(cacheKey, responseData, 300);
    
    res.json(responseData);
  } catch (error) {
    console.error('‚ùå Restaurant details error:', error.message);
    res.status(500).json({ 
      success: false, 
      message: 'Failed to fetch restaurant details',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

/**
 * 3Ô∏è‚É£ ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑÿ∑ŸÑÿ® ŸÖÿπ ÿßŸÑÿ™ÿ™ÿ®ÿπ (ŸÉÿßÿ¥ ÿ£ŸÇÿµÿ± ŸÖÿØÿ©)
 * GET /api/aggregate/orders/:id/full
 */
exports.getOrderWithTracking = async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user.id;
    
    if (!require('mongoose').Types.ObjectId.isValid(id)) {
      return res.status(400).json({ 
        success: false, 
        message: 'ŸÖÿπÿ±ŸêŸëŸÅ ÿßŸÑÿ∑ŸÑÿ® ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠' 
      });
    }
    
    const cacheKey = `order:tracking:${id}:${userId}`;
    
    const cachedData = cache.get(cacheKey);
    if (cachedData) {
      console.log(`üì¶ Serving order ${id} tracking from cache`);
      return res.json({
        ...cachedData,
        cached: true
      });
    }

    console.log(`üîÑ Fetching order ${id} tracking from database`);
    
    const order = await Order.findOne({ _id: id, user: userId })
      .populate('user', 'name phone image email')
      .populate('driver', 'name phone image rating totalDeliveries')
      .populate('restaurant', 'name image phone addressLine')
      .populate('pickupAddress', 'label addressLine city latitude longitude')
      .populate('deliveryAddress', 'label addressLine city latitude longitude')
      .lean();

    if (!order) {
      return res.status(404).json({ 
        success: false, 
        message: 'ÿßŸÑÿ∑ŸÑÿ® ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ ÿ£Ÿà ŸÑŸäÿ≥ ŸÑÿØŸäŸÉ ÿµŸÑÿßÿ≠Ÿäÿ© ÿßŸÑŸàÿµŸàŸÑ' 
      });
    }

    let driverLocation = null;
    let locationHistory = [];
    
    if (order.driver) {
      [driverLocation, locationHistory] = await Promise.all([
        DriverLocation.findOne({
          driver: order.driver._id,
          order: order._id
        })
        .sort({ createdAt: -1 })
        .lean(),
        
        DriverLocation.find({
          driver: order.driver._id,
          order: order._id,
          createdAt: { $gte: new Date(Date.now() - 30 * 60 * 1000) } // ÿ¢ÿÆÿ± 30 ÿØŸÇŸäŸÇÿ©
        })
        .select('location createdAt')
        .sort({ createdAt: 1 })
        .limit(20)
        .lean()
      ]);
    }

    const orderTimeline = [
      {
        status: 'created',
        title: 'ÿ™ŸÖ ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ∑ŸÑÿ®',
        description: 'ÿ™ŸÖ ÿßÿ≥ÿ™ŸÑÿßŸÖ ÿ∑ŸÑÿ®ŸÉ ÿ®ŸÜÿ¨ÿßÿ≠',
        timestamp: order.createdAt,
        completed: true
      },
      {
        status: 'accepted',
        title: 'ÿ™ŸÖ ŸÇÿ®ŸàŸÑ ÿßŸÑÿ∑ŸÑÿ®',
        description: order.status === 'pending' ? 'ŸÇŸäÿØ ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ±' : 'ÿ™ŸÖ ÿßŸÑŸÇÿ®ŸàŸÑ',
        timestamp: order.status === 'pending' ? null : order.updatedAt,
        completed: order.status !== 'pending'
      },
      {
        status: 'picked',
        title: 'ÿ™ŸÖ ÿßÿ≥ÿ™ŸÑÿßŸÖ ÿßŸÑÿ∑ŸÑÿ®',
        description: order.status === 'picked' || order.status === 'delivered' ? 'ÿ™ŸÖ ÿßŸÑÿßÿ≥ÿ™ŸÑÿßŸÖ' : 'ŸÇŸäÿØ ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ±',
        timestamp: order.status === 'picked' || order.status === 'delivered' ? order.updatedAt : null,
        completed: order.status === 'picked' || order.status === 'delivered'
      },
      {
        status: 'delivered',
        title: 'ÿ™ŸÖ ÿßŸÑÿ™ŸàÿµŸäŸÑ',
        description: order.status === 'delivered' ? 'ÿ™ŸÖ ÿßŸÑÿ™ŸàÿµŸäŸÑ ÿ®ŸÜÿ¨ÿßÿ≠' : 'ŸÇŸäÿØ ÿßŸÑÿ™ŸàÿµŸäŸÑ',
        timestamp: order.status === 'delivered' ? order.updatedAt : null,
        completed: order.status === 'delivered'
      }
    ];

    const responseData = {
      success: true,
      data: {
        order,
        tracking: {
          currentLocation: driverLocation,
          locationHistory,
          isActive: !!driverLocation,
          lastUpdated: driverLocation?.createdAt || null,
          estimatedDeliveryTime: this.calculateETA(order)
        },
        timeline: orderTimeline,
        metadata: {
          hasDriver: !!order.driver,
          status: order.status,
          statusText: this.getStatusText(order.status),
          canCancel: ['pending', 'accepted'].includes(order.status),
          canContactDriver: !!order.driver && ['accepted', 'picked'].includes(order.status)
        }
      },
      cached: false,
      timestamp: new Date()
    };

    cache.set(cacheKey, responseData, 30);
    
    res.json(responseData);
  } catch (error) {
    console.error('‚ùå Order tracking error:', error.message);
    res.status(500).json({ 
      success: false, 
      message: 'Failed to fetch order details',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

/**
 * 4Ô∏è‚É£ ÿ®ŸäÿßŸÜÿßÿ™ ÿµŸÅÿ≠ÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ© ŸÖÿπ ŸÉÿßÿ¥ ÿ£ÿ∑ŸàŸÑ
 * GET /api/aggregate/home
 */
exports.getHomeData = async (req, res) => {
  try {
    const cacheKey = 'home:data';
    
    const responseData = await cache.cacheWithFallback(
      cacheKey,
      async () => {
        console.log('üè† Fetching home data from database');
        
        const [
          topRestaurants,
          featuredItems,
          recentReviews,
          categories,
          stats
        ] = await Promise.all([
          Restaurant.find({ isOpen: true })
            .sort({ averageRating: -1, ratingsCount: -1 })
            .limit(8)
            .select('name image averageRating type deliveryFee estimatedDeliveryTime')
            .lean(),
          
          Item.find({ isAvailable: true })
            .populate('restaurant', 'name image')
            .sort({ createdAt: -1 })
            .limit(12)
            .select('name price image restaurant description category')
            .lean(),
          
          Review.find()
            .populate('user', 'name image')
            .populate('restaurant', 'name image')
            .select('rating comment createdAt')
            .sort({ createdAt: -1 })
            .limit(5)
            .lean(),
          
          Restaurant.distinct('type', { isOpen: true }),
          
          Promise.all([
            Restaurant.countDocuments({ isOpen: true }),
            Item.countDocuments({ isAvailable: true }),
            Order.countDocuments({ status: 'delivered' }),
            Review.countDocuments()
          ])
        ]);

        return {
          success: true,
          data: {
            topRestaurants,
            featuredItems,
            recentReviews,
            categories,
            stats: {
              restaurantCount: stats[0],
              itemCount: stats[1],
              ordersDelivered: stats[2],
              reviewsCount: stats[3]
            },
            promotions: [
              {
                id: 1,
                title: 'ÿÆÿµŸÖ 20% ÿπŸÑŸâ ÿ£ŸàŸÑ ÿ∑ŸÑÿ®',
                description: 'ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑŸÉŸàÿØ WELCOME20',
                validUntil: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
                image: 'https://res.cloudinary.com/demo/image/upload/v1633456789/promotion1.jpg'
              },
              {
                id: 2,
                title: 'ÿ™ŸàÿµŸäŸÑ ŸÖÿ¨ÿßŸÜŸä',
                description: 'ŸÑŸÑÿ∑ŸÑÿ®ÿßÿ™ ŸÅŸàŸÇ 100 ÿØÿ±ŸáŸÖ',
                validUntil: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
                image: 'https://res.cloudinary.com/demo/image/upload/v1633456789/promotion2.jpg'
              }
            ]
          },
          cached: false,
          timestamp: new Date()
        };
      },
      600
    );

    res.json(responseData);
  } catch (error) {
    console.error('‚ùå Home data error:', error.message);
    res.status(500).json({ 
      success: false, 
      message: 'Failed to load home page data',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

/**
 * 5Ô∏è‚É£ ÿ•ÿØÿßÿ±ÿ© ÿßŸÑŸÉÿßÿ¥ ŸÖŸÜ ÿÆŸÑÿßŸÑ API
 * POST /api/aggregate/cache/clear
 */
exports.clearCache = async (req, res) => {
  try {
    if (req.user.role !== 'admin') {
      return res.status(403).json({
        success: false,
        message: 'Access denied. Admin only.'
      });
    }

    const { pattern, key } = req.body;
    
    let result;
    
    if (key) {
      const deleted = cache.del(key);
      result = {
        action: 'delete_key',
        key,
        deletedCount: deleted
      };
    } else if (pattern) {
      const clearedCount = cache.invalidatePattern(pattern);
      result = {
        action: 'clear_pattern',
        pattern,
        clearedCount
      };
    } else {
      const clearedKeys = cache.flush();
      result = {
        action: 'flush_all',
        clearedKeys
      };
    }
    
    res.json({
      success: true,
      message: 'Cache cleared successfully',
      data: result,
      timestamp: new Date()
    });
  } catch (error) {
    console.error('‚ùå Cache clear error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to clear cache',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

/**
 * 6Ô∏è‚É£ ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑŸÉÿßÿ¥
 * GET /api/aggregate/cache/stats
 */
exports.getCacheStats = async (req, res) => {
  try {
    if (req.user.role !== 'admin') {
      return res.status(403).json({
        success: false,
        message: 'Access denied. Admin only.'
      });
    }

    const stats = cache.getStats();
    const info = cache.getCacheInfo();
    
    res.json({
      success: true,
      data: {
        ...info,
        details: stats,
        memoryUsage: process.memoryUsage(),
        uptime: process.uptime()
      },
      timestamp: new Date()
    });
  } catch (error) {
    console.error('‚ùå Cache stats error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to get cache statistics',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

// ====== ÿØŸàÿßŸÑ ŸÖÿ≥ÿßÿπÿØÿ© ======

exports.calculateETA = (order) => {
  const statusTimes = {
    pending: '15-25 ÿØŸÇŸäŸÇÿ©',
    accepted: '10-20 ÿØŸÇŸäŸÇÿ©',
    picked: '5-15 ÿØŸÇŸäŸÇÿ©',
    delivered: 'ÿ™ŸÖ ÿßŸÑÿ™ŸàÿµŸäŸÑ',
    cancelled: 'ŸÖŸÑÿ∫Ÿä'
  };
  
  return statusTimes[order.status] || 'ÿ∫Ÿäÿ± ŸÖÿπÿ±ŸàŸÅ';
};

exports.getStatusText = (status) => {
  const statusTexts = {
    pending: 'ŸÇŸäÿØ ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ±',
    accepted: 'ÿ™ŸÖ ÿßŸÑŸÇÿ®ŸàŸÑ',
    picked: 'ÿ™ŸÖ ÿßŸÑÿßÿ≥ÿ™ŸÑÿßŸÖ',
    delivered: 'ÿ™ŸÖ ÿßŸÑÿ™ŸàÿµŸäŸÑ',
    cancelled: 'ŸÖŸÑÿ∫Ÿä'
  };
  
  return statusTexts[status] || 'ÿ∫Ÿäÿ± ŸÖÿπÿ±ŸàŸÅ';
};
</file>

<file path="src/controllers/item.controller.js">
const Item = require("../models/item.model");
const PaginationUtils = require('../utils/pagination.util');

/**
 * POST /api/items
 * Create item with image (Cloudinary)
 */
exports.createItem = async (req, res) => {
  try {
    const { name, price, restaurant } = req.body;

    const item = await Item.create({
      name,
      price,
      restaurant,
      image: req.file ? req.file.path : null, // ‚úÖ Cloudinary URL
    });

    await item.populate("restaurant", "name");

    res.status(201).json(item);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: "Failed to create item" });
  }
};

/**
 * PUT /api/items/:id/image
 * Update item image (Cloudinary)
 */
exports.updateItemImage = async (req, res) => {
  try {
    const { id } = req.params;

    if (!req.file) {
      return res.status(400).json({ message: "No image uploaded" });
    }

    const item = await Item.findByIdAndUpdate(
      id,
      { image: req.file.path }, // ‚úÖ Cloudinary URL
      { new: true }
    );

    if (!item) {
      return res.status(404).json({ message: "Item not found" });
    }

    res.json(item);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: "Failed to update item image" });
  }
};

/**
 * DELETE /api/items/:id
 * Delete item (image remains in Cloudinary unless deleted manually)
 */
exports.deleteItem = async (req, res) => {
  try {
    const { id } = req.params;

    const item = await Item.findByIdAndDelete(id);
    if (!item) {
      return res.status(404).json({ message: "Item not found" });
    }

    res.json({ message: "Item deleted successfully" });
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: "Failed to delete item" });
  }
};


/**
 * üìã ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿßŸÑÿπŸÜÿßÿµÿ± ŸÖÿπ Pagination
 * GET /api/items
 */
exports.getItemsPaginated = async (req, res) => {
  try {
    const paginationOptions = PaginationUtils.getPaginationOptions(req);
    const { skip, limit, sort, filters } = paginationOptions;
    
    let query = { isAvailable: true };
    
    if (filters.restaurant) {
      query.restaurant = filters.restaurant;
    }
    
    if (filters.category) {
      query.category = filters.category;
    }
    
    if (filters.minPrice || filters.maxPrice) {
      query.price = {};
      if (filters.minPrice) query.price.$gte = Number(filters.minPrice);
      if (filters.maxPrice) query.price.$lte = Number(filters.maxPrice);
    }

    const [items, total] = await Promise.all([
      Item.find(query)
        .populate('restaurant', 'name image')
        .sort(sort)
        .skip(skip)
        .limit(limit),
      
      Item.countDocuments(query),
    ]);

    const response = PaginationUtils.createPaginationResponse(
      items,
      total,
      paginationOptions
    );
    
    res.json(response);
  } catch (error) {
    console.error('Pagination error:', error);
    res.status(500).json({ message: 'Failed to fetch items' });
  }
};
</file>

<file path="src/controllers/order.controller.js">
const Order = require("../models/order.model");
const Address = require("../models/address.model");
const DriverLocation = require("../models/driverLocation.model");
const cache = require('../utils/cache.util');
const PaginationUtils = require('../utils/pagination.util');
const notificationService = require("../services/notification.service");
const User = require("../models/user.model");

/**
 * üèéÔ∏è ÿØÿßŸÑÿ© ŸÖÿ≥ÿßÿπÿØÿ©: ÿ™ÿπŸäŸäŸÜ ÿ£ŸÇÿ±ÿ® ÿ≥ÿßÿ¶ŸÇ ŸÖÿ™ÿßÿ≠
 */
const assignClosestDriver = async (orderId, pickupCoordinates) => {
  try {
    // ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ÿ≥ÿßÿ¶ŸÇ ŸÖÿ™ÿßÿ≠ ÿ®ÿßŸÑŸÇÿ±ÿ® ŸÖŸÜ ŸÖŸàŸÇÿπ ÿßŸÑÿßÿ≥ÿ™ŸÑÿßŸÖ
    const nearestDriver = await DriverLocation.findOne({ 
      order: null 
    }).where('location').near({
      center: {
        type: 'Point',
        coordinates: pickupCoordinates
      },
      maxDistance: 5000, // 5 ŸÉŸÖ
      spherical: true
    }).populate('driver', 'name phone image');

    if (!nearestDriver) {
      console.log('üö´ No available drivers found near pickup location');
      return null;
    }

    // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ∑ŸÑÿ® ÿ®ÿßŸÑÿ≥ÿßÿ¶ŸÇ ÿßŸÑŸÖÿπŸäŸÜ
    await Order.findByIdAndUpdate(orderId, {
      driver: nearestDriver.driver._id,
      status: "accepted",
    });

    // ÿ™ÿ≠ÿØŸäÿ´ ŸÖŸàŸÇÿπ ÿßŸÑÿ≥ÿßÿ¶ŸÇ ŸÑŸäÿ¥Ÿäÿ± ÿ•ŸÑŸâ Ÿáÿ∞ÿß ÿßŸÑÿ∑ŸÑÿ®
    await DriverLocation.findByIdAndUpdate(nearestDriver._id, {
      order: orderId
    });

    console.log(`‚úÖ Driver ${nearestDriver.driver.name} assigned to order ${orderId}`);
    return nearestDriver.driver;
  } catch (error) {
    console.error('‚ùå Error assigning closest driver:', error.message);
    return null;
  }
};

/**
 * üßπ ÿØÿßŸÑÿ© ŸÖÿ≥ÿßÿπÿØÿ©: ÿ•ÿ®ÿ∑ÿßŸÑ ÿßŸÑŸÉÿßÿ¥ ÿπŸÜÿØ ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ∑ŸÑÿ®
 */
const invalidateOrderCache = async (orderId, userId) => {
  try {
    // ÿ•ÿ®ÿ∑ÿßŸÑ ŸÉÿßÿ¥ ŸÑŸàÿ≠ÿ© ÿßŸÑÿ™ÿ≠ŸÉŸÖ ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
    cache.del(`dashboard:${userId}`);

    // ÿ•ÿ®ÿ∑ÿßŸÑ ŸÉÿßÿ¥ ÿ™ÿ™ÿ®ÿπ ÿßŸÑÿ∑ŸÑÿ®
    cache.del(`order:tracking:${orderId}:${userId}`);

    // ÿ•ÿ®ÿ∑ÿßŸÑ ŸÉÿßÿ¥ ŸÑŸàÿ≠ÿ© ÿ™ÿ≠ŸÉŸÖ ÿßŸÑÿ£ÿØŸÖŸÜ
    cache.invalidatePattern('admin:dashboard:*');
    cache.invalidatePattern('orders:admin:*');

    // ÿ•ÿ®ÿ∑ÿßŸÑ ŸÉÿßÿ¥ ÿßŸÑÿ∑ŸÑÿ®ÿßÿ™ ÿßŸÑÿπÿßŸÖÿ©
    cache.invalidatePattern('orders:*');
    cache.invalidatePattern('user:complete:*');

    console.log(`üóëÔ∏è Invalidated cache for order ${orderId}`);
  } catch (error) {
    console.error('‚ùå Cache invalidation error:', error);
  }
};

/**
 * üìù ÿ•ŸÜÿ¥ÿßÿ° ÿ∑ŸÑÿ® ÿ¨ÿØŸäÿØ
 * POST /api/orders
 */
exports.createOrder = async (req, res) => {
  try {
    const { items, totalPrice, pickupAddress, deliveryAddress, restaurant } = req.body;
    const userId = req.user.id;

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
    if (!items || !Array.isArray(items) || items.length === 0) {
      return res.status(400).json({ 
        success: false,
        message: "Ÿäÿ¨ÿ® ÿ•ÿ∂ÿßŸÅÿ© ÿπŸÜÿßÿµÿ± ŸÑŸÑÿ∑ŸÑÿ®" 
      });
    }

    if (!totalPrice || totalPrice <= 0) {
      return res.status(400).json({ 
        success: false,
        message: "ÿßŸÑÿ≥ÿπÿ± ÿßŸÑÿ•ÿ¨ŸÖÿßŸÑŸä ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠" 
      });
    }

    if (!pickupAddress || !deliveryAddress) {
      return res.status(400).json({ 
        success: false,
        message: "ÿπŸÜŸàÿßŸÜ ÿßŸÑÿßÿ≥ÿ™ŸÑÿßŸÖ ŸàÿßŸÑÿ™ŸàÿµŸäŸÑ ŸÖÿ∑ŸÑŸàÿ®ÿßŸÜ" 
      });
    }

    if (!restaurant) {
      return res.status(400).json({ 
        success: false,
        message: "ÿßŸÑŸÖÿ∑ÿπŸÖ ŸÖÿ∑ŸÑŸàÿ®" 
      });
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ŸÖŸÑŸÉŸäÿ© ÿßŸÑÿπŸÖŸäŸÑ ŸÑŸÑÿπŸÜÿßŸàŸäŸÜ
    const pickup = await Address.findOne({ 
      _id: pickupAddress, 
      user: userId 
    });

    const delivery = await Address.findOne({ 
      _id: deliveryAddress, 
      user: userId 
    });

    if (!pickup || !delivery) {
      return res.status(400).json({ 
        success: false,
        message: "ÿßŸÑÿπŸÜÿßŸàŸäŸÜ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠ÿ© ÿ£Ÿà ŸÑÿß ÿ™ŸÖŸÑŸÉ ÿµŸÑÿßÿ≠Ÿäÿ© ÿßŸÑŸàÿµŸàŸÑ ÿ•ŸÑŸäŸáÿß" 
      });
    }

    // ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ∑ŸÑÿ®
    const order = await Order.create({
      user: userId,
      items,
      totalPrice,
      pickupAddress,
      deliveryAddress,
      restaurant,
      status: "pending",
    });

    // ŸÖÿ≠ÿßŸàŸÑÿ© ÿ™ÿπŸäŸäŸÜ ÿ£ŸÇÿ±ÿ® ÿ≥ÿßÿ¶ŸÇ ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß
    let assignedDriver = null;
    if (pickup.latitude && pickup.longitude) {
      assignedDriver = await assignClosestDriver(
        order._id, 
        [pickup.longitude, pickup.latitude]
      );
    }

    // ÿ•ÿ±ÿ≥ÿßŸÑ ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿßŸÑÿ∑ŸÑÿ®
    try {
      await notificationService.createOrderNotifications(order);
    } catch (notificationError) {
      console.error('‚ùå Notification error:', notificationError.message);
      // ŸÑÿß ŸÜŸàŸÇŸÅ ÿßŸÑÿπŸÖŸÑŸäÿ© ÿ•ÿ∞ÿß ŸÅÿ¥ŸÑÿ™ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™
    }

    // ÿ¨ŸÑÿ® ÿßŸÑÿ∑ŸÑÿ® ŸÖÿπ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ±ÿ™ÿ®ÿ∑ÿ©
    const populatedOrder = await Order.findById(order._id)
      .populate("user", "name phone image")
      .populate("driver", "name phone image")
      .populate("restaurant", "name image phone")
      .populate("pickupAddress")
      .populate("deliveryAddress")
      .lean();

    // ÿ•ÿ®ÿ∑ÿßŸÑ ÿßŸÑŸÉÿßÿ¥
    await invalidateOrderCache(order._id, userId);

    res.status(201).json({
      success: true,
      message: "ÿ™ŸÖ ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ∑ŸÑÿ® ÿ®ŸÜÿ¨ÿßÿ≠",
      data: {
        order: populatedOrder,
        assignedDriver: assignedDriver ? {
          id: assignedDriver._id,
          name: assignedDriver.name,
          phone: assignedDriver.phone
        } : null,
        nextSteps: assignedDriver ? "ÿ¨ÿßÿ±Ÿä ÿ™ÿ¨ŸáŸäÿ≤ ÿßŸÑÿ∑ŸÑÿ®" : "ÿ®ÿßŸÜÿ™ÿ∏ÿßÿ± ÿ™ÿπŸäŸäŸÜ ŸÖŸÜÿØŸàÿ®"
      },
      timestamp: new Date()
    });
  } catch (error) {
    console.error('‚ùå Create order error:', error.message);
    
    if (error.name === 'ValidationError') {
      return res.status(400).json({
        success: false,
        message: "ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ∑ŸÑÿ® ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠ÿ©",
        errors: Object.values(error.errors).map(err => err.message)
      });
    }
    
    if (error.code === 11000) {
      return res.status(400).json({
        success: false,
        message: "ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ∑ŸÑÿ®"
      });
    }
    
    res.status(500).json({ 
      success: false,
      message: "ŸÅÿ¥ŸÑ ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ∑ŸÑÿ®",
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

/**
 * üîÑ ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ ÿßŸÑŸÖŸÜÿØŸàÿ® (ŸÑŸÑÿ£ÿØŸÖŸÜ)
 * PUT /api/orders/:orderId/reassign
 */
exports.reassignDriver = async (req, res) => {
  try {
    const { orderId } = req.params;
    const userId = req.user.id;

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿµŸÑÿßÿ≠Ÿäÿ© ÿßŸÑÿ£ÿØŸÖŸÜ
    if (req.user.role !== 'admin') {
      return res.status(403).json({ 
        success: false,
        message: "ÿ∫Ÿäÿ± ŸÖÿµÿ±ÿ≠ ŸÑŸÉ ÿ®Ÿáÿ∞ÿß ÿßŸÑÿ•ÿ¨ÿ±ÿßÿ°" 
      });
    }

    const order = await Order.findById(orderId)
      .populate("pickupAddress")
      .populate("user", "id");

    if (!order) {
      return res.status(404).json({ 
        success: false,
        message: "ÿßŸÑÿ∑ŸÑÿ® ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ" 
      });
    }

    // ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ ÿßŸÑÿ≥ÿßÿ¶ŸÇ
    order.driver = null;
    order.status = "pending";
    await order.save();

    // ÿ•ÿ®ÿ∑ÿßŸÑ ŸÉÿßÿ¥ ÿßŸÑŸÖŸÜÿØŸàÿ® ÿßŸÑŸÇÿØŸäŸÖ
    if (order.driver) {
      await DriverLocation.findOneAndUpdate(
        { driver: order.driver._id, order: orderId },
        { order: null }
      );
    }

    // ŸÖÿ≠ÿßŸàŸÑÿ© ÿ™ÿπŸäŸäŸÜ ÿ≥ÿßÿ¶ŸÇ ÿ¨ÿØŸäÿØ
    let newDriver = null;
    if (order.pickupAddress && order.pickupAddress.latitude && order.pickupAddress.longitude) {
      newDriver = await assignClosestDriver(order._id, [
        order.pickupAddress.longitude,
        order.pickupAddress.latitude,
      ]);
    }

    // ÿ•ÿ®ÿ∑ÿßŸÑ ÿßŸÑŸÉÿßÿ¥
    await invalidateOrderCache(order._id, order.user._id);

    res.json({
      success: true,
      message: newDriver ? "ÿ™ŸÖ ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ ÿßŸÑŸÖŸÜÿØŸàÿ® ÿ®ŸÜÿ¨ÿßÿ≠" : "ŸÑÿß ŸäŸàÿ¨ÿØ ŸÖŸÜÿßÿØŸäÿ® ŸÖÿ™ÿßÿ≠ŸäŸÜ ÿ≠ÿßŸÑŸäÿßŸã",
      data: {
        orderId: order._id,
        newDriver: newDriver ? {
          id: newDriver._id,
          name: newDriver.name,
          phone: newDriver.phone
        } : null,
        status: order.status
      },
      timestamp: new Date()
    });
  } catch (error) {
    console.error('‚ùå Reassign driver error:', error.message);
    res.status(500).json({ 
      success: false,
      message: "ŸÅÿ¥ŸÑ ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ ÿßŸÑŸÖŸÜÿØŸàÿ®",
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

/**
 * üìã ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ∑ŸÑÿ®ÿßÿ™Ÿä ŸÖÿπ Pagination
 * GET /api/orders/me
 */
exports.getMyOrdersPaginated = async (req, res) => {
  try {
    const paginationOptions = PaginationUtils.getPaginationOptions(req);
    const { skip, limit, sort, filters } = paginationOptions;
    const userId = req.user.id;
    
    let query = { user: userId };
    
    if (filters.status) {
      query.status = filters.status;
    }
    
    if (filters.restaurant) {
      query.restaurant = filters.restaurant;
    }
    
    if (filters.minDate || filters.maxDate) {
      query.createdAt = {};
      if (filters.minDate) query.createdAt.$gte = new Date(filters.minDate);
      if (filters.maxDate) query.createdAt.$lte = new Date(filters.maxDate);
    }

    const cacheKey = `orders:user:${userId}:${JSON.stringify(query)}:${skip}:${limit}`;
    const cachedData = cache.get(cacheKey);
    
    if (cachedData) {
      console.log(`üì¶ Serving user orders from cache for user ${userId}`);
      return res.json({
        ...cachedData,
        cached: true,
      });
    }

    const [orders, total] = await Promise.all([
      Order.find(query)
        .populate('driver', 'name phone image')
        .populate('restaurant', 'name image')
        .populate('pickupAddress', 'label addressLine city')
        .populate('deliveryAddress', 'label addressLine city')
        .select('status totalPrice createdAt items')
        .sort(sort)
        .skip(skip)
        .limit(limit)
        .lean(),
      
      Order.countDocuments(query),
    ]);

    // ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿ∑ŸÑÿ®ÿßÿ™
    const orderStats = await Order.aggregate([
      { $match: { user: userId } },
      {
        $group: {
          _id: '$status',
          count: { $sum: 1 },
          totalAmount: { $sum: '$totalPrice' }
        }
      }
    ]);

    const stats = orderStats.reduce((acc, stat) => {
      acc[stat._id] = {
        count: stat.count,
        amount: stat.totalAmount
      };
      return acc;
    }, {});

    const response = PaginationUtils.createPaginationResponse(
      orders,
      total,
      paginationOptions,
      {
        stats,
        summary: {
          totalOrders: total,
          totalSpent: orderStats.reduce((sum, stat) => sum + stat.totalAmount, 0),
          averageOrderValue: total > 0 ? orderStats.reduce((sum, stat) => sum + stat.totalAmount, 0) / total : 0
        }
      }
    );
    
    cache.set(cacheKey, response, 60);
    
    res.json(response);
  } catch (error) {
    console.error('‚ùå Get my orders paginated error:', error.message);
    res.status(500).json({ 
      success: false,
      message: 'ŸÅÿ¥ŸÑ ÿ¨ŸÑÿ® ÿßŸÑÿ∑ŸÑÿ®ÿßÿ™',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

/**
 * üìã ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ∑ŸÑÿ®ÿßÿ™ ŸÖÿπ Pagination (ŸÑŸÑÿ£ÿØŸÖŸÜ)
 * GET /api/orders
 */
exports.getAllOrdersPaginated = async (req, res) => {
  try {
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿµŸÑÿßÿ≠Ÿäÿ© ÿßŸÑÿ£ÿØŸÖŸÜ
    if (req.user.role !== 'admin') {
      return res.status(403).json({
        success: false,
        message: 'ÿ∫Ÿäÿ± ŸÖÿµÿ±ÿ≠ ŸÑŸÉ ÿ®ÿßŸÑŸàÿµŸàŸÑ ÿ•ŸÑŸâ Ÿáÿ∞Ÿá ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™'
      });
    }

    const paginationOptions = PaginationUtils.getPaginationOptions(req);
    const { skip, limit, sort, filters } = paginationOptions;
    
    let query = {};
    
    if (filters.status) {
      query.status = filters.status;
    }
    
    if (filters.restaurant) {
      query.restaurant = filters.restaurant;
    }
    
    if (filters.user) {
      query.user = filters.user;
    }
    
    if (filters.driver) {
      query.driver = filters.driver;
    }
    
    if (filters.minDate || filters.maxDate) {
      query.createdAt = {};
      if (filters.minDate) query.createdAt.$gte = new Date(filters.minDate);
      if (filters.maxDate) query.createdAt.$lte = new Date(filters.maxDate);
    }

    const cacheKey = `orders:admin:${JSON.stringify(query)}:${skip}:${limit}`;
    const cachedData = cache.get(cacheKey);
    
    if (cachedData) {
      console.log('üì¶ Serving admin orders from cache');
      return res.json({
        ...cachedData,
        cached: true,
      });
    }

    const [orders, total] = await Promise.all([
      Order.find(query)
        .populate('user', 'name phone email')
        .populate('driver', 'name phone')
        .populate('restaurant', 'name image')
        .populate('pickupAddress', 'addressLine city')
        .populate('deliveryAddress', 'addressLine city')
        .sort(sort)
        .skip(skip)
        .limit(limit)
        .lean(),
      
      Order.countDocuments(query),
    ]);

    const stats = await Order.aggregate([
      { $match: query },
      {
        $group: {
          _id: '$status',
          count: { $sum: 1 },
          totalRevenue: { $sum: '$totalPrice' },
          avgOrderValue: { $avg: '$totalPrice' }
        }
      }
    ]);

    const totalRevenue = stats.reduce((sum, stat) => sum + stat.totalRevenue, 0);
    const totalOrders = stats.reduce((sum, stat) => sum + stat.count, 0);

    const response = PaginationUtils.createPaginationResponse(
      orders,
      total,
      paginationOptions,
      {
        stats: stats.reduce((acc, curr) => {
          acc[curr._id] = {
            count: curr.count,
            revenue: curr.totalRevenue,
            avgValue: curr.avgOrderValue
          };
          return acc;
        }, {}),
        summary: {
          totalRevenue,
          totalOrders,
          avgOrderValue: totalOrders > 0 ? totalRevenue / totalOrders : 0,
          revenueToday: await this.getTodayRevenue(query)
        }
      }
    );

    cache.set(cacheKey, response, 30);
    
    res.json(response);
  } catch (error) {
    console.error('‚ùå Get all orders paginated error:', error.message);
    res.status(500).json({ 
      success: false,
      message: 'ŸÅÿ¥ŸÑ ÿ¨ŸÑÿ® ÿßŸÑÿ∑ŸÑÿ®ÿßÿ™',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

/**
 * üîß ÿ™ÿπŸäŸäŸÜ ŸÖŸÜÿØŸàÿ® ŸäÿØŸàŸäÿßŸã (ŸÑŸÑÿ£ÿØŸÖŸÜ)
 * PUT /api/orders/:id/assign
 */
exports.assignDriver = async (req, res) => {
  try {
    const { id } = req.params;
    const { driverId } = req.body;
    const userId = req.user.id;

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿµŸÑÿßÿ≠Ÿäÿ© ÿßŸÑÿ£ÿØŸÖŸÜ
    if (req.user.role !== 'admin') {
      return res.status(403).json({ 
        success: false,
        message: "ÿ∫Ÿäÿ± ŸÖÿµÿ±ÿ≠ ŸÑŸÉ ÿ®Ÿáÿ∞ÿß ÿßŸÑÿ•ÿ¨ÿ±ÿßÿ°" 
      });
    }

    if (!driverId) {
      return res.status(400).json({ 
        success: false,
        message: "ŸÖÿπÿ±ŸêŸëŸÅ ÿßŸÑŸÖŸÜÿØŸàÿ® ŸÖÿ∑ŸÑŸàÿ®" 
      });
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ Ÿàÿ¨ŸàÿØ ÿßŸÑÿ∑ŸÑÿ®
    const oldOrder = await Order.findById(id)
      .populate('user', 'id name')
      .populate('restaurant', 'name');
    
    if (!oldOrder) {
      return res.status(404).json({ 
        success: false,
        message: "ÿßŸÑÿ∑ŸÑÿ® ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ" 
      });
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ Ÿàÿ¨ŸàÿØ ÿßŸÑŸÖŸÜÿØŸàÿ®
    const driver = await User.findOne({ 
      _id: driverId, 
      role: 'driver',
      isActive: true 
    });

    if (!driver) {
      return res.status(404).json({ 
        success: false,
        message: "ÿßŸÑŸÖŸÜÿØŸàÿ® ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ ÿ£Ÿà ÿ∫Ÿäÿ± ŸÜÿ¥ÿ∑" 
      });
    }

    // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ∑ŸÑÿ®
    const order = await Order.findByIdAndUpdate(
      id,
      { 
        driver: driverId, 
        status: "accepted" 
      },
      { new: true }
    )
      .populate("driver", "name phone image rating")
      .populate("user", "name phone")
      .populate("restaurant", "name")
      .populate("pickupAddress")
      .populate("deliveryAddress");

    // ÿ™ÿ≠ÿØŸäÿ´ ŸÖŸàŸÇÿπ ÿßŸÑÿ≥ÿßÿ¶ŸÇ
    await DriverLocation.findOneAndUpdate(
      { driver: driverId },
      { order: id },
      { upsert: true, new: true }
    );

    // ÿ•ÿ±ÿ≥ÿßŸÑ ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿ™ÿπŸäŸäŸÜ ÿßŸÑŸÖŸÜÿØŸàÿ®
    try {
      // ÿ•ÿ¥ÿπÿßÿ± ŸÑŸÑÿπŸÖŸäŸÑ
      await notificationService.sendNotification({
        user: order.user._id,
        type: "driver_assigned",
        title: "ÿ™ŸÖ ÿ™ÿπŸäŸäŸÜ ŸÖŸÜÿØŸàÿ®",
        content: `ÿ™ŸÖ ÿ™ÿπŸäŸäŸÜ ŸÖŸÜÿØŸàÿ® ${order.driver.name} ŸÑÿ™ŸàÿµŸäŸÑ ÿ∑ŸÑÿ®ŸÉ #${order._id.toString().slice(-6)}.`,
        data: {
          orderId: order._id,
          orderNumber: order._id.toString().slice(-6),
          driver: {
            id: order.driver._id,
            name: order.driver.name,
            phone: order.driver.phone,
            rating: order.driver.rating
          },
          restaurant: order.restaurant.name
        },
        priority: "high",
        link: `/orders/${order._id}`,
        icon: "üöó",
        tags: ["order", "driver_assigned", `order_${order._id}`],
      });

      // ÿ•ÿ¥ÿπÿßÿ± ŸÑŸÑŸÖŸÜÿØŸàÿ®
      await notificationService.sendNotification({
        user: order.driver._id,
        type: "order_assigned",
        title: "ÿ∑ŸÑÿ® ÿ¨ÿØŸäÿØ ŸÖÿπŸäŸÜ ŸÑŸÉ",
        content: `ÿ™ŸÖ ÿ™ÿπŸäŸäŸÜ ÿ∑ŸÑÿ® #${order._id.toString().slice(-6)} ŸÖŸÜ ${order.restaurant.name} ŸÑŸÉ ŸÑŸÑÿ™ŸàÿµŸäŸÑ.`,
        data: {
          orderId: order._id,
          orderNumber: order._id.toString().slice(-6),
          customer: {
            id: order.user._id,
            name: order.user.name,
            phone: order.user.phone
          },
          restaurant: {
            id: order.restaurant._id,
            name: order.restaurant.name
          },
          pickupAddress: order.pickupAddress,
          deliveryAddress: order.deliveryAddress,
          totalPrice: order.totalPrice
        },
        priority: "high",
        link: `/driver/orders/${order._id}`,
        icon: "üõí",
        tags: ["order", "driver", `order_${order._id}`],
      });
    } catch (notificationError) {
      console.error('‚ùå Notification error:', notificationError.message);
    }

    // ÿ•ÿ®ÿ∑ÿßŸÑ ÿßŸÑŸÉÿßÿ¥
    await invalidateOrderCache(order._id, order.user._id);

    res.json({
      success: true,
      message: "ÿ™ŸÖ ÿ™ÿπŸäŸäŸÜ ÿßŸÑŸÖŸÜÿØŸàÿ® ÿ®ŸÜÿ¨ÿßÿ≠",
      data: {
        order,
        driver: {
          id: order.driver._id,
          name: order.driver.name,
          phone: order.driver.phone,
          rating: order.driver.rating
        }
      },
      timestamp: new Date()
    });
  } catch (error) {
    console.error('‚ùå Assign driver error:', error.message);
    res.status(500).json({ 
      success: false,
      message: "ŸÅÿ¥ŸÑ ÿ™ÿπŸäŸäŸÜ ÿßŸÑŸÖŸÜÿØŸàÿ®",
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

/**
 * üöö ÿ™ÿ≠ÿØŸäÿ´ ÿ≠ÿßŸÑÿ© ÿßŸÑÿ∑ŸÑÿ® (ŸÑŸÑŸÖŸÜÿØŸàÿ®)
 * PUT /api/orders/:id/status
 */
exports.updateStatus = async (req, res) => {
  try {
    const { id } = req.params;
    const { status } = req.body;
    const userId = req.user.id;

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿµŸÑÿßÿ≠Ÿäÿ© (ŸÖŸÜÿØŸàÿ® ÿ£Ÿà ÿ£ÿØŸÖŸÜ)
    if (req.user.role !== 'driver' && req.user.role !== 'admin') {
      return res.status(403).json({ 
        success: false,
        message: "ÿ∫Ÿäÿ± ŸÖÿµÿ±ÿ≠ ŸÑŸÉ ÿ®Ÿáÿ∞ÿß ÿßŸÑÿ•ÿ¨ÿ±ÿßÿ°" 
      });
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ≠ÿßŸÑÿ©
    const validStatuses = ["pending", "accepted", "picked", "delivered", "cancelled"];
    if (!validStatuses.includes(status)) {
      return res.status(400).json({ 
        success: false,
        message: "ÿ≠ÿßŸÑÿ© ÿßŸÑÿ∑ŸÑÿ® ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠ÿ©" 
      });
    }

    // ÿ¨ŸÑÿ® ÿßŸÑÿ∑ŸÑÿ® ÿßŸÑŸÇÿØŸäŸÖ
    const oldOrder = await Order.findById(id)
      .populate('user', 'id name phone')
      .populate('driver', 'id name')
      .populate('restaurant', 'name');
    
    if (!oldOrder) {
      return res.status(404).json({ 
        success: false,
        message: "ÿßŸÑÿ∑ŸÑÿ® ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ" 
      });
    }

    // ÿ•ÿ∞ÿß ŸÉÿßŸÜ ŸÖŸÜÿØŸàÿ®ÿßŸãÿå ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ£ŸÜŸá ÿßŸÑŸÖŸÜÿØŸàÿ® ÿßŸÑŸÖÿπŸäŸÜ
    if (req.user.role === 'driver' && oldOrder.driver?._id.toString() !== userId) {
      return res.status(403).json({ 
        success: false,
        message: "Ÿáÿ∞ÿß ÿßŸÑÿ∑ŸÑÿ® ÿ∫Ÿäÿ± ŸÖÿπŸäŸÜ ŸÑŸÉ" 
      });
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ™ÿ≥ŸÑÿ≥ŸÑ ÿßŸÑÿ≠ÿßŸÑÿßÿ™
    if (!this.isValidStatusTransition(oldOrder.status, status, req.user.role)) {
      return res.status(400).json({ 
        success: false,
        message: "ÿ™ÿ∫ŸäŸäÿ± ÿßŸÑÿ≠ÿßŸÑÿ© ÿ∫Ÿäÿ± ŸÖÿ≥ŸÖŸàÿ≠ ÿ®Ÿá" 
      });
    }

    // ÿ™ÿ≠ÿØŸäÿ´ ÿ≠ÿßŸÑÿ© ÿßŸÑÿ∑ŸÑÿ®
    const order = await Order.findByIdAndUpdate(
      id, 
      { status }, 
      { new: true }
    )
      .populate('user', 'name phone')
      .populate('driver', 'name phone')
      .populate('restaurant', 'name')
      .populate('pickupAddress')
      .populate('deliveryAddress');

    // ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿßŸÑÿ≠ÿßŸÑÿ© deliveredÿå ÿ™ÿ≠ÿØŸäÿ´ ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿ≥ÿßÿ¶ŸÇ
    if (status === 'delivered' && order.driver) {
      await User.findByIdAndUpdate(order.driver._id, {
        $inc: { 
          'driverInfo.totalDeliveries': 1,
          'driverInfo.earnings': order.totalPrice * 0.8 // ŸÖÿ´ÿßŸÑ: 80% ŸÑŸÑÿ≥ÿßÿ¶ŸÇ
        }
      });
    }

    // ÿ•ÿ±ÿ≥ÿßŸÑ ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ≠ÿßŸÑÿ©
    try {
      await notificationService.updateOrderStatusNotifications(
        order, 
        oldOrder.status, 
        status
      );
    } catch (notificationError) {
      console.error('‚ùå Notification error:', notificationError.message);
    }

    // ÿ•ÿ®ÿ∑ÿßŸÑ ÿßŸÑŸÉÿßÿ¥
    await invalidateOrderCache(order._id, order.user._id);

    res.json({
      success: true,
      message: `ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿ´ ÿ≠ÿßŸÑÿ© ÿßŸÑÿ∑ŸÑÿ® ÿ•ŸÑŸâ ${this.getStatusText(status)}`,
      data: {
        order,
        statusChange: {
          from: oldOrder.status,
          to: status,
          text: this.getStatusText(status)
        }
      },
      timestamp: new Date()
    });
  } catch (error) {
    console.error('‚ùå Update status error:', error.message);
    res.status(500).json({ 
      success: false,
      message: "ŸÅÿ¥ŸÑ ÿ™ÿ≠ÿØŸäÿ´ ÿ≠ÿßŸÑÿ© ÿßŸÑÿ∑ŸÑÿ®",
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

/**
 * üìä ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ∑ŸÑÿ®ÿßÿ™ ÿßŸÑŸÖŸÜÿØŸàÿ®
 * GET /api/orders/driver/me
 */
exports.getDriverOrders = async (req, res) => {
  try {
    if (req.user.role !== 'driver') {
      return res.status(403).json({
        success: false,
        message: 'ÿ∫Ÿäÿ± ŸÖÿµÿ±ÿ≠ ŸÑŸÉ ÿ®ÿßŸÑŸàÿµŸàŸÑ ÿ•ŸÑŸâ Ÿáÿ∞Ÿá ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™'
      });
    }

    const paginationOptions = PaginationUtils.getPaginationOptions(req);
    const { skip, limit, sort, filters } = paginationOptions;
    const driverId = req.user.id;
    
    let query = { driver: driverId };
    
    if (filters.status) {
      query.status = filters.status;
    }
    
    if (filters.minDate || filters.maxDate) {
      query.createdAt = {};
      if (filters.minDate) query.createdAt.$gte = new Date(filters.minDate);
      if (filters.maxDate) query.createdAt.$lte = new Date(filters.maxDate);
    }

    const [orders, total] = await Promise.all([
      Order.find(query)
        .populate('user', 'name phone image')
        .populate('restaurant', 'name image addressLine')
        .populate('pickupAddress', 'label addressLine city latitude longitude')
        .populate('deliveryAddress', 'label addressLine city latitude longitude')
        .select('status totalPrice createdAt items')
        .sort(sort)
        .skip(skip)
        .limit(limit)
        .lean(),
      
      Order.countDocuments(query),
    ]);

    // ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑŸÖŸÜÿØŸàÿ®
    const driverStats = await Order.aggregate([
      { $match: { driver: req.user.id } },
      {
        $group: {
          _id: '$status',
          count: { $sum: 1 },
          totalEarnings: { 
            $sum: { $multiply: ['$totalPrice', 0.8] } // 80% ŸÑŸÑÿ≥ÿßÿ¶ŸÇ
          }
        }
      }
    ]);

    const totalDelivered = driverStats
      .filter(stat => stat._id === 'delivered')
      .reduce((sum, stat) => sum + stat.count, 0);

    const totalEarnings = driverStats
      .reduce((sum, stat) => sum + stat.totalEarnings, 0);

    const response = PaginationUtils.createPaginationResponse(
      orders,
      total,
      paginationOptions,
      {
        stats: {
          totalDelivered,
          totalEarnings,
          currentActive: await Order.countDocuments({ 
            driver: driverId, 
            status: { $in: ['accepted', 'picked'] } 
          }),
          byStatus: driverStats.reduce((acc, stat) => {
            acc[stat._id] = {
              count: stat.count,
              earnings: stat.totalEarnings
            };
            return acc;
          }, {})
        }
      }
    );
    
    res.json(response);
  } catch (error) {
    console.error('‚ùå Get driver orders error:', error.message);
    res.status(500).json({ 
      success: false,
      message: 'ŸÅÿ¥ŸÑ ÿ¨ŸÑÿ® ÿ∑ŸÑÿ®ÿßÿ™ ÿßŸÑŸÖŸÜÿØŸàÿ®',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

/**
 * üìà ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ•Ÿäÿ±ÿßÿØÿßÿ™ ÿßŸÑŸäŸàŸÖ
 */
exports.getTodayRevenue = async (query = {}) => {
  try {
    const startOfDay = new Date();
    startOfDay.setHours(0, 0, 0, 0);

    const endOfDay = new Date();
    endOfDay.setHours(23, 59, 59, 999);

    const result = await Order.aggregate([
      {
        $match: {
          ...query,
          createdAt: { $gte: startOfDay, $lte: endOfDay },
          status: 'delivered'
        }
      },
      {
        $group: {
          _id: null,
          totalRevenue: { $sum: '$totalPrice' },
          orderCount: { $sum: 1 }
        }
      }
    ]);

    return result[0] || { totalRevenue: 0, orderCount: 0 };
  } catch (error) {
    console.error('‚ùå Get today revenue error:', error.message);
    return { totalRevenue: 0, orderCount: 0 };
  }
};

/**
 * üîÑ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿµÿ≠ÿ© ÿ™ÿ∫ŸäŸäÿ± ÿßŸÑÿ≠ÿßŸÑÿ©
 */
exports.isValidStatusTransition = (oldStatus, newStatus, userRole) => {
  const validTransitions = {
    admin: {
      pending: ['accepted', 'cancelled'],
      accepted: ['picked', 'cancelled'],
      picked: ['delivered', 'cancelled'],
      delivered: [],
      cancelled: []
    },
    driver: {
      pending: [],
      accepted: ['picked'],
      picked: ['delivered'],
      delivered: [],
      cancelled: []
    },
    client: {
      pending: ['cancelled'],
      accepted: ['cancelled'],
      picked: [],
      delivered: [],
      cancelled: []
    }
  };

  const roleTransitions = validTransitions[userRole] || validTransitions.client;
  return roleTransitions[oldStatus]?.includes(newStatus) || false;
};

/**
 * üìù ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ŸÜÿµ ÿßŸÑÿ≠ÿßŸÑÿ©
 */
exports.getStatusText = (status) => {
  const statusTexts = {
    pending: 'ŸÇŸäÿØ ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ±',
    accepted: 'ÿ™ŸÖ ÿßŸÑŸÇÿ®ŸàŸÑ',
    picked: 'ÿ™ŸÖ ÿßŸÑÿßÿ≥ÿ™ŸÑÿßŸÖ',
    delivered: 'ÿ™ŸÖ ÿßŸÑÿ™ŸàÿµŸäŸÑ',
    cancelled: 'ŸÖŸÑÿ∫Ÿä'
  };
  
  return statusTexts[status] || 'ÿ∫Ÿäÿ± ŸÖÿπÿ±ŸàŸÅ';
};

/**
 * üìä ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿ∑ŸÑÿ®ÿßÿ™ ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
 */
exports.getUserOrderStats = async (userId) => {
  try {
    const stats = await Order.aggregate([
      { $match: { user: userId } },
      {
        $group: {
          _id: '$status',
          count: { $sum: 1 },
          totalAmount: { $sum: '$totalPrice' }
        }
      }
    ]);

    return stats.reduce((acc, stat) => {
      acc[stat._id] = {
        count: stat.count,
        amount: stat.totalAmount
      };
      return acc;
    }, {});
  } catch (error) {
    console.error('‚ùå Get user order stats error:', error.message);
    return {};
  }
};

/**
 * üìç ÿ™ÿ≠ÿØŸäÿ´ ŸÖŸàŸÇÿπ ÿßŸÑŸÖŸÜÿØŸàÿ®
 * POST /api/orders/:id/location
 */
exports.updateDriverLocation = async (req, res) => {
  try {
    const { id } = req.params;
    const { latitude, longitude } = req.body;
    
    if (req.user.role !== 'driver') {
      return res.status(403).json({
        success: false,
        message: 'ÿ∫Ÿäÿ± ŸÖÿµÿ±ÿ≠ ŸÑŸÉ ÿ®Ÿáÿ∞ÿß ÿßŸÑÿ•ÿ¨ÿ±ÿßÿ°'
      });
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ£ŸÜ ÿßŸÑÿ∑ŸÑÿ® ŸÖÿπŸäŸÜ ŸÑŸáÿ∞ÿß ÿßŸÑŸÖŸÜÿØŸàÿ®
    const order = await Order.findOne({ 
      _id: id, 
      driver: req.user.id 
    });

    if (!order) {
      return res.status(404).json({
        success: false,
        message: 'ÿßŸÑÿ∑ŸÑÿ® ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ ÿ£Ÿà ÿ∫Ÿäÿ± ŸÖÿπŸäŸÜ ŸÑŸÉ'
      });
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ•ÿ≠ÿØÿßÿ´Ÿäÿßÿ™
    if (!latitude || !longitude) {
      return res.status(400).json({
        success: false,
        message: 'ÿ•ÿ≠ÿØÿßÿ´Ÿäÿßÿ™ ÿßŸÑŸÖŸàŸÇÿπ ŸÖÿ∑ŸÑŸàÿ®ÿ©'
      });
    }

    // ÿ™ÿ≠ÿØŸäÿ´ ÿ£Ÿà ÿ•ŸÜÿ¥ÿßÿ° ŸÖŸàŸÇÿπ ÿßŸÑÿ≥ÿßÿ¶ŸÇ
    await DriverLocation.findOneAndUpdate(
      { driver: req.user.id, order: id },
      {
        driver: req.user.id,
        order: id,
        location: {
          type: 'Point',
          coordinates: [parseFloat(longitude), parseFloat(latitude)]
        },
        createdAt: new Date()
      },
      { upsert: true, new: true }
    );

    // ÿ•ÿ±ÿ≥ÿßŸÑ ÿ™ÿ≠ÿØŸäÿ´ ÿπÿ®ÿ± Socket.io
    const io = req.app.get('io');
    if (io) {
      io.to(`order:${id}`).emit('driver:location:updated', {
        orderId: id,
        driverId: req.user.id,
        location: { latitude, longitude },
        timestamp: new Date()
      });
    }

    // ÿ•ÿ®ÿ∑ÿßŸÑ ÿßŸÑŸÉÿßÿ¥
    await invalidateOrderCache(id, order.user);

    res.json({
      success: true,
      message: 'ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÖŸàŸÇÿπ ÿ®ŸÜÿ¨ÿßÿ≠',
      data: {
        orderId: id,
        location: { latitude, longitude },
        timestamp: new Date()
      }
    });
  } catch (error) {
    console.error('‚ùå Update driver location error:', error.message);
    res.status(500).json({
      success: false,
      message: 'ŸÅÿ¥ŸÑ ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÖŸàŸÇÿπ',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

/**
 * ‚ùå ÿ•ŸÑÿ∫ÿßÿ° ÿßŸÑÿ∑ŸÑÿ®
 * PUT /api/orders/:id/cancel
 */
exports.cancelOrder = async (req, res) => {
  try {
    const { id } = req.params;
    const { reason } = req.body;
    const userId = req.user.id;

    // ÿ¨ŸÑÿ® ÿßŸÑÿ∑ŸÑÿ®
    const order = await Order.findOne({ 
      _id: id, 
      user: userId 
    }).populate('user', 'name phone');

    if (!order) {
      return res.status(404).json({
        success: false,
        message: 'ÿßŸÑÿ∑ŸÑÿ® ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ ÿ£Ÿà ŸÑÿß ÿ™ŸÖŸÑŸÉ ÿµŸÑÿßÿ≠Ÿäÿ© ÿ•ŸÑÿ∫ÿßÿ¶Ÿá'
      });
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ•ŸÖŸÉÿßŸÜŸäÿ© ÿßŸÑÿ•ŸÑÿ∫ÿßÿ°
    if (!['pending', 'accepted'].includes(order.status)) {
      return res.status(400).json({
        success: false,
        message: 'ŸÑÿß ŸäŸÖŸÉŸÜ ÿ•ŸÑÿ∫ÿßÿ° ÿßŸÑÿ∑ŸÑÿ® ŸÅŸä Ÿáÿ∞Ÿá ÿßŸÑŸÖÿ±ÿ≠ŸÑÿ©'
      });
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ≥ÿ®ÿ® ÿßŸÑÿ•ŸÑÿ∫ÿßÿ°
    if (!reason || reason.trim().length < 5) {
      return res.status(400).json({
        success: false,
        message: 'Ÿäÿ±ÿ¨Ÿâ ÿ™ŸÇÿØŸäŸÖ ÿ≥ÿ®ÿ® ŸÑŸÑÿ•ŸÑÿ∫ÿßÿ° (5 ÿ£ÿ≠ÿ±ŸÅ ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ)'
      });
    }

    // ÿ™ÿ≠ÿØŸäÿ´ ÿ≠ÿßŸÑÿ© ÿßŸÑÿ∑ŸÑÿ®
    order.status = 'cancelled';
    order.cancellationReason = reason.trim();
    order.cancelledAt = new Date();
    order.cancelledBy = userId;
    await order.save();

    // ÿ•ÿ∞ÿß ŸÉÿßŸÜ ŸáŸÜÿßŸÉ ÿ≥ÿßÿ¶ŸÇ ŸÖÿπŸäŸÜÿå ÿ™ÿ≠ÿ±Ÿäÿ±Ÿá
    if (order.driver) {
      await DriverLocation.findOneAndUpdate(
        { driver: order.driver, order: id },
        { order: null }
      );
    }

    // ÿ•ÿ±ÿ≥ÿßŸÑ ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿßŸÑÿ•ŸÑÿ∫ÿßÿ°
    try {
      await notificationService.updateOrderStatusNotifications(
        order, 
        order.status, 
        'cancelled'
      );
    } catch (notificationError) {
      console.error('‚ùå Notification error:', notificationError.message);
    }

    // ÿ™ÿ≠ÿØŸäÿ´ ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
    const user = await User.findById(userId);
    if (user && user.stats) {
      user.stats.cancelledOrders = (user.stats.cancelledOrders || 0) + 1;
      await user.save();
    }

    // ÿ•ÿ®ÿ∑ÿßŸÑ ÿßŸÑŸÉÿßÿ¥
    await invalidateOrderCache(order._id, userId);

    res.json({
      success: true,
      message: 'ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿßŸÑÿ∑ŸÑÿ® ÿ®ŸÜÿ¨ÿßÿ≠',
      data: {
        orderId: order._id,
        status: order.status,
        cancelledAt: order.cancelledAt,
        reason: reason
      },
      timestamp: new Date()
    });
  } catch (error) {
    console.error('‚ùå Cancel order error:', error.message);
    res.status(500).json({
      success: false,
      message: 'ŸÅÿ¥ŸÑ ÿ•ŸÑÿ∫ÿßÿ° ÿßŸÑÿ∑ŸÑÿ®',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

/**
 * üìç ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ŸÖŸàŸÇÿπ ÿßŸÑŸÖŸÜÿØŸàÿ®
 * GET /api/orders/:id/location
 */
exports.getDriverLocation = async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user.id;

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ£ŸÜ ÿßŸÑÿ∑ŸÑÿ® ŸäÿÆÿµ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
    const order = await Order.findOne({ 
      _id: id, 
      user: userId 
    });

    if (!order) {
      return res.status(404).json({
        success: false,
        message: 'ÿßŸÑÿ∑ŸÑÿ® ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ ÿ£Ÿà ŸÑÿß ÿ™ŸÖŸÑŸÉ ÿµŸÑÿßÿ≠Ÿäÿ© ÿßŸÑŸàÿµŸàŸÑ ÿ•ŸÑŸäŸá'
      });
    }

    if (!order.driver) {
      return res.status(404).json({
        success: false,
        message: 'ŸÑŸÖ Ÿäÿ™ŸÖ ÿ™ÿπŸäŸäŸÜ ŸÖŸÜÿØŸàÿ® ŸÑŸáÿ∞ÿß ÿßŸÑÿ∑ŸÑÿ® ÿ®ÿπÿØ'
      });
    }

    // ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ŸÖŸàŸÇÿπ ÿßŸÑÿ≥ÿßÿ¶ŸÇ
    const driverLocation = await DriverLocation.findOne({
      driver: order.driver,
      order: id
    });

    if (!driverLocation) {
      return res.status(404).json({
        success: false,
        message: 'ŸÖŸàŸÇÿπ ÿßŸÑŸÖŸÜÿØŸàÿ® ÿ∫Ÿäÿ± ŸÖÿ™ÿßÿ≠ ÿ≠ÿßŸÑŸäÿßŸã'
      });
    }

    res.json({
      success: true,
      data: {
        orderId: id,
        driverId: order.driver,
        location: {
          latitude: driverLocation.location.coordinates[1],
          longitude: driverLocation.location.coordinates[0]
        },
        updatedAt: driverLocation.updatedAt,
        driverInfo: await User.findById(order.driver).select('name phone image')
      }
    });
  } catch (error) {
    console.error('‚ùå Get driver location error:', error.message);
    res.status(500).json({
      success: false,
      message: 'ŸÅÿ¥ŸÑ ÿ¨ŸÑÿ® ŸÖŸàŸÇÿπ ÿßŸÑŸÖŸÜÿØŸàÿ®',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

/**
 * üìä ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿ∑ŸÑÿ®ÿßÿ™ (ŸÑŸÑÿ£ÿØŸÖŸÜ)
 * GET /api/orders/stats
 */
exports.getOrderStats = async (req, res) => {
  try {
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿµŸÑÿßÿ≠Ÿäÿ© ÿßŸÑÿ£ÿØŸÖŸÜ
    if (req.user.role !== 'admin') {
      return res.status(403).json({
        success: false,
        message: 'ÿ∫Ÿäÿ± ŸÖÿµÿ±ÿ≠ ŸÑŸÉ ÿ®ÿßŸÑŸàÿµŸàŸÑ ÿ•ŸÑŸâ Ÿáÿ∞Ÿá ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™'
      });
    }

    const { startDate, endDate } = req.query;
    const filter = {};

    if (startDate || endDate) {
      filter.createdAt = {};
      if (startDate) filter.createdAt.$gte = new Date(startDate);
      if (endDate) filter.createdAt.$lte = new Date(endDate);
    }

    const cacheKey = `order:stats:${JSON.stringify(filter)}`;
    const cachedData = cache.get(cacheKey);
    
    if (cachedData) {
      return res.json({
        ...cachedData,
        cached: true
      });
    }

    const stats = await Order.aggregate([
      { $match: filter },
      {
        $group: {
          _id: null,
          totalOrders: { $sum: 1 },
          totalRevenue: { $sum: '$totalPrice' },
          completedOrders: {
            $sum: { $cond: [{ $eq: ['$status', 'delivered'] }, 1, 0] }
          },
          pendingOrders: {
            $sum: { $cond: [{ $in: ['$status', ['pending', 'accepted', 'picked']] }, 1, 0] }
          },
          cancelledOrders: {
            $sum: { $cond: [{ $eq: ['$status', 'cancelled'] }, 1, 0] }
          }
        }
      },
      {
        $project: {
          _id: 0,
          totalOrders: 1,
          totalRevenue: 1,
          completedOrders: 1,
          pendingOrders: 1,
          cancelledOrders: 1,
          completionRate: {
            $cond: [
              { $eq: ['$totalOrders', 0] },
              0,
              { $multiply: [{ $divide: ['$completedOrders', '$totalOrders'] }, 100] }
            ]
          },
          avgOrderValue: {
            $cond: [
              { $eq: ['$totalOrders', 0] },
              0,
              { $divide: ['$totalRevenue', '$totalOrders'] }
            ]
          }
        }
      }
    ]);

    const response = {
      success: true,
      data: stats[0] || {
        totalOrders: 0,
        totalRevenue: 0,
        completedOrders: 0,
        pendingOrders: 0,
        cancelledOrders: 0,
        completionRate: 0,
        avgOrderValue: 0
      },
      timestamp: new Date(),
      filters: {
        startDate,
        endDate
      }
    };

    cache.set(cacheKey, response, 60);
    
    res.json(response);
  } catch (error) {
    console.error('‚ùå Get order stats error:', error.message);
    res.status(500).json({
      success: false,
      message: 'ŸÅÿ¥ŸÑ ÿ¨ŸÑÿ® ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿ∑ŸÑÿ®ÿßÿ™',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};
</file>

<file path="src/controllers/restaurant.controller.js">
const Restaurant = require("../models/restaurant.model");
const RestaurantAddress = require("../models/restaurantAddress.model");
const PaginationUtils = require('../utils/pagination.util');

/**
 * GET all restaurants
 */
exports.getRestaurants = async (req, res) => {
  try {
    const restaurants = await Restaurant.find()
      .populate("createdBy", "name phone email")
      .populate("items");

    res.json(restaurants);
  } catch {
    res.status(500).json({ message: "Failed to fetch restaurants" });
  }
};

/**
 * Search restaurants
 */
exports.searchRestaurants = async (req, res) => {
  try {
    const { name, type } = req.query;
    const filter = {};

    if (name) filter.name = { $regex: name, $options: "i" };
    if (type) filter.type = type;

    const restaurants = await Restaurant.find(filter)
      .populate("createdBy", "name phone")
      .populate("items");

    res.json(restaurants);
  } catch {
    res.status(500).json({ message: "Search failed" });
  }
};

/**
 * Get restaurant with addresses
 */
exports.getRestaurantWithAddress = async (req, res) => {
  try {
    const restaurant = await Restaurant.findById(req.params.id)
      .populate("createdBy", "name email phone")
      .lean();

    if (!restaurant)
      return res.status(404).json({ message: "Restaurant not found" });

    const addresses = await RestaurantAddress.find({
      restaurant: req.params.id,
    });

    res.json({ ...restaurant, addresses });
  } catch {
    res.status(500).json({ message: "Failed to fetch restaurant info" });
  }
};

/**
 * Create restaurant
 */
exports.createRestaurant = async (req, res) => {
  try {
    const { name, description, type } = req.body;

    const restaurant = await Restaurant.create({
      name,
      description,
      type: type || "restaurant",
      image: req.files?.image ? req.files.image[0].path : null,
      coverImage: req.files?.coverImage ? req.files.coverImage[0].path : null,
      createdBy: req.user.id,
      isOpen: true,
    });

    await restaurant.populate("createdBy", "name email phone");
    res.status(201).json(restaurant);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: "Failed to create restaurant" });
  }
};

/**
 * Update restaurant data
 */
exports.updateRestaurant = async (req, res) => {
  try {
    const { name, description, type, isOpen } = req.body;

    const restaurant = await Restaurant.findByIdAndUpdate(
      req.params.id,
      { name, description, type, isOpen },
      { new: true }
    );

    res.json(restaurant);
  } catch {
    res.status(500).json({ message: "Failed to update restaurant" });
  }
};

/**
 * Update cover image
 */
exports.updateCoverImage = async (req, res) => {
  try {
    if (!req.file)
      return res.status(400).json({ message: "No image uploaded" });

    const restaurant = await Restaurant.findByIdAndUpdate(
      req.params.id,
      { coverImage: req.file.path },
      { new: true }
    );

    res.json(restaurant);
  } catch {
    res.status(500).json({ message: "Failed to update cover image" });
  }
};

/**
 * Delete restaurant
 */
exports.deleteRestaurant = async (req, res) => {
  try {
    await Restaurant.findByIdAndDelete(req.params.id);
    res.json({ message: "Restaurant deleted" });
  } catch {
    res.status(500).json({ message: "Failed to delete restaurant" });
  }
};

/**
 * üìã ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿßŸÑŸÖÿ∑ÿßÿπŸÖ ŸÖÿπ Pagination
 * GET /api/restaurants
 */
exports.getRestaurantsPaginated = async (req, res) => {
  try {
    const paginationOptions = PaginationUtils.getPaginationOptions(req);
    const { skip, limit, sort, search, filters } = paginationOptions;
    
    let query = { isOpen: true };
    
    if (search) {
      query.$or = [
        { name: { $regex: search, $options: 'i' } },
        { description: { $regex: search, $options: 'i' } },
      ];
    }
    
    if (filters.type) {
      query.type = filters.type;
    }
    
    const [restaurants, total] = await Promise.all([
      Restaurant.find(query)
        .populate('createdBy', 'name phone email')
        .populate('items')
        .sort(sort)
        .skip(skip)
        .limit(limit),
      
      Restaurant.countDocuments(query),
    ]);

    const response = PaginationUtils.createPaginationResponse(
      restaurants,
      total,
      paginationOptions
    );
    
    res.json(response);
  } catch (error) {
    console.error('Pagination error:', error);
    res.status(500).json({ message: 'Failed to fetch restaurants' });
  }
};

/**
 * üîç ÿ®ÿ≠ÿ´ ŸÖÿ™ŸÇÿØŸÖ ŸÖÿπ Pagination
 * GET /api/restaurants/search/advanced
 */
exports.advancedSearch = async (req, res) => {
  try {
    const paginationOptions = PaginationUtils.getPaginationOptions(req);
    const { skip, limit, sort, filters } = paginationOptions;
    
    // ÿ®ŸÜÿßÿ° ÿßÿ≥ÿ™ÿπŸÑÿßŸÖ ŸÖÿ™ŸÇÿØŸÖ
    let query = { isOpen: true };
    
    if (filters.name) {
      query.name = { $regex: filters.name, $options: 'i' };
    }
    
    if (filters.type) {
      query.type = filters.type;
    }
    
    if (filters.minRating) {
      query.averageRating = { $gte: Number(filters.minRating) };
    }
    
    if (filters.tags) {
      query.tags = { $in: filters.tags.split(',') };
    }
    
    if (filters.hasDelivery !== undefined) {
      query.deliveryFee = filters.hasDelivery === 'true' 
        ? { $gt: 0 } 
        : { $eq: 0 };
    }

    const [restaurants, total] = await Promise.all([
      Restaurant.find(query)
        .populate('createdBy', 'name phone')
        .populate({
          path: 'items',
          match: { isAvailable: true },
          options: { limit: 5 },
        })
        .sort(sort)
        .skip(skip)
        .limit(limit),
      
      Restaurant.countDocuments(query),
    ]);

    // ÿ¨ŸÑÿ® ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿ®ÿ≠ÿ´
    const stats = {
      types: await Restaurant.distinct('type', query),
      averageRating: await Restaurant.aggregate([
        { $match: query },
        { $group: { _id: null, avg: { $avg: '$averageRating' } } },
      ]),
      countByType: await Restaurant.aggregate([
        { $match: query },
        { $group: { _id: '$type', count: { $sum: 1 } } },
      ]),
    };

    const response = PaginationUtils.createPaginationResponse(
      restaurants,
      total,
      paginationOptions,
      { stats }
    );
    
    res.json(response);
  } catch (error) {
    console.error('Advanced search error:', error);
    res.status(500).json({ message: 'Search failed' });
  }
};
</file>

<file path="src/middlewares/auth.middleware.js">
const jwt = require("jsonwebtoken");
const cache = require("../utils/cache.util");
const User = require("../models/user.model");

module.exports = async (req, res, next) => {
  try {
    const token = req.headers.authorization?.split(" ")[1];

    if (!token) {
      return res.status(401).json({ message: "No token provided" });
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ blacklist
    const isBlacklisted = cache.get(`token:blacklist:${token}`);
    if (isBlacklisted) {
      return res.status(401).json({ message: "Token is invalid" });
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿµŸÑÿßÿ≠Ÿäÿ© Token
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded;

    // ÿ™ÿ≠ÿØŸäÿ´ ÿ¢ÿÆÿ± ŸÜÿ¥ÿßÿ∑ ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
    try {
      const user = await User.findById(decoded.id);
      if (user) {
        user.lastActivity = new Date();
        await user.save();
      }
    } catch (userError) {
      console.error("User activity update error:", userError);
      // ŸÑÿß ŸÜŸàŸÇŸÅ ÿßŸÑÿ∑ŸÑÿ® ÿ•ÿ∞ÿß ŸÅÿ¥ŸÑ ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÜÿ¥ÿßÿ∑
    }

    next();
  } catch (error) {
    console.error("Auth middleware error:", error.message);
    
    if (error.name === "JsonWebTokenError") {
      return res.status(401).json({ message: "Invalid token" });
    }
    
    if (error.name === "TokenExpiredError") {
      return res.status(401).json({ message: "Token expired" });
    }
    
    res.status(500).json({ message: "Authentication failed" });
  }
};
</file>

<file path="src/middlewares/rateLimit.middleware.js">
const rateLimit = require('express-rate-limit');

// Rate limiter ŸÑŸÑŸÄ API ÿßŸÑÿπÿßŸÖÿ©
exports.apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 ÿØŸÇŸäŸÇÿ©
  max: 100, // 100 ÿ∑ŸÑÿ® ŸÑŸÉŸÑ IP
  message: {
    success: false,
    message: "Too many requests from this IP, please try again after 15 minutes"
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// Rate limiter ÿ£ŸÉÿ´ÿ± ÿ™ÿ¥ÿØÿØÿßŸã ŸÑŸÑŸÄ authentication
exports.authLimiter = rateLimit({
  windowMs: 60 * 60 * 1000, // ÿ≥ÿßÿπÿ© Ÿàÿßÿ≠ÿØÿ©
  max: 50, // 5 ŸÖÿ≠ÿßŸàŸÑÿßÿ™ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿØÿÆŸàŸÑ ŸÅŸÇÿ∑
  message: {
    success: false,
    message: "Too many login attempts, please try again after an hour"
  },
  skipSuccessfulRequests: true,
});

// Rate limiter ŸÑŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™
exports.notificationLimiter = rateLimit({
  windowMs: 60 * 1000, // ÿØŸÇŸäŸÇÿ© Ÿàÿßÿ≠ÿØÿ©
  max: 10, // 10 ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ŸÅŸä ÿßŸÑÿØŸÇŸäŸÇÿ©
  message: {
    success: false,
    message: "Too many notification requests"
  }
});

// Rate limiter ŸÑŸÑŸÄ Upload
exports.uploadLimiter = rateLimit({
  windowMs: 10 * 60 * 1000, // 10 ÿØŸÇÿßÿ¶ŸÇ
  max: 20, // 20 ŸÖŸÑŸÅ ŸÅŸä 10 ÿØŸÇÿßÿ¶ŸÇ
  message: {
    success: false,
    message: "Too many file uploads, please try again later"
  }
});
</file>

<file path="src/middlewares/upload.js">
const multer = require("multer");
const { CloudinaryStorage } = require("multer-storage-cloudinary");
const cloudinary = require("../config/cloudinary");
const { AppError } = require("./errorHandler.middleware");

// ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ£ŸÜŸàÿßÿπ ÿßŸÑŸÖŸÑŸÅÿßÿ™ ÿßŸÑŸÖÿ≥ŸÖŸàÿ≠ ÿ®Ÿáÿß
const allowedMimeTypes = {
  image: ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp', 'image/svg+xml'],
  video: ['video/mp4', 'video/mov', 'video/avi', 'video/mkv', 'video/webm'],
  audio: ['audio/mpeg', 'audio/wav', 'audio/ogg', 'audio/mp3'],
  document: ['application/pdf', 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', 'text/plain']
};

// ÿ≠ÿ¨ŸÖ ÿßŸÑŸÖŸÑŸÅÿßÿ™ ÿßŸÑÿ£ŸÇÿµŸâ (10MB ŸÑŸÑÿµŸàÿ±ÿå 50MB ŸÑŸÑŸÅŸäÿØŸäŸàÿå 5MB ŸÑŸÑŸÖÿ≥ÿ™ŸÜÿØÿßÿ™)
const maxFileSizes = {
  image: 10 * 1024 * 1024, // 10MB
  video: 50 * 1024 * 1024, // 50MB
  audio: 20 * 1024 * 1024, // 20MB
  document: 5 * 1024 * 1024, // 5MB
  default: 5 * 1024 * 1024 // 5MB
};

const fileFilter = (allowedTypes) => (req, file, cb) => {
  try {
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ŸÜŸàÿπ ÿßŸÑŸÖŸÑŸÅ
    const fileType = Object.keys(allowedMimeTypes).find(type => 
      allowedMimeTypes[type].includes(file.mimetype)
    );

    if (!fileType) {
      return cb(new AppError(`ŸÜŸàÿπ ÿßŸÑŸÖŸÑŸÅ ${file.mimetype} ÿ∫Ÿäÿ± ŸÖÿ≥ŸÖŸàÿ≠ ÿ®Ÿá`, 400), false);
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑŸÜŸàÿπ ŸÖÿ≥ŸÖŸàÿ≠ÿßŸã ÿ®Ÿá
    if (!allowedTypes.includes(fileType) && !allowedTypes.includes('all')) {
      return cb(new AppError(`ŸÜŸàÿπ ÿßŸÑŸÖŸÑŸÅ ${fileType} ÿ∫Ÿäÿ± ŸÖÿ≥ŸÖŸàÿ≠ ÿ®Ÿá ŸÑŸÑÿ±ŸÅÿπ`, 400), false);
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ≠ÿ¨ŸÖ ÿßŸÑŸÖŸÑŸÅ
    const maxSize = maxFileSizes[fileType] || maxFileSizes.default;
    if (file.size > maxSize) {
      return cb(new AppError(`ÿ≠ÿ¨ŸÖ ÿßŸÑŸÖŸÑŸÅ Ÿäÿ™ÿ¨ÿßŸàÿ≤ ÿßŸÑÿ≠ÿØ ÿßŸÑŸÖÿ≥ŸÖŸàÿ≠ ÿ®Ÿá (${maxSize / 1024 / 1024}MB)`, 400), false);
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßÿ≥ŸÖ ÿßŸÑŸÖŸÑŸÅ
    if (!file.originalname || file.originalname.length > 255) {
      return cb(new AppError('ÿßÿ≥ŸÖ ÿßŸÑŸÖŸÑŸÅ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠', 400), false);
    }

    cb(null, true);
  } catch (error) {
    cb(new AppError('ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑŸÖŸÑŸÅ', 500), false);
  }
};

const upload = (folder, allowedTypes = ['image']) => {
  const storage = new CloudinaryStorage({
    cloudinary: cloudinary,
    params: async (req, file) => {
      try {
        // ÿ™ÿ≠ÿØŸäÿØ ŸÖÿ¨ŸÑÿØ ŸÅÿ±ÿπŸä ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ŸÜŸàÿπ ÿßŸÑŸÖŸÑŸÅ
        const fileType = Object.keys(allowedMimeTypes).find(type => 
          allowedMimeTypes[type].includes(file.mimetype)
        ) || 'other';

        const subfolder = `${folder}/${fileType}s`;
        
        // ÿ•ŸÜÿ¥ÿßÿ° ÿßÿ≥ŸÖ ŸÖŸÑŸÅ ŸÅÿ±ŸäÿØ
        const timestamp = Date.now();
        const random = Math.random().toString(36).substring(7);
        const originalName = file.originalname.replace(/\.[^/.]+$/, ""); // ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑÿßŸÖÿ™ÿØÿßÿØ
        const safeName = originalName.replace(/[^a-zA-Z0-9-_]/g, '_');
        const publicId = `${safeName}-${timestamp}-${random}`;
        
        return {
          folder: subfolder,
          format: async () => {
            if (file.mimetype.startsWith('image')) return 'webp'; // ÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑÿµŸàÿ± ÿ•ŸÑŸâ webp
            if (file.mimetype.startsWith('video')) return 'mp4'; // ÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑŸÅŸäÿØŸäŸà ÿ•ŸÑŸâ mp4
            return file.originalname.split('.').pop();
          },
          public_id: publicId,
          transformation: file.mimetype.startsWith('image') ? [
            { width: 1200, height: 1200, crop: "limit" },
            { quality: "auto:good" },
            { fetch_format: "auto" }
          ] : [],
          resource_type: "auto"
        };
      } catch (error) {
        console.error('Cloudinary storage params error:', error);
        throw error;
      }
    },
  });

  return multer({
    storage,
    fileFilter: fileFilter(allowedTypes),
    limits: {
      fileSize: Math.max(...allowedTypes.map(type => maxFileSizes[type] || maxFileSizes.default)),
      files: 10 // ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ ŸÑÿπÿØÿØ ÿßŸÑŸÖŸÑŸÅÿßÿ™
    }
  });
};

// ÿØÿßŸÑÿ© ŸÖÿ≥ÿßÿπÿØÿ© ŸÑÿ±ŸÅÿπ ŸÖŸÑŸÅÿßÿ™ ŸÖÿ™ÿπÿØÿØÿ©
const uploadMultiple = (folder, fields, allowedTypes = ['image']) => {
  const uploader = upload(folder, allowedTypes);
  
  return (req, res, next) => {
    uploader.fields(fields)(req, res, (err) => {
      if (err) {
        if (err instanceof multer.MulterError) {
          if (err.code === 'LIMIT_FILE_SIZE') {
            return next(new AppError('ÿ≠ÿ¨ŸÖ ÿßŸÑŸÖŸÑŸÅ Ÿäÿ™ÿ¨ÿßŸàÿ≤ ÿßŸÑÿ≠ÿØ ÿßŸÑŸÖÿ≥ŸÖŸàÿ≠ ÿ®Ÿá', 400));
          }
          if (err.code === 'LIMIT_FILE_COUNT') {
            return next(new AppError('ÿ™ŸÖ ÿ±ŸÅÿπ ÿπÿØÿØ ŸÉÿ®Ÿäÿ± ÿ¨ÿØÿßŸã ŸÖŸÜ ÿßŸÑŸÖŸÑŸÅÿßÿ™', 400));
          }
          if (err.code === 'LIMIT_UNEXPECTED_FILE') {
            return next(new AppError('ÿ≠ŸÇŸÑ ŸÖŸÑŸÅ ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÇÿπ', 400));
          }
          if (err.code === 'LIMIT_PART_COUNT') {
            return next(new AppError('ÿπÿØÿØ ÿßŸÑÿ£ÿ¨ÿ≤ÿßÿ° ŸÉÿ®Ÿäÿ± ÿ¨ÿØÿßŸã', 400));
          }
        }
        return next(new AppError(err.message || 'ÿÆÿ∑ÿ£ ŸÅŸä ÿ±ŸÅÿπ ÿßŸÑŸÖŸÑŸÅ', 400));
      }
      
      // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ Ÿàÿ¨ŸàÿØ ÿßŸÑŸÖŸÑŸÅÿßÿ™ ÿßŸÑŸÖÿ∑ŸÑŸàÿ®ÿ©
      if (fields.some(field => field.required && !req.files?.[field.name])) {
        return next(new AppError(`ÿ≠ŸÇŸÑ ${field.name} ŸÖÿ∑ŸÑŸàÿ®`, 400));
      }
      
      next();
    });
  };
};

// ÿØÿßŸÑÿ© ŸÖÿ≥ÿßÿπÿØÿ© ŸÑŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑŸÖŸÑŸÅÿßÿ™ ÿßŸÑŸÖÿ±ŸÅŸàÿπÿ©
const validateUpload = (req, res, next) => {
  if (!req.file && !req.files) {
    return next(new AppError('ŸÑŸÖ Ÿäÿ™ŸÖ ÿ±ŸÅÿπ ÿ£Ÿä ŸÖŸÑŸÅ', 400));
  }
  
  // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ£ŸÜ ÿßŸÑŸÖŸÑŸÅÿßÿ™ ŸÇÿØ ÿ™ŸÖ ÿ±ŸÅÿπŸáÿß ÿ®ŸÜÿ¨ÿßÿ≠ ÿ•ŸÑŸâ Cloudinary
  if (req.file && !req.file.path) {
    return next(new AppError('ŸÅÿ¥ŸÑ ÿ±ŸÅÿπ ÿßŸÑŸÖŸÑŸÅ ÿ•ŸÑŸâ ÿßŸÑÿ≥ÿ≠ÿßÿ®ÿ©', 500));
  }
  
  if (req.files) {
    for (const fieldName in req.files) {
      for (const file of req.files[fieldName]) {
        if (!file.path) {
          return next(new AppError(`ŸÅÿ¥ŸÑ ÿ±ŸÅÿπ ŸÖŸÑŸÅ ${file.originalname}`, 500));
        }
      }
    }
  }
  
  next();
};

module.exports = upload;
module.exports.uploadMultiple = uploadMultiple;
module.exports.validateUpload = validateUpload;
module.exports.allowedMimeTypes = allowedMimeTypes;
module.exports.maxFileSizes = maxFileSizes;
</file>

<file path="src/models/conversation.model.js">
const mongoose = require("mongoose");

const conversationSchema = new mongoose.Schema(
  {
    // ŸÜŸàÿπ ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
    type: {
      type: String,
      required: true,
      enum: [
        "direct",        // ŸÖÿ®ÿßÿ¥ÿ±ÿ© ÿ®ŸäŸÜ ÿ¥ÿÆÿµŸäŸÜ
        "support",       // ŸÖÿπ ÿßŸÑÿØÿπŸÖ ÿßŸÑŸÅŸÜŸä
        "order",         // ÿÆÿßÿµÿ© ÿ®ÿßŸÑÿ∑ŸÑÿ®
        "group",         // ŸÖÿ¨ŸÖŸàÿπÿ©
        "broadcast",     // ÿ®ÿ´
      ],
      default: "direct",
      index: true,
    },
    
    // ÿπŸÜŸàÿßŸÜ ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ© (ŸÑŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑÿ¨ŸÖÿßÿπŸäÿ©)
    title: {
      type: String,
      trim: true,
      maxlength: 100,
    },
    
    // ŸàÿµŸÅ ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ© (ŸÑŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑÿ¨ŸÖÿßÿπŸäÿ©)
    description: {
      type: String,
      trim: true,
      maxlength: 500,
    },
    
    // ÿµŸàÿ±ÿ© ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
    image: {
      type: String,
    },
    
    // ÿßŸÑŸÖÿ¥ÿßÿ±ŸÉŸàŸÜ ŸÅŸä ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
    participants: [{
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
      index: true,
    }],
    
    // ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿ•ÿ∂ÿßŸÅŸäÿ© ÿ≠ÿ≥ÿ® ŸÜŸàÿπ ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
    metadata: {
      // ŸÑŸÖÿ≠ÿßÿØÿ´ÿßÿ™ ÿßŸÑÿØÿπŸÖ
      support: {
        department: {
          type: String,
          enum: ["technical", "billing", "general", "complaints"],
        },
        priority: {
          type: String,
          enum: ["low", "medium", "high", "urgent"],
          default: "medium",
        },
        status: {
          type: String,
          enum: ["open", "pending", "resolved", "closed"],
          default: "open",
        },
        assignedTo: {
          type: mongoose.Schema.Types.ObjectId,
          ref: "User",
        },
        tags: [String],
      },
      
      // ŸÑŸÖÿ≠ÿßÿØÿ´ÿßÿ™ ÿßŸÑÿ∑ŸÑÿ®ÿßÿ™
      order: {
        orderId: {
          type: mongoose.Schema.Types.ObjectId,
          ref: "Order",
        },
        restaurant: {
          type: mongoose.Schema.Types.ObjectId,
          ref: "Restaurant",
        },
        driver: {
          type: mongoose.Schema.Types.ObjectId,
          ref: "User",
        },
        status: {
          type: String,
          enum: ["active", "completed", "cancelled"],
          default: "active",
        },
      },
      
      // ŸÑŸÑŸÖÿ≠ÿßÿØÿ´ÿßÿ™ ÿßŸÑÿ¨ŸÖÿßÿπŸäÿ©
      group: {
        isPublic: {
          type: Boolean,
          default: false,
        },
        maxParticipants: {
          type: Number,
          default: 100,
        },
        admins: [{
          type: mongoose.Schema.Types.ObjectId,
          ref: "User",
        }],
        joinCode: String,
      },
    },
    
    // ÿ¢ÿÆÿ± ÿ±ÿ≥ÿßŸÑÿ©
    lastMessage: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Message",
    },
    
    // ŸàŸÇÿ™ ÿ¢ÿÆÿ± ŸÜÿ¥ÿßÿ∑
    lastActivity: {
      type: Date,
      default: Date.now,
      index: true,
    },
    
    // ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™
    notificationSettings: {
      mute: {
        type: Boolean,
        default: false,
      },
      muteUntil: Date,
      sound: {
        type: Boolean,
        default: true,
      },
      vibrate: {
        type: Boolean,
        default: true,
      },
    },
    
    // ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿÆÿµŸàÿµŸäÿ©
    privacySettings: {
      allowNewMembers: {
        type: Boolean,
        default: false,
      },
      showOnlineStatus: {
        type: Boolean,
        default: true,
      },
      showReadReceipts: {
        type: Boolean,
        default: true,
      },
      allowMedia: {
        type: Boolean,
        default: true,
      },
      allowVoiceMessages: {
        type: Boolean,
        default: true,
      },
    },
    
    // ÿßŸÑŸàÿ≥ŸàŸÖ
    tags: [{
      type: String,
      trim: true,
      index: true,
    }],
    
    // ÿ™ÿßÿ±ŸäÿÆ ÿßŸÑÿ£ÿ±ÿ¥ŸäŸÅ
    archivedAt: Date,
    
    // ÿ™ÿßÿ±ŸäÿÆ ÿßŸÑÿ≠ÿ∞ŸÅ
    deletedAt: Date,
    
    // ÿ™ÿßÿ±ŸäÿÆ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° (ŸÑŸÑŸÖÿ≠ÿßÿØÿ´ÿßÿ™ ÿßŸÑŸÖÿ§ŸÇÿ™ÿ©)
    expiresAt: {
      type: Date,
    },
    
    // ÿßŸÑÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™
    stats: {
      messageCount: {
        type: Number,
        default: 0,
      },
      participantCount: {
        type: Number,
        default: 0,
      },
      unreadCount: {
        type: Number,
        default: 0,
      },
      lastMessageAt: Date,
      firstMessageAt: Date,
    },
  },
  {
    timestamps: true,
    toJSON: { virtuals: true },
    toObject: { virtuals: true },
  }
);

// Indexes
conversationSchema.index({ participants: 1, lastActivity: -1 });
conversationSchema.index({ type: 1, "metadata.order.orderId": 1 });
conversationSchema.index({ "metadata.support.status": 1 });
conversationSchema.index({ expiresAt: 1 }, { expireAfterSeconds: 0 });

// Middleware
conversationSchema.pre("save", function(next) {
  // ÿ™ÿ≠ÿØŸäÿ´ ÿπÿØÿØ ÿßŸÑŸÖÿ¥ÿßÿ±ŸÉŸäŸÜ
  this.stats.participantCount = this.participants.length;
  
  // ÿ™ÿ≠ÿØŸäÿ´ ÿ¢ÿÆÿ± ŸÜÿ¥ÿßÿ∑
  if (this.isModified("lastActivity")) {
    this.lastActivity = new Date();
  }
  
  // ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ŸÖÿ≠ÿßÿØÿ´ÿ© ÿ∑ŸÑÿ® Ÿàÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿßŸÑÿ∑ŸÑÿ®ÿå ÿ£ÿ±ÿ¨ÿπ ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
  if (this.type === "order" && this.metadata.order?.status === "cancelled") {
    this.expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7 ÿ£ŸäÿßŸÖ
  }
  
  next();
});

// Virtuals
conversationSchema.virtual("isActive").get(function() {
  if (this.expiresAt && this.expiresAt < new Date()) {
    return false;
  }
  
  if (this.archivedAt || this.deletedAt) {
    return false;
  }
  
  if (this.type === "order" && this.metadata.order?.status !== "active") {
    return false;
  }
  
  return true;
});

conversationSchema.virtual("isGroup").get(function() {
  return this.participants.length > 2 || this.type === "group";
});

conversationSchema.virtual("isSupport").get(function() {
  return this.type === "support";
});

conversationSchema.virtual("isOrder").get(function() {
  return this.type === "order";
});

// Methods
conversationSchema.methods.addParticipant = async function(userId) {
  if (!this.participants.includes(userId)) {
    this.participants.push(userId);
    await this.save();
  }
  return this;
};

conversationSchema.methods.removeParticipant = async function(userId) {
  this.participants = this.participants.filter(
    participant => participant.toString() !== userId.toString()
  );
  await this.save();
  return this;
};

conversationSchema.methods.updateLastMessage = async function(messageId) {
  this.lastMessage = messageId;
  this.lastActivity = new Date();
  this.stats.lastMessageAt = new Date();
  
  if (!this.stats.firstMessageAt) {
    this.stats.firstMessageAt = new Date();
  }
  
  this.stats.messageCount += 1;
  await this.save();
  return this;
};

conversationSchema.methods.mute = async function(duration = null) {
  this.notificationSettings.mute = true;
  
  if (duration) {
    const muteUntil = new Date();
    muteUntil.setHours(muteUntil.getHours() + duration);
    this.notificationSettings.muteUntil = muteUntil;
  }
  
  await this.save();
  return this;
};

conversationSchema.methods.unmute = async function() {
  this.notificationSettings.mute = false;
  this.notificationSettings.muteUntil = null;
  await this.save();
  return this;
};

conversationSchema.methods.archive = async function() {
  this.archivedAt = new Date();
  await this.save();
  return this;
};

conversationSchema.methods.unarchive = async function() {
  this.archivedAt = null;
  await this.save();
  return this;
};

conversationSchema.methods.markAsDeleted = async function() {
  this.deletedAt = new Date();
  await this.save();
  return this;
};

// Static Methods
conversationSchema.statics.findByParticipants = async function(participantIds, type = "direct") {
  const query = {
    type,
    participants: { $all: participantIds, $size: participantIds.length },
    deletedAt: null,
  };
  
  return await this.findOne(query);
};

conversationSchema.statics.createDirectChat = async function(user1Id, user2Id) {
  const existingChat = await this.findByParticipants([user1Id, user2Id], "direct");
  
  if (existingChat) {
    return existingChat;
  }
  
  const chat = await this.create({
    type: "direct",
    participants: [user1Id, user2Id],
    lastActivity: new Date(),
  });
  
  return chat;
};

conversationSchema.statics.createSupportChat = async function(userId, department = "general") {
  const User = require("./user.model");
  
  // ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ŸÖŸÖÿ´ŸÑ ÿØÿπŸÖ ŸÖÿ™ÿßÿ≠
  const supportAgent = await User.findOne({
    role: "admin",
    "preferences.supportAgent": true,
    isOnline: true,
  });
  
  const chat = await this.create({
    type: "support",
    participants: [userId, ...(supportAgent ? [supportAgent._id] : [])],
    metadata: {
      support: {
        department,
        priority: department === "complaints" ? "high" : "medium",
        status: "open",
        assignedTo: supportAgent?._id || null,
        tags: [department, "new"],
      },
    },
    lastActivity: new Date(),
  });
  
  return chat;
};

conversationSchema.statics.createOrderChat = async function(orderId, userId, driverId = null, restaurantId = null) {
  const participants = [userId];
  
  if (driverId) participants.push(driverId);
  
  const chat = await this.create({
    type: "order",
    title: `ŸÖÿ≠ÿßÿØÿ´ÿ© ÿßŸÑÿ∑ŸÑÿ® #${orderId.toString().slice(-6)}`,
    participants,
    metadata: {
      order: {
        orderId,
        restaurant: restaurantId,
        driver: driverId,
        status: "active",
      },
    },
    expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 ŸäŸàŸÖ
    lastActivity: new Date(),
  });
  
  return chat;
};

conversationSchema.statics.createGroupChat = async function(creatorId, title, description = "", participants = [], isPublic = false) {
  const allParticipants = [...new Set([creatorId, ...participants])];
  
  const chat = await this.create({
    type: "group",
    title,
    description,
    participants: allParticipants,
    image: null,
    metadata: {
      group: {
        isPublic,
        maxParticipants: 100,
        admins: [creatorId],
        joinCode: isPublic ? Math.random().toString(36).substring(2, 8).toUpperCase() : null,
      },
    },
    lastActivity: new Date(),
  });
  
  return chat;
};

conversationSchema.statics.getUserConversations = async function(userId, options = {}) {
  const {
    page = 1,
    limit = 20,
    type,
    archived = false,
    includeExpired = false,
  } = options;
  
  const skip = (page - 1) * limit;
  
  const query = {
    participants: userId,
    deletedAt: null,
  };
  
  if (type) query.type = type;
  
  if (!archived) {
    query.archivedAt = null;
  }
  
  if (!includeExpired) {
    query.$or = [
      { expiresAt: null },
      { expiresAt: { $gt: new Date() } },
    ];
  }
  
  const [conversations, total] = await Promise.all([
    this.find(query)
      .populate("participants", "name image role isOnline")
      .populate("lastMessage")
      .sort({ lastActivity: -1 })
      .skip(skip)
      .limit(limit)
      .lean(),
    
    this.countDocuments(query),
  ]);
  
  // ÿ≠ÿ≥ÿßÿ® ÿπÿØÿØ ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿ∫Ÿäÿ± ÿßŸÑŸÖŸÇÿ±Ÿàÿ°ÿ© ŸÑŸÉŸÑ ŸÖÿ≠ÿßÿØÿ´ÿ©
  const Message = require("./message.model");
  
  for (const conversation of conversations) {
    conversation.unreadCount = await Message.countDocuments({
      conversation: conversation._id,
      "readBy.user": { $ne: userId },
      sender: { $ne: userId },
    });
    
    conversation.isActive = conversation.expiresAt 
      ? conversation.expiresAt > new Date() 
      : true;
  }
  
  return {
    conversations,
    pagination: {
      page,
      limit,
      total,
      totalPages: Math.ceil(total / limit),
    },
  };
};

module.exports = mongoose.model("Conversation", conversationSchema);
</file>

<file path="src/models/item.model.js">
const mongoose = require("mongoose");

const itemSchema = new mongoose.Schema(
  {
    name: {
      type: String,
      required: true,
      trim: true,
    },
    price: {
      type: Number,
      required: true,
      min: 0,
    },
    image: {
      type: String,
    },
    description: {
      type: String,
      trim: true,
    },
    category: {
      type: String,
      default: "main",
      enum: ["appetizer", "main", "dessert", "drink", "side", "special"],
    },
    restaurant: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Restaurant",
      required: true,
      index: true,
    },
    isAvailable: {
      type: Boolean,
      default: true,
    },
    ingredients: [{
      type: String,
      trim: true,
    }],
    preparationTime: {
      type: Number, // ÿ®ÿßŸÑÿØŸÇÿßÿ¶ŸÇ
      default: 15,
    },
    spicyLevel: {
      type: Number,
      min: 0,
      max: 3,
      default: 0,
    },
    isVegetarian: {
      type: Boolean,
      default: false,
    },
    isVegan: {
      type: Boolean,
      default: false,
    },
    calories: {
      type: Number,
      min: 0,
    },
  },
  { 
    timestamps: true,
    toJSON: { virtuals: true },
    toObject: { virtuals: true }
  }
);

// ÿ•ŸÜÿ¥ÿßÿ° index ŸÑŸÑÿ®ÿ≠ÿ´ ÿßŸÑÿ≥ÿ±Ÿäÿπ
itemSchema.index({ name: "text", description: "text", category: 1 });
itemSchema.index({ restaurant: 1, category: 1 });
itemSchema.index({ restaurant: 1, isAvailable: 1 });

module.exports = mongoose.model("Item", itemSchema);
</file>

<file path="src/models/restaurant.model.js">
const mongoose = require("mongoose");

const restaurantSchema = new mongoose.Schema(
  {
    image: {
      type: String,
    },
    coverImage: {
      type: String,
    },
    name: {
      type: String,
      required: true,
      trim: true,
    },
    description: String,
    isOpen: {
      type: Boolean,
      default: true,
    },
    createdBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
    },
    averageRating: {
      type: Number,
      default: 0,
    },
    ratingsCount: {
      type: Number,
      default: 0,
    },
    type: {
      type: String,
      default: "restaurant",
      enum: ["restaurant", "cafe", "bakery", "fast-food", "grocery", "pharmacy", "other"],
    },
    phone: {
      type: String,
      trim: true,
    },
    email: {
      type: String,
      trim: true,
      lowercase: true,
    },
    openingHours: {
      type: Map,
      of: String, // ŸäŸàŸÖ: ÿ≥ÿßÿπÿßÿ™ ŸÖÿ´ŸÑ "09:00-22:00"
      default: {},
    },
    deliveryFee: {
      type: Number,
      default: 0,
    },
    minOrderAmount: {
      type: Number,
      default: 0,
    },
    estimatedDeliveryTime: {
      type: Number, // ÿ®ÿßŸÑÿØŸÇÿßÿ¶ŸÇ
      default: 30,
    },
    tags: [{
      type: String,
      trim: true,
    }],
  },
  { timestamps: true }
);

restaurantSchema.virtual("items", {
  ref: "Item",
  localField: "_id",
  foreignField: "restaurant",
});

restaurantSchema.virtual("addresses", {
  ref: "RestaurantAddress",
  localField: "_id",
  foreignField: "restaurant",
});

restaurantSchema.virtual("reviews", {
  ref: "Review",
  localField: "_id",
  foreignField: "restaurant",
});

restaurantSchema.set("toObject", { virtuals: true });
restaurantSchema.set("toJSON", { virtuals: true });

module.exports = mongoose.model("Restaurant", restaurantSchema);
</file>

<file path="src/routes/aggregate.routes.js">
const express = require('express');
const router = express.Router();
const auth = require('../middlewares/auth.middleware');
const role = require('../middlewares/role.middleware');
const aggregateController = require('../controllers/aggregate.controller');
const PaginationUtils = require('../utils/pagination.util');

/**
 * üìä ÿ®ŸäÿßŸÜÿßÿ™ ŸÑŸàÿ≠ÿ© ÿ™ÿ≠ŸÉŸÖ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
 * Ÿäÿ≠ÿ™ÿßÿ¨: ÿ™Ÿàÿ´ŸäŸÇ
 */
router.get('/dashboard', auth, aggregateController.getDashboardData);

/**
 * üè™ ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿßŸÑŸÖÿ∑ÿßÿπŸÖ ŸÖÿπ Pagination
 * GET /api/aggregate/restaurants
 * Query params:
 * - page: ÿ±ŸÇŸÖ ÿßŸÑÿµŸÅÿ≠ÿ© (default: 1)
 * - limit: ÿπÿØÿØ ÿßŸÑÿπŸÜÿßÿµÿ± ŸÅŸä ÿßŸÑÿµŸÅÿ≠ÿ© (default: 10, max: 50)
 * - search: ŸÜÿµ ŸÑŸÑÿ®ÿ≠ÿ´
 * - sortBy: ÿßŸÑÿ≠ŸÇŸÑ ŸÑŸÑÿ™ÿ±ÿ™Ÿäÿ®
 * - sortOrder: asc/desc
 * - filter[type]: ŸÅŸÑÿ™ÿ±ÿ© ÿ≠ÿ≥ÿ® ÿßŸÑŸÜŸàÿπ
 * - filter[tags]: ŸÅŸÑÿ™ÿ±ÿ© ÿ≠ÿ≥ÿ® ÿßŸÑŸàÿ≥ŸàŸÖ
 * - minRating: ÿ£ŸÇŸÑ ÿ™ŸÇŸäŸäŸÖ
 */
router.get(
  '/restaurants',
  PaginationUtils.validatePaginationParams,
  aggregateController.getRestaurantsPaginated
);

/**
 * üçΩÔ∏è ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿßŸÑÿπŸÜÿßÿµÿ± ŸÖÿπ Pagination
 * GET /api/aggregate/items
 * Query params ÿ•ÿ∂ÿßŸÅŸäÿ©:
 * - filter[restaurant]: ŸÅŸÑÿ™ÿ±ÿ© ÿ≠ÿ≥ÿ® ÿßŸÑŸÖÿ∑ÿπŸÖ
 * - filter[category]: ŸÅŸÑÿ™ÿ±ÿ© ÿ≠ÿ≥ÿ® ÿßŸÑŸÅÿ¶ÿ©
 * - minPrice: ÿ£ŸÇŸÑ ÿ≥ÿπÿ±
 * - maxPrice: ÿ£ÿπŸÑŸâ ÿ≥ÿπÿ±
 * - filter[isVegetarian]: ŸÜÿ®ÿßÿ™Ÿä
 * - filter[isVegan]: ŸÅŸäÿ∫ÿßŸÜ
 */
router.get(
  '/items',
  PaginationUtils.validatePaginationParams,
  aggregateController.getItemsPaginated
);

/**
 * üì¶ ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿßŸÑÿ∑ŸÑÿ®ÿßÿ™ ŸÖÿπ Pagination (ŸÑŸÑÿ£ÿØŸÖŸÜ ŸÅŸÇÿ∑)
 * GET /api/aggregate/orders/admin
 * Query params ÿ•ÿ∂ÿßŸÅŸäÿ©:
 * - filter[status]: ÿ≠ÿßŸÑÿ© ÿßŸÑÿ∑ŸÑÿ®
 * - filter[restaurant]: ÿßŸÑŸÖÿ∑ÿπŸÖ
 * - filter[driver]: ÿßŸÑŸÖŸÜÿØŸàÿ®
 * - minDate: ŸÖŸÜ ÿ™ÿßÿ±ŸäÿÆ
 * - maxDate: ÿ•ŸÑŸâ ÿ™ÿßÿ±ŸäÿÆ
 */
router.get(
  '/orders/admin',
  auth,
  role('admin'),
  PaginationUtils.validatePaginationParams,
  aggregateController.getOrdersPaginatedAdmin
);

/**
 * üìä ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ™ŸÇŸäŸäŸÖÿßÿ™ ŸÖÿ∑ÿπŸÖ ŸÖÿπ Pagination
 * GET /api/aggregate/reviews/:restaurantId
 */
// ‚ö†Ô∏è ŸÑÿßÿ≠ÿ∏: Ÿáÿ∞Ÿá ÿßŸÑŸàÿ∏ŸäŸÅÿ© ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØÿ© ŸÅŸä ÿßŸÑŸÄ controllerÿå ÿ≥ÿ£ŸÜÿ¥ÿ¶Ÿáÿß ŸÑÿßÿ≠ŸÇÿßŸã

/**
 * üè™ ÿ™ŸÅÿßÿµŸäŸÑ ŸÖÿ∑ÿπŸÖ ŸÉÿßŸÖŸÑÿ© (ÿ®ÿØŸàŸÜ ÿ™Ÿàÿ´ŸäŸÇ)
 */
router.get('/restaurants/:id/full', aggregateController.getRestaurantDetails);

/**
 * üì¶ ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑÿ∑ŸÑÿ® ŸÖÿπ ÿßŸÑÿ™ÿ™ÿ®ÿπ
 * Ÿäÿ≠ÿ™ÿßÿ¨: ÿ™Ÿàÿ´ŸäŸÇ + ÿßŸÑÿπŸÖŸäŸÑ ŸÅŸÇÿ∑
 */
router.get('/orders/:id/full', auth, role('client'), aggregateController.getOrderWithTracking);

/**
 * üè† ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿµŸÅÿ≠ÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ© (ŸÑŸÑÿπÿ±ÿ∂ ÿßŸÑÿπÿßŸÖ)
 */
router.get('/home', aggregateController.getHomeData);

/**
 * üîß ÿ®ŸäÿßŸÜÿßÿ™ ŸÑŸàÿ≠ÿ© ÿ™ÿ≠ŸÉŸÖ ÿßŸÑÿ£ÿØŸÖŸÜ
 * Ÿäÿ≠ÿ™ÿßÿ¨: ÿ™Ÿàÿ´ŸäŸÇ + ÿ£ÿØŸÖŸÜ ŸÅŸÇÿ∑
 */
router.get('/admin/dashboard', auth, role('admin'), async (req, res) => {
    try {
        const Order = require('../models/order.model');
        const User = require('../models/user.model');
        const Restaurant = require('../models/restaurant.model');
        const DriverLocation = require('../models/driverLocation.model');

        const [
            totalUsers,
            totalOrders,
            totalRestaurants,
            pendingOrders,
            activeDrivers,
            recentOrders
        ] = await Promise.all([
            User.countDocuments(),
            Order.countDocuments(),
            Restaurant.countDocuments(),
            Order.countDocuments({ status: 'pending' }),
            DriverLocation.distinct('driver'),
            Order.find()
                .populate('user', 'name')
                .populate('driver', 'name')
                .sort({ createdAt: -1 })
                .limit(10)
        ]);

        res.json({
            success: true,
            data: {
                stats: {
                    totalUsers,
                    totalOrders,
                    totalRestaurants,
                    pendingOrders,
                    activeDrivers: activeDrivers.length
                },
                recentOrders,
                charts: {
                    ordersByStatus: await getOrdersByStatus()
                }
            }
        });
    } catch (error) {
        console.error('Admin dashboard error:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Failed to load admin dashboard' 
        });
    }
});

// ÿØÿßŸÑÿ© ŸÖÿ≥ÿßÿπÿØÿ© ÿØÿßÿÆŸÑŸäÿ©
async function getOrdersByStatus() {
    try {
        const Order = require('../models/order.model');
        const result = await Order.aggregate([
            { $group: { _id: '$status', count: { $sum: 1 } } }
        ]);

        return result.reduce((acc, curr) => {
            acc[curr._id] = curr.count;
            return acc;
        }, {});
    } catch (error) {
        console.error('Orders by status error:', error);
        return {};
    }
}

router.post('/cache/clear', auth, role('admin'), aggregateController.clearCache);

/**
 * üìä ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑŸÉÿßÿ¥ (ŸÑŸÑÿ£ÿØŸÖŸÜ ŸÅŸÇÿ∑)
 */
router.get('/cache/stats', auth, role('admin'), aggregateController.getCacheStats);

module.exports = router;
</file>

<file path="src/routes/auth.routes.js">
const express = require("express");
const router = express.Router();
const authController = require("../controllers/auth.controller");
const { validateRegister, validateLogin } = require('../middlewares/validation.middleware');



router.post("/register", validateRegister, authController.register);
router.post("/login", validateLogin, authController.login);


module.exports = router;
</file>

<file path="src/routes/item.routes.js">
const express = require("express");
const router = express.Router();
const itemController = require("../controllers/item.controller");
const auth = require("../middlewares/auth.middleware");
const role = require("../middlewares/role.middleware");
const upload = require("../middlewares/upload");
const PaginationUtils = require('../utils/pagination.util');

// GET all items with pagination
router.get('/', PaginationUtils.validatePaginationParams, itemController.getItemsPaginated);

router.post(
  "/",
  auth,
  role("admin"),
  upload("items").single("image"),
  itemController.createItem
);

// PUT image
router.put(
  "/:id/image",
  auth,
  role("admin"),
  upload("items").single("image"),
  itemController.updateItemImage
);

router.delete(
  "/:id",
  auth,
  role("admin"),
  itemController.deleteItem
);

module.exports = router;
</file>

<file path="src/routes/order.routes.js">
const express = require("express");
const router = express.Router();

const orderController = require("../controllers/order.controller");
const auth = require("../middlewares/auth.middleware");
const role = require("../middlewares/role.middleware");
const { noCache } = require('../middlewares/cache.middleware');
const PaginationUtils = require('../utils/pagination.util');
const { validateOrder } = require('../middlewares/validation.middleware');

/**
 * üè† ÿßŸÑÿπŸÖŸÑÿßÿ° ŸÅŸÇÿ∑
 * ÿ•ŸÜÿ¥ÿßÿ° ÿ∑ŸÑÿ® ÿ¨ÿØŸäÿØ ŸÖŸÜ ÿ£Ÿä ÿπŸÜŸàÿßŸÜ ÿ•ŸÑŸâ ÿ£Ÿä ÿπŸÜŸàÿßŸÜ
 * POST /api/orders
 */
router.post("/", auth, role("client"), validateOrder, orderController.createOrder);

/**
 * üë§ ÿßŸÑÿπŸÖŸÑÿßÿ° ŸÅŸÇÿ∑ - ŸÖÿπ Pagination
 * GET /api/orders/me
 */
router.get('/me', auth, role('client'), PaginationUtils.validatePaginationParams, orderController.getMyOrdersPaginated);

/**
 * üîë ÿßŸÑÿ£ÿØŸÖŸÜ ŸÅŸÇÿ∑ - ŸÖÿπ Pagination
 * GET /api/orders
 */
router.get('/', auth, role('admin'), PaginationUtils.validatePaginationParams, orderController.getAllOrdersPaginated);

/**
 * üîß ÿßŸÑÿ£ÿØŸÖŸÜ ŸÅŸÇÿ∑
 * ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ ÿßŸÑŸÖŸÜÿØŸàÿ® ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß
 * PUT /api/orders/:orderId/reassign
 */
router.put("/:orderId/reassign", auth, role("admin"), orderController.reassignDriver);

/**
 * üîß ÿßŸÑÿ£ÿØŸÖŸÜ ŸÅŸÇÿ∑
 * ÿ™ÿπŸäŸäŸÜ ŸÖŸÜÿØŸàÿ® ŸäÿØŸàŸäŸãÿß
 * PUT /api/orders/:id/assign
 */
router.put("/:id/assign", auth, role("admin"), orderController.assignDriver);

/**
 * üöö ÿßŸÑŸÖŸÜÿØŸàÿ® ŸÅŸÇÿ∑
 * ÿ™ÿ≠ÿØŸäÿ´ ÿ≠ÿßŸÑÿ© ÿßŸÑÿ∑ŸÑÿ®
 * PUT /api/orders/:id/status
 */
router.put("/:id/status", auth, role("driver"), noCache, orderController.updateStatus);

/**
 * üöö ÿßŸÑŸÖŸÜÿØŸàÿ® ŸÅŸÇÿ∑
 * ÿ™ÿ≠ÿØŸäÿ´ ŸÖŸàŸÇÿπ ÿßŸÑŸÖŸÜÿØŸàÿ®
 * POST /api/orders/:id/location
 */
router.post("/:id/location", auth, role("driver"), orderController.updateDriverLocation);

/**
 * ‚ùå ÿ•ŸÑÿ∫ÿßÿ° ÿßŸÑÿ∑ŸÑÿ® (ÿßŸÑÿπŸÖŸäŸÑ ŸÅŸÇÿ∑)
 * PUT /api/orders/:id/cancel
 */
router.put("/:id/cancel", auth, role("client"), orderController.cancelOrder);

/**
 * üöö ÿßŸÑŸÖŸÜÿØŸàÿ® ŸÅŸÇÿ∑
 * ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ∑ŸÑÿ®ÿßÿ™ ÿßŸÑŸÖŸÜÿØŸàÿ®
 * GET /api/orders/driver/me
 */
router.get("/driver/me", auth, role("driver"), PaginationUtils.validatePaginationParams, orderController.getDriverOrders);

/**
 * üìã ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ™ŸÅÿßÿµŸäŸÑ ÿ∑ŸÑÿ® ŸÖÿπŸäŸÜ
 * GET /api/orders/:id
 */
router.get("/:id", auth, async (req, res) => {
  try {
    const orderId = req.params.id;
    const userId = req.user.id;
    const userRole = req.user.role;

    const order = await Order.findById(orderId)
      .populate('user', 'name phone')
      .populate('driver', 'name phone')
      .populate('restaurant', 'name image')
      .populate('pickupAddress')
      .populate('deliveryAddress');

    if (!order) {
      return res.status(404).json({
        success: false,
        message: 'ÿßŸÑÿ∑ŸÑÿ® ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ'
      });
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿµŸÑÿßÿ≠Ÿäÿßÿ™
    const isOwner = order.user._id.toString() === userId;
    const isDriver = order.driver && order.driver._id.toString() === userId;
    const isAdmin = userRole === 'admin';

    if (!isOwner && !isDriver && !isAdmin) {
      return res.status(403).json({
        success: false,
        message: 'ÿ∫Ÿäÿ± ŸÖÿµÿ±ÿ≠ ŸÑŸÉ ÿ®ÿßŸÑŸàÿµŸàŸÑ ÿ•ŸÑŸâ Ÿáÿ∞ÿß ÿßŸÑÿ∑ŸÑÿ®'
      });
    }

    res.json({
      success: true,
      data: order
    });
  } catch (error) {
    console.error('Get order error:', error);
    res.status(500).json({
      success: false,
      message: 'ŸÅÿ¥ŸÑ ÿ¨ŸÑÿ® ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ∑ŸÑÿ®'
    });
  }
});

module.exports = router;
</file>

<file path="src/routes/restaurant.routes.js">
const express = require("express");
const router = express.Router();
const restaurantController = require("../controllers/restaurant.controller");
const auth = require("../middlewares/auth.middleware");
const role = require("../middlewares/role.middleware");
const upload = require("../middlewares/upload");
const reviewRoutes = require("./review.routes");

// ÿßÿ≥ÿ™Ÿäÿ±ÿßÿØ PaginationUtils
const PaginationUtils = require('../utils/pagination.util');

// Middleware ŸÑÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿµŸàÿ± ŸÑŸÑŸÖÿ∑ÿßÿπŸÖ (image + coverImage)
const restaurantUpload = upload("restaurants").fields([
  { name: "image", maxCount: 1 },
  { name: "coverImage", maxCount: 1 }, 
]);

// ======== ROUTES ========

// GET all restaurants with pagination
router.get('/', PaginationUtils.validatePaginationParams, restaurantController.getRestaurantsPaginated);

// Advanced search with pagination
router.get('/search/advanced', PaginationUtils.validatePaginationParams, restaurantController.advancedSearch);

// ‚úÖ ÿßŸÑÿ®ÿ≠ÿ´ ÿ®ÿßŸÑÿßÿ≥ŸÖ ŸàÿßŸÑŸÜŸàÿπ
router.get("/search", restaurantController.searchRestaurants);

// GET ŸÖÿ∑ÿπŸÖ ŸÖÿπ ÿ¨ŸÖŸäÿπ ÿßŸÑÿπŸÜÿßŸàŸäŸÜ
router.get("/:id/details", restaurantController.getRestaurantWithAddress);

// POST ÿ•ŸÜÿ¥ÿßÿ° ŸÖÿ∑ÿπŸÖ ÿ¨ÿØŸäÿØ ŸÖÿπ ÿ±ŸÅÿπ ÿßŸÑÿµŸàÿ±
router.post(
  "/",
  auth,
  role("admin"),
  restaurantUpload,
  restaurantController.createRestaurant
);

// ======== Reviews ========
router.use("/:id/reviews", reviewRoutes);

// PUT ÿ™ÿ≠ÿØŸäÿ´ ÿµŸàÿ±ÿ© ÿßŸÑÿ∫ŸÑÿßŸÅ
router.put(
  "/:id/cover",
  auth,
  role("admin"),
  upload("restaurants").single("image"),
  restaurantController.updateCoverImage
);

// PUT ÿ™ÿ≠ÿØŸäÿ´ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ∑ÿπŸÖ (ÿßÿ≥ŸÖÿå ŸàÿµŸÅÿå ÿ≠ÿßŸÑÿ© ŸÖŸÅÿ™Ÿàÿ≠/ŸÖÿ∫ŸÑŸÇ)
router.put(
  "/:id",
  auth,
  role("admin"),
  restaurantController.updateRestaurant
);

// DELETE ÿ≠ÿ∞ŸÅ ÿßŸÑŸÖÿ∑ÿπŸÖ
router.delete(
  "/:id",
  auth,
  role("admin"),
  restaurantController.deleteRestaurant
);

module.exports = router;
</file>

<file path="src/server.js">
require("dotenv").config();
const http = require("http");
const app = require("./app");
const connectDB = require("./config/db");
const socketService = require("./services/socket.service");

const PORT = process.env.PORT || 3000;

// connect database
connectDB(); 

// create http server
const server = http.createServer(app);

// ÿ™ŸáŸäÿ¶ÿ© Socket.io ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ socketService
socketService.initialize(server);

// ÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ Ÿàÿ¨ŸàÿØ notificationCleanupJob ŸÇÿ®ŸÑ ÿßÿ≥ÿ™ÿØÿπÿßÿ¶Ÿá
let notificationCleanupJob;
try {
  notificationCleanupJob = require("./jobs/notificationCleanup.job");
  if (notificationCleanupJob && notificationCleanupJob.start) {
    notificationCleanupJob.start();
  }
} catch (error) {
  console.log("‚ö†Ô∏è Notification cleanup job not found or has errors:", error.message);
}

// start server
server.listen(PORT, () => {
  console.log(`üöÄ Server running on http://localhost:${PORT}`);
  console.log(`üì° Socket.io service: ${socketService.isInitialized() ? '‚úÖ Ready' : '‚ùå Not ready'}`);
});

// Handle graceful shutdown
process.on("SIGTERM", () => {
  console.log("üëã SIGTERM received. Shutting down gracefully...");
  
  if (notificationCleanupJob && notificationCleanupJob.stop) {
    notificationCleanupJob.stop();
  }
  
  server.close(() => {
    console.log("üí§ Server closed");
    process.exit(0);
  });
});
</file>

<file path="src/socket.js">
const socketService = require("./services/socket.service");

const initSocket = (server) => {
  try {
    const io = socketService.initialize(server);
    
    if (server && server.app) {
      server.app.set('io', io);
      server.app.set('socketService', socketService);
    }
    
    console.log("‚úÖ Socket.io initialized successfully");
    return io;
  } catch (error) {
    console.error("‚ùå Socket.io initialization failed:", error.message);
    // ŸÑÿß ŸÜŸàŸÇŸÅ ÿßŸÑÿÆÿßÿØŸÖ ÿ•ÿ∞ÿß ŸÅÿ¥ŸÑÿ™ ÿßŸÑŸÄ sockets
    return null;
  }
};

module.exports = initSocket;
</file>

<file path="package.json">
{
  "name": "backend",
  "version": "1.0.0",
  "description": "",
  "main": "server.js",
  "scripts": {
    "start": "node src/server.js",
    "dev": "nodemon src/server.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "dependencies": {
    "bcryptjs": "^3.0.3",
    "check-disk-space": "^3.4.0",
    "cloudinary": "^1.41.3",
    "compression": "^1.8.1",
    "cors": "^2.8.6",
    "dotenv": "^17.2.3",
    "express": "^5.2.1",
    "express-rate-limit": "^8.2.1",
    "helmet": "^8.1.0",
    "jsonwebtoken": "^9.0.3",
    "mongodb": "^7.1.0",
    "mongoose": "^9.1.5",
    "multer": "^2.0.2",
    "multer-storage-cloudinary": "^4.0.0",
    "node-cache": "^5.1.2",
    "node-cron": "^4.2.1",
    "socket.io": "^4.8.3",
    "socket.io-client": "^4.8.3",
    "swagger-jsdoc": "^6.2.8",
    "swagger-ui-express": "^5.0.1",
    "winston": "^3.19.0"
  },
  "devDependencies": {
    "jest": "^30.2.0",
    "mongodb-memory-server": "^11.0.1",
    "nodemon": "^3.1.11",
    "supertest": "^7.2.2"
  }
}
</file>

<file path="src/controllers/auth.controller.js">
const User = require("../models/user.model");
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");
const crypto = require("crypto");
const cache = require("../utils/cache.util");

// Register
exports.register = async (req, res) => {
  const { name, phone, password } = req.body;

  const exists = await User.findOne({ phone });
  if (exists) {
    return res.status(400).json({ message: "User already exists" });
  }

  const hashedPassword = await bcrypt.hash(password, 10);

  const user = await User.create({
    name,
    phone,
    password: hashedPassword,
  });

  res.status(201).json({ message: "User registered" });
};

// Login
exports.login = async (req, res) => {
  try {
    const { phone, password } = req.body;

    // 1. ÿßÿ®ÿ≠ÿ´ ÿπŸÜ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÖÿπ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± (ŸÖŸáŸÖ: select('+password'))
    const user = await User.findOne({ phone }).select('+password +isActive +isVerified');
    
    if (!user) {
      return res.status(400).json({ 
        success: false,
        message: "ÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ ÿ£Ÿà ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠ÿ©" 
      });
    }

    // 2. ÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ≠ÿßŸÑÿ© ÿßŸÑÿ≠ÿ≥ÿßÿ®
    if (!user.isActive) {
      return res.status(403).json({ 
        success: false,
        message: "ÿßŸÑÿ≠ÿ≥ÿßÿ® ŸÖÿπÿ∑ŸÑÿå ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑÿ™ŸàÿßÿµŸÑ ŸÖÿπ ÿßŸÑÿØÿπŸÖ" 
      });
    }

    // 3. ÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±
    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) {
      return res.status(400).json({ 
        success: false,
        message: "ÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ ÿ£Ÿà ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠ÿ©" 
      });
    }

    // 4. ÿ£ŸÜÿ¥ÿ¶ ÿßŸÑÿ™ŸàŸÉŸÜ
    const token = jwt.sign(
      { 
        id: user._id, 
        role: user.role,
        phone: user.phone 
      },
      process.env.JWT_SECRET || 'fallback-secret-key-change-in-production',
      { expiresIn: "7d" }
    );

    // 5. ÿ≥ÿ¨ŸÑ ŸÜÿ¥ÿßÿ∑ ÿßŸÑÿØÿÆŸàŸÑ
    await user.logActivity('login', {
      ip: req.ip,
      userAgent: req.get('user-agent')
    });

    // 6. ÿ™ÿ≠ÿØŸäÿ´ ÿ¢ÿÆÿ± ÿØÿÆŸàŸÑ
    user.lastLogin = new Date();
    await user.save({ validateBeforeSave: false });

    // 7. ÿ£ÿπÿØ ÿßŸÑÿ±ÿØ (ÿ®ÿØŸàŸÜ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±)
    const userResponse = user.toObject();
    delete userResponse.password;

    res.json({ 
      success: true,
      token,
      user: userResponse,
      message: "ÿ™ŸÖ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ÿ®ŸÜÿ¨ÿßÿ≠"
    });

  } catch (error) {
    console.error('Login error:', error);
    
    res.status(500).json({ 
      success: false,
      message: "ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ",
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};


/**
 * üîê ÿ™ÿ≥ÿ¨ŸäŸÑ ŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ¨ÿØŸäÿØ ŸÖÿ™ŸÇÿØŸÖ
 * POST /api/auth/register/complete
 */
exports.registerComplete = async (req, res) => {
  try {
    const { name, phone, password, email, role = "client", ...additionalData } = req.body;

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
    if (!name || !phone || !password) {
      return res.status(400).json({
        success: false,
        message: "Name, phone, and password are required",
      });
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ Ÿàÿ¨ŸàÿØ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
    const exists = await User.findOne({ phone });
    if (exists) {
      return res.status(400).json({
        success: false,
        message: "User already exists",
      });
    }

    // ÿ™ÿ¨ŸáŸäÿ≤ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
    const userData = {
      name,
      phone,
      password: await bcrypt.hash(password, 10),
      email,
      role,
      isVerified: false,
      stats: {
        joinedDate: new Date(),
      },
      preferences: {
        notifications: {
          email: true,
          sms: true,
          push: true,
          orderUpdates: true,
          promotions: true,
        },
        language: "ar",
        currency: "XOF",
        theme: "light",
      },
    };

    // ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ•ÿ∂ÿßŸÅŸäÿ© ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ŸÖŸàÿ¨ŸàÿØÿ©
    if (additionalData.dateOfBirth) {
      userData.dateOfBirth = new Date(additionalData.dateOfBirth);
    }

    if (additionalData.gender) {
      userData.gender = additionalData.gender;
    }

    if (additionalData.city) {
      userData.city = additionalData.city;
    }

    // ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
    const user = await User.create(userData);

    // ÿ•ŸÜÿ¥ÿßÿ° verification code
    const verificationCode = crypto.randomBytes(3).toString("hex").toUpperCase();
    user.verificationCode = verificationCode;
    user.verificationCodeExpires = Date.now() + 24 * 60 * 60 * 1000; // 24 ÿ≥ÿßÿπÿ©
    await user.save();

    // ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑŸÜÿ¥ÿßÿ∑
    await user.logActivity("registered", {
      method: "email",
      ip: req.ip,
      userAgent: req.headers["user-agent"]
    });
    // ÿ•ŸÜÿ¥ÿßÿ° token
    const token = jwt.sign(
      { id: user._id, role: user.role },
      process.env.JWT_SECRET,
      { expiresIn: "7d" }
    );

    // TODO: ÿ•ÿ±ÿ≥ÿßŸÑ verification code ÿπÿ®ÿ± SMS ÿ£Ÿà Email

    res.status(201).json({
      success: true,
      message: "Registration successful. Please verify your account.",
      data: {
        user: {
          id: user._id,
          name: user.name,
          phone: user.phone,
          email: user.email,
          role: user.role,
          isVerified: user.isVerified,
        },
        token,
        verificationCode, // ŸÅŸÇÿ∑ ŸÑŸÑÿ™ÿ∑ŸàŸäÿ±ÿå ÿ•ÿ≤ÿßŸÑÿ© ŸÅŸä ÿßŸÑÿ•ŸÜÿ™ÿßÿ¨
        nextStep: "verify_account",
      },
    });
  } catch (error) {
    console.error("‚ùå Registration error:", {
      message: error.message,
      stack: error.stack,
      name: error.name,
      code: error.code,
      body: req.body
    });

    let statusCode = 500;
    let message = "Registration failed";

    if (error.name === 'ValidationError') {
      statusCode = 400;
      const errors = Object.values(error.errors).map(err => err.message);
      message = `Validation failed: ${errors.join(', ')}`;
    } else if (error.code === 11000) {
      statusCode = 400;
      const field = error.message.includes('email') ? 'Email' : 'Phone';
      message = `${field} already exists`;
    } else if (error.message.includes('next is not a function')) {
      message = "Server configuration error - please contact support";
    }

    res.status(statusCode).json({
      success: false,
      message: message,
      metadata: {
        timestamp: new Date().toISOString(),
        ...(process.env.NODE_ENV === 'development' && {
          error: error.message,
          errorType: error.name
        })
      }
    });
  }
};

/**
 * üìß ÿ™ÿ£ŸÉŸäÿØ ÿßŸÑÿ≠ÿ≥ÿßÿ®
 * POST /api/auth/verify
 */
exports.verifyAccount = async (req, res) => {
  try {
    const { phone, verificationCode } = req.body;

    const user = await User.findOne({
      phone,
      verificationCode,
      verificationCodeExpires: { $gt: Date.now() }
    });

    if (!user) {
      return res.status(400).json({
        success: false,
        message: "Invalid or expired verification code",
      });
    }

    // ÿ™ÿ≠ÿØŸäÿ´ ÿ≠ÿßŸÑÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
    user.isVerified = true;
    user.verificationCode = undefined;
    user.verificationCodeExpires = undefined;
    await user.save();

    // ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑŸÜÿ¥ÿßÿ∑
    await user.logActivity("account_verified", {
      method: "code",
      ip: req.ip,
    }, req);

    // ÿ•ŸÜÿ¥ÿßÿ° token ÿ¨ÿØŸäÿØ
    const token = jwt.sign(
      { id: user._id, role: user.role },
      process.env.JWT_SECRET,
      { expiresIn: "30d" }
    );

    res.json({
      success: true,
      message: "Account verified successfully",
      data: {
        user: {
          id: user._id,
          name: user.name,
          phone: user.phone,
          isVerified: user.isVerified,
        },
        token,
      },
    });
  } catch (error) {
    console.error("‚ùå Verification error:", error.message);
    res.status(500).json({
      success: false,
      message: "Verification failed",
    });
  }
};

/**
 * üîÑ ÿ•ÿπÿßÿØÿ© ÿ•ÿ±ÿ≥ÿßŸÑ ŸÉŸàÿØ ÿßŸÑÿ™ÿ≠ŸÇŸÇ
 * POST /api/auth/resend-verification
 */
exports.resendVerification = async (req, res) => {
  try {
    const { phone } = req.body;

    const user = await User.findOne({ phone, isVerified: false });

    if (!user) {
      return res.status(404).json({
        success: false,
        message: "User not found or already verified",
      });
    }

    // ÿ•ŸÜÿ¥ÿßÿ° ŸÉŸàÿØ ÿ¨ÿØŸäÿØ
    const verificationCode = crypto.randomBytes(3).toString("hex").toUpperCase();
    user.verificationCode = verificationCode;
    user.verificationCodeExpires = Date.now() + 24 * 60 * 60 * 1000;
    await user.save();

    // TODO: ÿ•ÿ±ÿ≥ÿßŸÑ SMS ÿ£Ÿà Email

    res.json({
      success: true,
      message: "Verification code sent successfully",
      data: {
        phone: user.phone,
        verificationCode, // ŸÑŸÑÿ™ÿ∑ŸàŸäÿ± ŸÅŸÇÿ∑
        expiresIn: "24 hours",
      },
    });
  } catch (error) {
    console.error("‚ùå Resend verification error:", error.message);
    res.status(500).json({
      success: false,
      message: "Failed to resend verification",
    });
  }
};

/**
 * üîë ŸÜÿ≥Ÿäÿ™ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±
 * POST /api/auth/forgot-password
 */
exports.forgotPassword = async (req, res) => {
  try {
    const { phone } = req.body;

    const user = await User.findOne({ phone });

    if (!user) {
      return res.status(404).json({
        success: false,
        message: "User not found",
      });
    }

    // ÿ•ŸÜÿ¥ÿßÿ° reset token
    const resetToken = crypto.randomBytes(32).toString("hex");
    user.resetPasswordToken = crypto
      .createHash("sha256")
      .update(resetToken)
      .digest("hex");

    user.resetPasswordExpires = Date.now() + 10 * 60 * 1000; // 10 ÿØŸÇÿßÿ¶ŸÇ
    await user.save();

    // TODO: ÿ•ÿ±ÿ≥ÿßŸÑ SMS ŸÖÿπ ÿßŸÑÿ±ÿßÿ®ÿ∑

    res.json({
      success: true,
      message: "Password reset instructions sent",
      data: {
        phone: user.phone,
        resetToken, // ŸÑŸÑÿ™ÿ∑ŸàŸäÿ± ŸÅŸÇÿ∑
        expiresIn: "10 minutes",
      },
    });
  } catch (error) {
    console.error("‚ùå Forgot password error:", error.message);
    res.status(500).json({
      success: false,
      message: "Failed to process forgot password",
    });
  }
};

/**
 * üîÑ ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±
 * POST /api/auth/reset-password
 */
exports.resetPassword = async (req, res) => {
  try {
    const { phone, resetToken, newPassword } = req.body;

    // ÿ™ÿ¥ŸÅŸäÿ± token ŸÑŸÑÿ®ÿ≠ÿ´
    const hashedToken = crypto
      .createHash("sha256")
      .update(resetToken)
      .digest("hex");

    const user = await User.findOne({
      phone,
      resetPasswordToken: hashedToken,
      resetPasswordExpires: { $gt: Date.now() },
    });

    if (!user) {
      return res.status(400).json({
        success: false,
        message: "Invalid or expired reset token",
      });
    }

    // ÿ™ÿ≠ÿØŸäÿ´ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±
    user.password = await bcrypt.hash(newPassword, 10);
    user.resetPasswordToken = undefined;
    user.resetPasswordExpires = undefined;
    await user.save();

    // ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑŸÜÿ¥ÿßÿ∑
    await user.logActivity("password_reset", {
      method: "reset_token",
      ip: req.ip,
    }, req);

    res.json({
      success: true,
      message: "Password reset successfully",
    });
  } catch (error) {
    console.error("‚ùå Reset password error:", error.message);
    res.status(500).json({
      success: false,
      message: "Failed to reset password",
    });
  }
};

/**
 * üîê ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ÿßŸÑŸÖÿ™ŸÇÿØŸÖ
 * POST /api/auth/login/complete
 */
exports.loginComplete = async (req, res) => {
  try {
    const { phone, password } = req.body;

    const user = await User.findOne({ phone }).select("+password");

    if (!user) {
      return res.status(400).json({
        success: false,
        message: "Invalid credentials",
      });
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±
    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) {
      return res.status(400).json({
        success: false,
        message: "Invalid credentials",
      });
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ≠ÿßŸÑÿ© ÿßŸÑÿ≠ÿ≥ÿßÿ®
    if (!user.isActive) {
      return res.status(403).json({
        success: false,
        message: "Account is deactivated",
      });
    }

    // ÿ™ÿ≠ÿØŸäÿ´ ÿ¢ÿÆÿ± ÿ™ÿ≥ÿ¨ŸäŸÑ ÿØÿÆŸàŸÑ
    user.lastLogin = new Date();
    user.isOnline = true;
    await user.save();

    // ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑŸÜÿ¥ÿßÿ∑
    await user.logActivity("login", {
      method: "password",
      ip: req.ip,
      userAgent: req.headers["user-agent"],
    }, req);

    // ÿ•ŸÜÿ¥ÿßÿ° token
    const token = jwt.sign(
      { id: user._id, role: user.role },
      process.env.JWT_SECRET,
      { expiresIn: "30d" }
    );

    // ÿ•ÿπÿØÿßÿØ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÑŸÑÿ±ÿØ
    const userResponse = {
      id: user._id,
      name: user.name,
      phone: user.phone,
      email: user.email,
      role: user.role,
      image: user.image,
      isVerified: user.isVerified,
      stats: user.stats,
      preferences: user.preferences,
      lastLogin: user.lastLogin,
    };

    res.json({
      success: true,
      message: "Login successful",
      data: {
        user: userResponse,
        token,
        expiresIn: "30 days",
      },
    });
  } catch (error) {
    console.error("‚ùå Login error:", error.message);
    res.status(500).json({
      success: false,
      message: "Login failed",
    });
  }
};

/**
 * üö™ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿÆÿ±Ÿàÿ¨
 * POST /api/auth/logout
 */
exports.logout = async (req, res) => {
  try {
    const userId = req.user.id;

    const user = await User.findById(userId);
    if (user) {
      user.isOnline = false;
      user.lastActivity = new Date();
      await user.save();

      // ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑŸÜÿ¥ÿßÿ∑
      await user.logActivity("logout", {
        ip: req.ip,
      }, req);
    }

    // ÿ•ÿ®ÿ∑ÿßŸÑ token (ŸÅŸä ÿ≠ÿßŸÑÿ© ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ blacklist)
    const token = req.headers.authorization?.split(" ")[1];
    if (token) {
      cache.set(`token:blacklist:${token}`, true, 3600); // ÿ≥ÿßÿπÿ© Ÿàÿßÿ≠ÿØÿ©
    }

    res.json({
      success: true,
      message: "Logged out successfully",
    });
  } catch (error) {
    console.error("‚ùå Logout error:", error.message);
    res.status(500).json({
      success: false,
      message: "Logout failed",
    });
  }
};

/**
 * üîç ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿµŸÑÿßÿ≠Ÿäÿ© Token
 * GET /api/auth/validate
 */
exports.validateToken = async (req, res) => {
  try {
    const token = req.headers.authorization?.split(" ")[1];

    if (!token) {
      return res.status(401).json({
        success: false,
        message: "No token provided",
      });
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ blacklist
    const isBlacklisted = cache.get(`token:blacklist:${token}`);
    if (isBlacklisted) {
      return res.status(401).json({
        success: false,
        message: "Token is invalid",
      });
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿµŸÑÿßÿ≠Ÿäÿ© Token
    const decoded = jwt.verify(token, process.env.JWT_SECRET);

    // ÿ¨ŸÑÿ® ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
    const user = await User.findById(decoded.id)
      .select("-password -verificationCode -resetPasswordToken");

    if (!user) {
      return res.status(401).json({
        success: false,
        message: "User not found",
      });
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ≠ÿßŸÑÿ© ÿßŸÑÿ≠ÿ≥ÿßÿ®
    if (!user.isActive) {
      return res.status(403).json({
        success: false,
        message: "Account is deactivated",
      });
    }

    res.json({
      success: true,
      message: "Token is valid",
      data: {
        user,
        tokenInfo: {
          expiresAt: new Date(decoded.exp * 1000),
          issuedAt: new Date(decoded.iat * 1000),
          role: decoded.role,
        },
      },
    });
  } catch (error) {
    console.error("‚ùå Token validation error:", error.message);

    if (error.name === "JsonWebTokenError") {
      return res.status(401).json({
        success: false,
        message: "Invalid token",
      });
    }

    if (error.name === "TokenExpiredError") {
      return res.status(401).json({
        success: false,
        message: "Token expired",
      });
    }

    res.status(500).json({
      success: false,
      message: "Token validation failed",
    });
  }
};

// ... ÿßŸÑŸÉŸàÿØ ÿßŸÑÿ≠ÿßŸÑŸä ...

/**
 * üîê ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ÿßŸÑŸÖÿ™ŸÇÿØŸÖ
 * POST /api/auth/login/complete
 */
exports.loginComplete = async (req, res) => {
  try {
    const { phone, password, email } = req.body;

    let user;

    // ŸÖÿ≠ÿßŸàŸÑÿ© ÿßŸÑÿØÿÆŸàŸÑ ÿ®ÿßŸÑŸáÿßÿ™ŸÅ ÿ£ŸàŸÑÿßŸã
    if (phone) {
      user = await User.findOne({ phone }).select("+password");
    }
    // ÿ´ŸÖ ŸÖÿ≠ÿßŸàŸÑÿ© ÿßŸÑÿØÿÆŸàŸÑ ÿ®ÿßŸÑÿ®ÿ±ŸäÿØ ÿßŸÑÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜŸä
    else if (email) {
      user = await User.findOne({ email }).select("+password");
    }
    else {
      return res.status(400).json({
        success: false,
        message: "ÿßŸÑŸáÿßÿ™ŸÅ ÿ£Ÿà ÿßŸÑÿ®ÿ±ŸäÿØ ÿßŸÑÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜŸä ŸÖÿ∑ŸÑŸàÿ®"
      });
    }

    if (!user) {
      return res.status(400).json({
        success: false,
        message: "ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿØÿÆŸàŸÑ ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠ÿ©"
      });
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±
    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) {
      return res.status(400).json({
        success: false,
        message: "ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿØÿÆŸàŸÑ ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠ÿ©"
      });
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ≠ÿßŸÑÿ© ÿßŸÑÿ≠ÿ≥ÿßÿ®
    if (!user.isActive) {
      return res.status(403).json({
        success: false,
        message: "ÿßŸÑÿ≠ÿ≥ÿßÿ® ŸÖÿπÿ∑ŸÑÿå Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ™ŸàÿßÿµŸÑ ŸÖÿπ ÿßŸÑÿØÿπŸÖ"
      });
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ™ŸÅÿπŸäŸÑ ÿßŸÑÿ≠ÿ≥ÿßÿ®
    if (!user.isVerified && process.env.REQUIRE_VERIFICATION === 'true') {
      return res.status(403).json({
        success: false,
        message: "Ÿäÿ±ÿ¨Ÿâ ÿ™ŸÅÿπŸäŸÑ ÿ≠ÿ≥ÿßÿ®ŸÉ ÿ£ŸàŸÑÿßŸã",
        requiresVerification: true,
        userId: user._id
      });
    }

    // ÿ™ÿ≠ÿØŸäÿ´ ÿ¢ÿÆÿ± ÿ™ÿ≥ÿ¨ŸäŸÑ ÿØÿÆŸàŸÑ
    user.lastLogin = new Date();
    user.isOnline = true;
    await user.save();

    // ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑŸÜÿ¥ÿßÿ∑
    await user.logActivity("login", {
      method: "password",
      ip: req.ip,
      userAgent: req.headers["user-agent"],
    }, req);

    // ÿ•ŸÜÿ¥ÿßÿ° token
    const token = jwt.sign(
      {
        id: user._id,
        role: user.role,
        name: user.name,
        phone: user.phone
      },
      process.env.JWT_SECRET,
      { expiresIn: process.env.JWT_EXPIRES_IN || "30d" }
    );

    // ÿ•ÿπÿØÿßÿØ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÑŸÑÿ±ÿØ
    const userResponse = {
      id: user._id,
      name: user.name,
      phone: user.phone,
      email: user.email,
      role: user.role,
      image: user.image,
      isVerified: user.isVerified,
      stats: user.stats,
      preferences: user.preferences,
      lastLogin: user.lastLogin,
    };

    res.json({
      success: true,
      message: "ÿ™ŸÖ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ÿ®ŸÜÿ¨ÿßÿ≠",
      data: {
        user: userResponse,
        token,
        expiresIn: process.env.JWT_EXPIRES_IN || "30 days",
      },
    });
  } catch (error) {
    console.error("‚ùå Login error:", error.message);
    res.status(500).json({
      success: false,
      message: "ŸÅÿ¥ŸÑ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ",
    });
  }
};
</file>

<file path="src/models/user.model.js">
const mongoose = require("mongoose");

const userSchema = new mongoose.Schema(
  {
    // ÿßŸÑŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿäÿ©
    name: {
      type: String,
      required: true,
      trim: true,
      minlength: 2,
      maxlength: 100,
    },

    phone: {
      type: String,
      required: true,
      unique: true,
      trim: true,
      match: [/^\+?[\d\s\-\(\)]+$/, "Please enter a valid phone number"],
      index: true,
    },

    email: {
      type: String,
      trim: true,
      lowercase: true,
      sparse: true, // Ÿäÿ≥ŸÖÿ≠ ÿ®ŸÇŸäŸÖ null ŸÅÿ±ŸäÿØÿ©
      match: [/^\S+@\S+\.\S+$/, "Please enter a valid email"],
    },

    password: {
      type: String,
      required: true,
      minlength: 6,
      select: false, // ŸÑÿß ÿ™ÿπÿ±ÿ∂ ÿπŸÜÿØ ÿßŸÑÿßÿ≥ÿ™ÿπŸÑÿßŸÖ
    },

    image: {
      type: String,
      default: null,
    },

    coverImage: {
      type: String,
      default: null,
    },

    // ÿßŸÑÿ£ÿØŸàÿßÿ± ŸàÿßŸÑÿµŸÑÿßÿ≠Ÿäÿßÿ™
    role: {
      type: String,
      enum: ["client", "driver", "admin"],
      default: "client",
      index: true,
    },

    // ÿ≠ÿßŸÑÿ© ÿßŸÑÿ≠ÿ≥ÿßÿ®
    isActive: {
      type: Boolean,
      default: true,
    },

    isVerified: {
      type: Boolean,
      default: false,
    },

    isOnline: {
      type: Boolean,
      default: false,
    },

    // ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿ•ÿ∂ÿßŸÅŸäÿ©
    bio: {
      type: String,
      trim: true,
      maxlength: 500,
    },

    address: {
      type: String,
      trim: true,
    },

    city: {
      type: String,
      trim: true,
      default: "Niamey",
    },

    location: {
      type: {
        type: String,
        enum: ["Point"],
        default: "Point",
      },
      coordinates: {
        type: [Number], // [longitude, latitude]
        default: [2.1098, 13.5126], // Niamey
      },
    },

    dateOfBirth: {
      type: Date,
    },

    gender: {
      type: String,
      enum: ["male", "female", "other", "prefer-not-to-say"],
    },

    // ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
    preferences: {
      notifications: {
        email: { type: Boolean, default: true },
        sms: { type: Boolean, default: true },
        push: { type: Boolean, default: true },
        orderUpdates: { type: Boolean, default: true },
        promotions: { type: Boolean, default: true },
      },
      language: {
        type: String,
        default: "ar",
        enum: ["ar", "fr", "en"],
      },
      currency: {
        type: String,
        default: "XOF",
        enum: ["XOF", "EUR", "USD"],
      },
      theme: {
        type: String,
        default: "light",
        enum: ["light", "dark"],
      },
    },

    // ÿßŸÑÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™
    stats: {
      totalOrders: { type: Number, default: 0 },
      completedOrders: { type: Number, default: 0 },
      cancelledOrders: { type: Number, default: 0 },
      totalSpent: { type: Number, default: 0 },
      averageRating: { type: Number, default: 0 },
      ratingCount: { type: Number, default: 0 },
      lastOrderDate: { type: Date },
      joinedDate: { type: Date, default: Date.now },
    },

    // ŸÑŸÑŸÖŸÜÿØŸàÿ®ŸäŸÜ ŸÅŸÇÿ∑
    driverInfo: {
      licenseNumber: String,
      vehicleType: {
        type: String,
        enum: ["motorcycle", "car", "bicycle", "scooter"],
      },
      vehiclePlate: String,
      isAvailable: { type: Boolean, default: true },
      currentLocation: {
        type: {
          type: String,
          enum: ["Point"],
          default: "Point"
        },
        coordinates: {
          type: [Number],
          default: [2.1098, 13.5126] // ŸÜŸÅÿ≥ ÿ•ÿ≠ÿØÿßÿ´Ÿäÿßÿ™ location
        }
      },
      
      rating: { type: Number, default: 0 },
      totalDeliveries: { type: Number, default: 0 },
      earnings: { type: Number, default: 0 },
      documents: [{
        type: { type: String, enum: ["license", "insurance", "registration"] },
        url: String,
        verified: { type: Boolean, default: false },
        verifiedAt: Date,
      }],
    },

    // ÿ™Ÿàÿßÿ±ŸäÿÆ ŸÖŸáŸÖÿ©
    lastLogin: Date,
    lastActivity: Date,
    passwordChangedAt: Date,
    verificationCode: String,
    verificationCodeExpires: Date,
    resetPasswordToken: String,
    resetPasswordExpires: Date,

    // ÿßŸÑÿ≠ÿ≥ÿßÿ®ÿßÿ™ ÿßŸÑÿßÿ¨ÿ™ŸÖÿßÿπŸäÿ©
    socialAccounts: {
      googleId: String,
      facebookId: String,
      appleId: String,
    },

    // ÿßŸÑŸÖŸÅÿ∂ŸÑÿßÿ™
    favorites: [{
      type: mongoose.Schema.Types.ObjectId,
      ref: "Restaurant",
    }],

    // ÿ≥ÿ¨ŸÑ ÿßŸÑŸÜÿ¥ÿßÿ∑ÿßÿ™
    activityLog: [{
      action: String,
      details: mongoose.Schema.Types.Mixed,
      timestamp: { type: Date, default: Date.now },
      ipAddress: String,
      userAgent: String,
    }],
  },
  {
    timestamps: true,
    toJSON: { virtuals: true },
    toObject: { virtuals: true }
  }
);

// Indexes
userSchema.index({ location: "2dsphere" });
userSchema.index({ "driverInfo.currentLocation": "2dsphere" });
userSchema.index({ role: 1, isActive: 1 });
userSchema.index({ createdAt: -1 });

// Virtuals
userSchema.virtual("age").get(function () {
  if (!this.dateOfBirth) return null;
  const today = new Date();
  const birthDate = new Date(this.dateOfBirth);
  let age = today.getFullYear() - birthDate.getFullYear();
  const monthDiff = today.getMonth() - birthDate.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birthDate.getDate())) {
    age--;
  }
  return age;
});

userSchema.virtual("fullProfile").get(function () {
  return {
    id: this._id,
    name: this.name,
    email: this.email,
    phone: this.phone,
    role: this.role,
    image: this.image,
    isVerified: this.isVerified,
    stats: this.stats,
  };
});

// Middleware
// Middleware - ÿßŸÑÿ≠ŸÑ ÿßŸÑÿ¢ŸÖŸÜ
userSchema.pre("save", async function () {
  if (this.isModified("password")) {
    this.passwordChangedAt = Date.now();
  }
  // ŸÑÿß ÿ™ÿ≥ÿ™ÿÆÿØŸÖ next() - ÿØÿπ async Ÿäÿ™ŸàŸÑŸâ ÿßŸÑÿ£ŸÖÿ±
});
// Methods
// ŸÅŸä user.model.jsÿå ÿßÿ≥ÿ™ÿ®ÿØŸÑ ÿØÿßŸÑÿ© logActivity:
userSchema.methods.logActivity = async function (action, details = {}) {
  try {
    await this.model('User').updateOne(
      { _id: this._id },
      {
        $push: {
          activityLog: {
            $each: [{
              action,
              details,
              ipAddress: details.ip || '',
              userAgent: details.userAgent || '',
              timestamp: new Date()
            }],
            $slice: -100
          }
        },
        $set: { lastActivity: new Date() }
      }
    );

    // ÿ™ÿ≠ÿØŸäÿ´ ŸÖÿ≠ŸÑŸä ŸÅŸÇÿ∑
    this.lastActivity = new Date();
    return this;
  } catch (error) {
    console.error('‚ùå Error logging activity:', error.message);
    return this;
  }
};

// ŸÅŸä user.model.js - ÿ™ÿ≠ÿØŸäÿ´ ÿØÿßŸÑÿ© updateStats
userSchema.methods.updateStats = async function () {
  try {
    const Order = require("./order.model");
    const Review = require("./review.model");

    // ÿßÿ≥ÿ™ÿÆÿØŸÖ aggregate ŸÖÿ®ÿßÿ¥ÿ±ÿ©
    const [orderStats, reviewStats] = await Promise.all([
      Order.aggregate([
        { $match: { user: this._id } },
        {
          $group: {
            _id: null,
            totalOrders: { $sum: 1 },
            completedOrders: {
              $sum: { $cond: [{ $eq: ["$status", "delivered"] }, 1, 0] }
            },
            cancelledOrders: {
              $sum: { $cond: [{ $eq: ["$status", "cancelled"] }, 1, 0] }
            },
            totalSpent: { $sum: "$totalPrice" },
            lastOrderDate: { $max: "$createdAt" },
          },
        },
      ]),
      Review.aggregate([
        { $match: { user: this._id } },
        {
          $group: {
            _id: null,
            averageRating: { $avg: "$rating" },
            ratingCount: { $sum: 1 }
          }
        }
      ])
    ]);

    // ÿ™ÿ≠ÿØŸäÿ´ ŸÖÿ®ÿßÿ¥ÿ± ÿ®ÿØŸàŸÜ save()
    const updateData = {
      'stats.lastOrderDate': orderStats[0]?.lastOrderDate || null
    };

    if (orderStats.length > 0) {
      updateData['stats.totalOrders'] = orderStats[0].totalOrders || 0;
      updateData['stats.completedOrders'] = orderStats[0].completedOrders || 0;
      updateData['stats.cancelledOrders'] = orderStats[0].cancelledOrders || 0;
      updateData['stats.totalSpent'] = orderStats[0].totalSpent || 0;
    }

    if (reviewStats.length > 0) {
      updateData['stats.averageRating'] = reviewStats[0].averageRating || 0;
      updateData['stats.ratingCount'] = reviewStats[0].ratingCount || 0;
    }

    await mongoose.model('User').findByIdAndUpdate(
      this._id,
      { $set: updateData },
      { runValidators: false }
    );

    // ÿ™ÿ≠ÿØŸäÿ´ object ŸÖÿ≠ŸÑŸäÿßŸã
    if (orderStats.length > 0) {
      this.stats.totalOrders = orderStats[0].totalOrders || 0;
      this.stats.completedOrders = orderStats[0].completedOrders || 0;
      this.stats.cancelledOrders = orderStats[0].cancelledOrders || 0;
      this.stats.totalSpent = orderStats[0].totalSpent || 0;
      this.stats.lastOrderDate = orderStats[0].lastOrderDate || null;
    }

    if (reviewStats.length > 0) {
      this.stats.averageRating = reviewStats[0].averageRating || 0;
      this.stats.ratingCount = reviewStats[0].ratingCount || 0;
    }

    return this;
  } catch (error) {
    console.error("Error updating user stats:", error.message);
    return this;
  }
};
module.exports = mongoose.model("User", userSchema);
</file>

<file path="src/app.js">
const express = require("express");
const cors = require("cors");
const helmet = require('helmet');
const compression = require('compression');

// ÿßÿ≥ÿ™Ÿäÿ±ÿßÿØ middlewares
const { 
  apiLimiter, 
  authLimiter, 
  notificationLimiter,
  uploadLimiter 
} = require('./middlewares/rateLimit.middleware');

const { cacheMiddleware, noCache, cacheResponse } = require("./middlewares/cache.middleware");
const { errorHandler, notFoundHandler } = require('./middlewares/errorHandler.middleware');
const { httpLogger, errorLogger } = require('./utils/logger.util');

// ÿßÿ≥ÿ™Ÿäÿ±ÿßÿØ routes
const userRoutes = require("./routes/user.routes");
const authRoutes = require("./routes/auth.routes");
const restaurantRoutes = require("./routes/restaurant.routes");
const orderRoutes = require("./routes/order.routes");
const itemRoutes = require("./routes/item.routes");
const addressRoutes = require("./routes/address.routes");
const restaurantAddressRoutes = require("./routes/restaurantAddress.routes");
const aggregateRoutes = require("./routes/aggregate.routes");
const restaurantCompleteRoutes = require("./routes/restaurantComplete.routes");
const userCompleteRoutes = require("./routes/userComplete.routes");
const notificationRoutes = require("./routes/notification.routes");
const chatRoutes = require("./routes/chat.routes");
const healthRoutes = require('./routes/health.routes');

// ÿßÿ≥ÿ™Ÿäÿ±ÿßÿØ Swagger
const swaggerUi = require('swagger-ui-express');
const swaggerSpecs = require('./config/swagger');
const cache = require('./utils/cache.util');
const app = express();


app.set('trust proxy', 1);
// ========== MIDDLEWARES ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿäÿ© ==========
app.use(cors({
  origin: process.env.CLIENT_URL || 'http://localhost:3001',
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With'],
  credentials: true
}));

app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Middleware ŸÑÿ≤ŸäÿßÿØÿ© ÿ≠ÿ¨ŸÖ ÿßŸÑÿ±ŸÅÿπ
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

app.use(compression({
  level: 6,
  threshold: 100 * 1024 // ÿ∂ÿ∫ÿ∑ ÿßŸÑÿ±ÿØŸàÿØ ÿ£ŸÉÿ®ÿ± ŸÖŸÜ 100KB
}));

// ========== ÿßŸÑÿ£ŸÖÿßŸÜ ==========
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'", 'https://fonts.googleapis.com'],
      scriptSrc: ["'self'", "'unsafe-inline'"],
      imgSrc: ["'self'", "data:", "https://res.cloudinary.com", "https://*.cloudinary.com"],
      connectSrc: ["'self'", "ws://localhost:3000", "ws://localhost:3001", process.env.CLIENT_URL],
      fontSrc: ["'self'", "https://fonts.gstatic.com"],
      objectSrc: ["'none'"],
      mediaSrc: ["'self'"],
      frameSrc: ["'none'"],
    },
  },
  crossOriginEmbedderPolicy: false,
  crossOriginResourcePolicy: { policy: "cross-origin" }
}));

// ÿ•ÿ∂ÿßŸÅÿ© headers ÿ£ŸÖÿßŸÜ ÿ•ÿ∂ÿßŸÅŸäÿ©
app.use((req, res, next) => {
  res.setHeader('X-Content-Type-Options', 'nosniff');
  res.setHeader('X-Frame-Options', 'DENY');
  res.setHeader('X-XSS-Protection', '1; mode=block');
  res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');
  res.setHeader('Permissions-Policy', 'camera=(), microphone=(), geolocation=()');
  next();
});

// ========== Logging ==========
app.use(httpLogger);

// ========== Cache Middleware ==========
app.use(cacheMiddleware);

// ========== Rate Limiting ==========
// ÿ™ÿ∑ÿ®ŸäŸÇ rate limiting ÿπŸÑŸâ ŸÖÿ≥ÿßÿ±ÿßÿ™ ŸÖÿ≠ÿØÿØÿ©
app.use("/api/auth", authLimiter); // ŸÑŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ŸàÿßŸÑÿØÿÆŸàŸÑ
app.use("/api/notifications/send", notificationLimiter); // ŸÑÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ŸÅŸÇÿ∑
app.use("/api/uploads", uploadLimiter); // ŸÑŸÑÿ±ŸÅÿπ
app.use("/api", apiLimiter); // ŸÑŸÑÿπÿßŸÖÿ© (Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ÿ¢ÿÆÿ± rate limiter)

// ========== Swagger Documentation ==========
if (process.env.NODE_ENV !== 'production') {
  app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpecs, {
    explorer: true,
    customCss: '.swagger-ui .topbar { display: none }',
    customSiteTitle: "Food Delivery API Docs",
    swaggerOptions: {
      persistAuthorization: true,
      docExpansion: 'none',
      filter: true,
      displayRequestDuration: true
    }
  }));
}

app.get('/api-docs.json', (req, res) => {
  res.setHeader('Content-Type', 'application/json');
  res.send(swaggerSpecs);
});

// ========== Health Check Route ==========
app.get('/health', (req, res) => {
  res.json({ 
    status: 'healthy', 
    timestamp: new Date().toISOString(),
    version: '1.0.0',
    service: 'Food Delivery API'
  });
});

// ========== Routes ==========
// Public routes
app.get("/", (req, res) => {
  res.json({ 
    message: "Food Delivery API is working ‚úÖ", 
    version: "1.0.0",
    developer: "WALID YAHAYA",
    documentation: "/api-docs",
    health: "/health"
  });
});

// API routes
app.use("/api/users", userRoutes);
app.use("/api/complete", userCompleteRoutes);
app.use("/api/auth", authRoutes);
app.use("/api/restaurants", restaurantRoutes);
app.use("/api/restaurants", restaurantCompleteRoutes);
app.use("/api/items", itemRoutes);
app.use("/api/orders", orderRoutes);
app.use("/api/addresses", addressRoutes);
app.use("/api/restaurant-addresses", restaurantAddressRoutes);
app.use("/api/aggregate", aggregateRoutes);
app.use("/api/notifications", notificationRoutes);
app.use("/api/chat", chatRoutes);
app.use("/api/health", healthRoutes);

// ========== Static Files ==========
app.use('/uploads', express.static('uploads'));

// ========== Error Handling ==========
app.use(notFoundHandler);
app.use(errorLogger);
app.use(errorHandler);

// ========== Cache Monitoring ==========
// ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑŸÉÿßÿ¥ ÿ™ŸÑŸÇÿßÿ¶ŸäÿßŸã ŸÉŸÑ ÿ≥ÿßÿπÿ©
if (process.env.NODE_ENV !== 'production') {
  // Endpoint ŸÑŸÖÿ±ÿßŸÇÿ®ÿ© ÿßŸÑŸÉÿßÿ¥ (ÿßŸÑÿ™ÿ∑ŸàŸäÿ± ŸÅŸÇÿ∑)
  app.get('/api/cache-stats', (req, res) => {
    const stats = cache.getStats();
    res.json({
      success: true,
      data: stats,
      timestamp: new Date()
    });
  });

  // ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑŸÉÿßÿ¥ ÿ™ŸÑŸÇÿßÿ¶ŸäÿßŸã ŸÉŸÑ ÿ≥ÿßÿπÿ©
  setInterval(() => {
    const cleaned = cache.smartCleanup(2, 24);
    if (cleaned > 0) {
      console.log(`üßπ Smart cache cleanup: ${cleaned} keys removed`);
    }
  }, 60 * 60 * 1000);
}

module.exports = app;
</file>

</files>
